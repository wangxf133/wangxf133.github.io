<html>
  <head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>shell语言脚本构建2-使用结构化命令 | xiaofei</title>
<link rel="shortcut icon" href="https://wangxf133.github.io/favicon.ico">
<link rel="stylesheet" href="https://wangxf133.github.io/styles/main.css">

<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/moment.js/2.23.0/moment.min.js"></script>


  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://wangxf133.github.io">
  <img class="avatar" src="https://wangxf133.github.io/images/avatar.png" alt="" width="80px" height="80px">
  </a>
  <h1 class="site-title">
    xiaofei
  </h1>
  <p class="site-description">
    东北师范大学-在读博士
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
</div>

      
        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              shell语言脚本构建2-使用结构化命令
            </h2>
            <div class="post-info">
              <time class="post-time">
                · 2019-03-27 ·
              </time>
              
                <a href="https://wangxf133.github.io/tag/cykUzrlw2" class="post-tags">
                  # 脚本文件
                </a>
              
                <a href="https://wangxf133.github.io/tag/PvD-ng_cF" class="post-tags">
                  # shell语言
                </a>
              
            </div>
            <div class="post-content">
              <!--more-->

<p>许多程序要求对shell脚本中的命令施加一些逻辑流程控制。有一类命令会根据条件使脚本跳过某些命令。这样的命令通常称为结构化命令（structured command）。 </p>
<p>结构化命令允许你改变程序执行的顺序。在bash shell中有不少结构化命令，我们会逐个研究。</p>
<p>本章来看一下if-then和case语句。 </p>
<h2 id="使用 if-then语句">使用 if-then语句</h2><p>最基本的结构化命令就是if-then语句。if-then语句有如下格式。</p>
<pre><code class="language-sh">if command 
then 
    commands 
fi </code></pre>
<p>如果你在用其他编程语言的if-then语句，这种形式可能会让你有点困惑。在其他编程语言中，if语句之后的对象是一个等式，这个等式的求值结果为TRUE或FALSE。但bash shell的if语句并不是这么做的。<br>bash shell的if语句会运行if后面的那个命令。如果该命令的退出状态码（参见上篇文章）是0（该命令成功运行），位于then部分的命令就会被执行。如果该命令的退出状态码是其他值，then部分的命令就不会被执行，bash shell会继续执行脚本中的下一个命令。<strong>fi语句用来表示if-then语句到此结束</strong>。 </p>
<p>这里有个简单的例子可解释这个概念。 </p>
<pre><code class="language-sh">$ cat test1.sh 
#!/bin/bash 
# testing the if statement 
if pwd 
then 
    echo &quot;It worked&quot; 
fi </code></pre>
<p>这个脚本在if行采用了pwd命令。如果命令成功结束，echo语句就会显示该文本字符串。在命令行运行该脚本时，会得到如下结果。</p>
<pre><code class="language-sh">$ sh test1.sh 
/home/Christine 
It worked
</code></pre>
<p><strong>shell执行了if行中的pwd命令。由于退出状态码是0，它就又执行了then部分的echo语句。</strong></p>
<p>另外一个例子:</p>
<pre><code class="language-sh">$ cat test2.sh 
#!/bin/bash 
# testing a bad command 
if IamNotaCommand 
then 
   echo &quot;It worked&quot; 
fi 
echo &quot;We are outside the if statement&quot; </code></pre>
<pre><code class="language-sh">$ sh test2.sh 
test2.sh: line 3: IamNotaCommand: command not found 
We are outside the if statement </code></pre>
<p>在这个例子中，我们在if语句行故意放了一个不能工作的命令。由于这是个错误的命令，所以它会产生一个非零的退出状态码，且bash shell会跳过then部分的echo语句。还要注意，运行if语句中的那个错误命令所生成的错误消息依然会显示在脚本的输出中。</p>
<blockquote>
<p>有时你可能不想看到错误信息，等以后有机会了在学习。（先挖个坑） </p>
</blockquote>
<hr>
<p>说明<br>你可能在有些脚本中看到过if-then语句的另一种形式： </p>
<pre><code>if command; then 
 commands 
fi </code></pre><p>通过把分号放在待求值的命令尾部，就可以将then语句放在同一行上了，这样看起来更像其他编程语言中的if-then语句。</p>
<hr>
<p>在then部分，你可以使用不止一条命令。可以像在脚本中的其他地方一样在这里列出多条命令。bash shell会将这些命令当成一个块，如果if语句行的命令的退出状态值为0，所有的命令都会被执行；如果if语句行的命令的退出状态不为0，所有的命令都会被跳过。 </p>
<pre><code class="language-sh">$ cat test3.sh 
#!/bin/bash 
# testing multiple commands in the then section 
# 
testuser=Christine 
# 
if grep $testuser /etc/passwd 
then 
   echo &quot;This is my first command&quot; 
   echo &quot;This is my second command&quot; 
   echo &quot;I can even put in other commands besides&quot;
   ls -a /home/$testuser/.b* 
fi </code></pre>
<p>if语句行使用grep命令在/etc/passwd文件中查找某个用户名当前是否在系统上使用。如果有用户使用了那个登录名，脚本会显示一些文本信息并列出该用户HOME目录的bash文件。 </p>
<pre><code class="language-sh">[xiaofei@DESKTOP-U55QOF8 12]$sh test3.sh
xiaofei:x:1000:1000:,,,:/home/xiaofei:/bin/bash
This is my first command
This is my second command
I can even put in other commands besides echo:
/home/xiaofei/.bash_history  /home/xiaofei/.bashrc
/home/xiaofei/.bash_logout   /home/xiaofei/.bashrc-miniconda3.bak</code></pre>
<p>但是，如果将testuser变量设置成一个系统上不存在的用户，则什么都不会显示。<br>如果在这里显示的一些消息可说明这个用户名在系统中未找到，这样可能就会显得更友好。是的，可以用if-then语句的另外一个特性来做到这一点。 </p>
<h2 id="if-then-else语句">if-then-else语句</h2><p>在if-then语句中，不管命令是否成功执行，你都只有一种选择。如果命令返回一个非零退出状态码(不正常运行)，bash shell会继续执行脚本中的下一条命令。在这种情况下，如果能够执行另一组命令就好了。这正是if-then-else语句的作用。<br>if-then-else语句在语句中提供了另外一组命令。 </p>
<pre><code>if command 
then 
   commands 
else 
   commands 
fi </code></pre><p>当if语句中的命令返回退出状态码0时，then部分中的命令会被执行，这跟普通的if-then语句一样。当if语句中的命令返回非零退出状态码时，bash shell会执行else部分中的命令。<br>现在可以复制并修改测试脚本来加入else部分。</p>
<pre><code class="language-sh">#!/bin/bash
# testing multiple commands in the then section
#
testuser=xiaofei  
#testuser=Christine
#
if grep $testuser /etc/passwd
then
   echo &quot;The bash files for user $testuser are:&quot;
   ls -a /home/$testuser/.b*
   echo
else
   echo &quot;The user $testuser does not exist on this system.&quot;
   echo
fi</code></pre>
<p>这样就更友好了。跟then部分一样，else部分可以包含多条命令。fi语句说明else部分结束了。 </p>
<h2 id="嵌套 if">嵌套 if</h2><p>有时你需要检查脚本代码中的多种条件。对此，可以使用嵌套的if-then语句。<br>要检查/etc/passwd文件中是否存在某个用户名以及该用户的目录是否尚在，可以使用嵌套的if-then语句。嵌套的if-then语句位于主if-then-else语句的else代码块中。 </p>
<pre><code class="language-sh">$ ls -d /home/NoSuchUser/ 
/home/NoSuchUser/ 
$ 
$ cat test5.sh 
#!/bin/bash 
# Testing nested ifs 
# 
testuser=NoSuchUser 
# 
if grep $testuser /etc/passwd 
then 
   echo &quot;The user $testuser exists on this system.&quot; 
else 
   echo &quot;The user $testuser does not exist on this system.&quot; 
   if ls -d /home/$testuser/ 
   then 
      echo &quot;However, $testuser has a directory.&quot; 
   fi 
fi 
</code></pre>
<p>运行结果</p>
<pre><code class="language-sh">$ sh test5.sh 
The user NoSuchUser does not exist on this system. 
/home/NoSuchUser/ 
However, NoSuchUser has a directory. 
$ </code></pre>
<p>这个脚本准确无误地发现，尽管登录名已经从/etc/passwd中删除了，但是该用户的目录仍然存在。在脚本中使用这种嵌套if-then语句的问题在于代码不易阅读，很难理清逻辑流程。</p>
<p>可以使用else部分的另一种形式：elif。这样就不用再书写多个if-then语句了。<strong>elif使用另一个if-then语句延续else部分。</strong></p>
<pre><code class="language-sh">if command1 
then 
   commands 
elif command2 
then 
    more commands 
fi</code></pre>
<p>elif语句行提供了另一个要测试的命令，这类似于原始的if语句行。如果elif后命令的退出状态码是0，则bash会执行第二个then语句部分的命令。使用这种嵌套方法，代码更清晰，逻辑更易懂。</p>
<pre><code class="language-sh">$ cat test5.sh 
#!/bin/bash 
# Testing nested ifs - use elif 
# 
testuser=NoSuchUser 
# 
if grep $testuser /etc/passwd 
then 
   echo &quot;The user $testuser exists on this system.&quot; 
# 
elif ls -d /home/$testuser 
then 
   echo &quot;The user $testuser does not exist on this system.&quot; 
   echo &quot;However, $testuser has a directory.&quot; 
# 
fi </code></pre>
<p>运行结果：</p>
<pre><code class="language-sh">$ sh test5.sh 
/home/NoSuchUser 
The user NoSuchUser does not exist on this system. 
However, NoSuchUser has a directory. </code></pre>
<p>甚至可以更进一步，让脚本检查拥有目录的不存在用户以及没有拥有目录的不存在用户。这可以通过在嵌套elif中加入一个else语句来实现。 </p>
<pre><code class="language-sh">#!/bin/bash
# Testing nested ifs - use elif &amp; else

testuser=NoSuchUser
#testuser=xiaofei


if grep $testuser /etc/passwd
then
    echo &quot;The user $testuser exists on this system.&quot;
elif ls -d /home/$testuser
then
    echo &quot;The user $testuser does not exist on this system.&quot;
    echo &quot;However, $testuser has a directory.&quot;
else
    echo &quot;The user $testuser does not exist on this system.&quot;
    echo &quot;And, $testuser does not have a directory.&quot;
fi</code></pre>
<p>在/home/NoSuchUser目录被删除之前，这个测试脚本执行的是elif语句，返回零值的退出状态。因此elif的then代码块中的语句得以执行。删除了/home/NoSuchUser目录之后，elif语句返回的是非零值的退出状态。这使得elif块中的else代码块得以执行。 </p>
<hr>
<p>窍门:<br>记住，在elif语句中，紧跟其后的else语句属于elif代码块。它们并不属于之前的if-then代码块。 </p>
<hr>
<p>可以继续将多个elif语句串起来，形成一个大的if-then-elif嵌套组合。 </p>
<pre><code class="language-sh">if command1 
then 
    command set 1 
elif command2 
then 
   command set 2 
elif command3 
then 
   command set 3 
elif command4 
then 
   command set 4 
fi </code></pre>
<p>每块命令都会根据命令是否会返回退出状态码0来执行。记住，bash shell会依次执行if语句，只有第一个返回退出状态码0的语句中的then部分会被执行。 </p>
<p>尽管使用了elif语句的代码看起来更清晰，但是脚本的逻辑仍然会让人犯晕。在后面中你会看到如何使用case命令代替if-then语句的大量嵌套。 </p>
<h2 id="test命令">test命令</h2><p>到目前为止，在if语句中看到的都是普通shell命令。你可能想问，if-then语句是否能测试命令退出状态码之外的条件</p>
<p>答案是不能。但在bash shell中有个好用的工具可以帮你通过if-then语句测试其他条件。</p>
<p>test命令提供了在if-then语句中测试不同条件的途径。如果test命令中列出的条件成立，test命令就会退出并返回退出状态码0。这样if-then语句就与其他编程语言中的if-then语句以类似的方式工作了。如果条件不成立，test命令就会退出并返回非零的退出状态码，这使得if-then语句不会再被执行。 </p>
<p>test命令的格式非常简单。 </p>
<pre><code class="language-sh">test condition </code></pre>
<p>condition是test命令要测试的一系列参数和值。当用在if-then语句中时，test命令看起来是这样的。 </p>
<pre><code class="language-sh">if test condition 
then 
   commands 
fi </code></pre>
<p>如果不写test命令的condition部分，它会以非零的退出状态码退出，并执行else语句块。</p>
<pre><code class="language-sh">$ cat test6.sh 
#!/bin/bash 
# Testing the test command 
# 
if test 
then 
   echo &quot;No expression returns a True&quot; 
else 
   echo &quot;No expression returns a False&quot; 
fi </code></pre>
<pre><code class="language-sh">$ sh test6.sh 
No expression returns a False </code></pre>
<p>当你加入一个条件时，test命令会测试该条件。例如，可以使用test命令确定变量中是否有内容。这只需要一个简单的条件表达式。 </p>
<pre><code class="language-sh">$ cat test6.sh 
#!/bin/bash 
# Testing the test command 
# 
my_variable=&quot;Full&quot; 
# 
if test $my_variable 
then 
   echo &quot;The $my_variable expression returns a True&quot; 
# 
else 
   echo &quot;The $my_variable expression returns a False&quot; 
fi 

$ sh test6.sh 
The Full expression returns a True </code></pre>
<p>变量my_variable中包含有内容（Full），因此当test命令测试条件时，返回的退出状态为0。这使得then语句块中的语句得以执行。<br>如你所料，如果该变量中没有包含内容，就会出现相反的情况。 </p>
<pre><code class="language-sh">$ cat test6.sh 
#!/bin/bash 
# Testing the test command 
# 
my_variable=&quot;&quot; 
# 
if test $my_variable 
then 
   echo &quot;The $my_variable expression returns a True&quot; 
# 
else 
   echo &quot;The $my_variable expression returns a False&quot; 
fi 

$ sh test6.sh 
The  expression returns a False </code></pre>
<p>bash shell提供了另一种条件测试方法，无需在if-then语句中声明test命令。</p>
<pre><code>if [ condition ] 
then 
   commands 
fi </code></pre><p>方括号定义了测试条件。<strong>注意，第一个方括号之后和第二个方括号之前必须加上一个空格，否则就会报错。</strong><br>test命令可以判断三类条件： </p>
<ul>
<li>数值比较 </li>
<li>字符串比较 </li>
<li>文件比较</li>
</ul>
<h4 id="数值比较">数值比较</h4><p>使用test命令最常见的情形是对两个数值进行比较。下表列出了测试两个值时可用的条件参数。<br><img src="https://s1.ax2x.com/2018/08/07/55MplR.png" alt="55MplR.png"></p>
<p>数值条件测试可以用在数字和变量上。</p>
<pre><code class="language-sh">$ cat numeric_test.sh 
#!/bin/bash 
# Using numeric test evaluations 

value1=10 
value2=11 

if [ $value1 -gt 5 ] 
then 
    echo &quot;The test value $value1 is greater than 5&quot; 
fi 
# 
if [ $value1 -eq $value2 ] 
then 
    echo &quot;The values are equal&quot; 
else 
    echo &quot;The values are different&quot; 
fi </code></pre>
<p>第一个条件测试： </p>
<pre><code>if [ $value1 -gt 5 ] </code></pre><p>测试变量value1的值是否大于5。第二个条件测试： </p>
<pre><code>if [ $value1 -eq $value2 ] </code></pre><p>测试变量value1的值是否和变量value2的值相等。两个数值条件测试的结果和预想一致。 </p>
<pre><code class="language-sh">$ sh numeric_test.sh 
The test value 10 is greater than 5 
The values are different 
$ </code></pre>
<p>但是涉及浮点值时，数值条件测试会有一个限制。 </p>
<pre><code class="language-sh">$ cat floating_point_test.sh 
#!/bin/bash 
# Using floating point numbers in test evaluations 
# 
value1=5.555 
# 
echo &quot;The test value is $value1&quot; 
# 
if [ $value1 -gt 5 ] 
then 
    echo &quot;The test value $value1 is greater than 5&quot; 
fi 
# 
$ sh floating_point_test.sh 
The test value is 5.555 
./floating_point_test.sh: line 8:  
[: 5.555: integer expression expected </code></pre>
<p>此例，变量value1中存储的是浮点值。接着，脚本对这个值进行了测试。显然这里出错了。记住，bash shell只能处理整数。如果你只是要通过echo语句来显示这个结果，那没问题。但是，在基于数字的函数中就不行了，例如我们的数值测试条件。最后一行就说明我们不能在test命令中使用浮点值。 </p>
<h4 id="字符串比较">字符串比较</h4><p>条件测试还允许比较字符串值。比较字符串比较烦琐，你马上就会看到。下表列出了可用的字符串比较功能。 </p>
<p><img src="https://s1.ax2x.com/2018/08/07/55MuFr.png" alt="55MuFr.png"></p>
<h5 id="字符串相等性">字符串相等性</h5><p>字符串的相等和不等条件不言自明，很容易看出两个字符串值是否相同。 </p>
<pre><code class="language-sh">$ cat test7.sh 
#!/bin/bash
# testing string equality
testuser=xiaofei
#
if [ $USER = $testuser ]
then
   echo &quot;Welcome $testuser&quot;
fi


$ sh test7.sh 
Welcome xiaofei </code></pre>
<p>字符串不等条件也可以判断两个字符串是否有相同的值。 </p>
<pre><code class="language-sh">$ cat test8.sh 
#!/bin/bash 
# testing string equality 
testuser=baduser 
# 
if [ $USER != $testuser ] 
then 
   echo &quot;This is not $testuser&quot; 
else 
   echo &quot;Welcome $testuser&quot; 
fi


$ sh test8.sh 
This is not baduser </code></pre>
<p>记住，在比较字符串的相等性时，比较测试会将所有的标点和大小写情况都考虑在内。</p>
<h5 id="字符串顺序">字符串顺序</h5><p>要测试一个字符串是否比另一个字符串大就是麻烦的开始。当要开始使用测试条件的大于或小于功能时，就会出现两个经常困扰shell程序员的问题：</p>
<ul>
<li>大于号和小于号必须转义，否则shell会把它们当作重定向符号，把字符串值当作文件名； </li>
<li>大于和小于顺序和sort命令所采用的不同。 </li>
</ul>
<p>在编写脚本时，第一条可能会导致一个不易察觉的严重问题。下面的例子展示了shell脚本编程初学者时常碰到的问题。 </p>
<pre><code class="language-sh">$ cat badtest.sh 
#!/bin/bash 
# mis-using string comparisons 
# 
val1=baseball 
val2=hockey 
# 
if [ $val1 &gt; $val2 ] 
then 
   echo &quot;$val1 is greater than $val2&quot; 
else 
   echo &quot;$val1 is less than $val2&quot; 
fi 


$ ./badtest.sh 
baseball is greater than hockey 
$ ls -l hockey 
-rw-r--r--    1 rich     rich            0 Sep 30 19:08 hockey 
</code></pre>
<p>这个脚本中只用了大于号，没有出现错误，但结果是错的。脚本把大于号解释成了输出重定向。因此，它创建了一个名为hockey的文件。由于重定向的顺利完成，test命令返回了退出状态码0，if语句便以为所有命令都成功结束了。<br>要解决这个问题，就需要正确转义大于号。 </p>
<pre><code class="language-sh">$ cat test9.sh 
#!/bin/bash 
# mis-using string comparisons 
# 
val1=baseball 
val2=hockey 
# 
if [ $val1 \&gt; $val2 ] 
then 
  echo &quot;$val1 is greater than $val2&quot; 
else 
   echo &quot;$val1 is less than $val2&quot; 
fi 

$ sh test9.sh 
baseball is less than hockey </code></pre>
<p>这个答案就对了</p>
<p>第二个问题更细微，除非你经常处理大小写字母，否则几乎遇不到。sort命令处理大写字母的方法刚好跟test命令相反。让我们在脚本中测试一下这个特性。 </p>
<pre><code class="language-sh">$ cat test9b.sh 
#!/bin/bash 
# testing string sort order 
val1=Testing 
val2=testing 
# 
if [ $val1 \&gt; $val2 ] 
then 
   echo &quot;$val1 is greater than $val2&quot; 
else 
   echo &quot;$val1 is less than $val2&quot; 
fi 
$  
$ ./test9b.sh 
Testing is less than testing 
$  
$ sort testfile 
testing 
Testing</code></pre>
<p>在比较测试中，大写字母被认为是小于小写字母的。但sort命令恰好相反。当你将同样的字符串放进文件中并用sort命令排序时，小写字母会先出现。这是由各个命令使用的排序技术不同造成的。</p>
<p>比较测试中使用的是标准的ASCII顺序，根据每个字符的ASCII数值来决定排序结果。sort命令使用的是系统的本地化语言设置中定义的排序顺序。对于英语，本地化设置指定了在排序顺序中小写字母出现在大写字母前。 </p>
<h5 id="字符串大小">字符串大小</h5><p>-n和-z可以检查一个变量是否含有数据。</p>
<pre><code class="language-sh">$ cat test10.sh 
#!/bin/bash 
# testing string length 
val1=testing 
val2=&#39;&#39; 
# 
if [ -n $val1 ] 
then 
   echo &quot;The string &#39;$val1&#39; is not empty&quot; 
else 
   echo &quot;The string &#39;$val1&#39; is empty&quot; 
fi 
# 
if [ -z $val2 ] 
then 
   echo &quot;The string &#39;$val2&#39; is empty&quot; 
else 
   echo &quot;The string &#39;$val2&#39; is not empty&quot; 
fi 
# 
if [ -z $val3 ] 
then 
   echo &quot;The string &#39;$val3&#39; is empty&quot; 
else 
   echo &quot;The string &#39;$val3&#39; is not empty&quot; 
fi 
$  
$ ./test10.sh 
The string &#39;testing&#39; is not empty 
The string &#39;&#39; is empty 
The string &#39;&#39; is empty </code></pre>
<p>这个例子创建了两个字符串变量。val1变量包含了一个字符串，val2变量包含的是一个空字符串。后续的比较如下： </p>
<pre><code>if [ -n $val1 ] </code></pre><p>判断val1变量是否长度非0，而它的长度正好非0，所以then部分被执行了。 </p>
<pre><code>if [ -z $var2 ]  </code></pre><p>判断val2变量是否长度为0，而它正好长度为0，所以then部分被执行了。 </p>
<pre><code>if [ -z $val3 ]  </code></pre><p>判断val3变量是否长度为0。这个变量并未在shell脚本中定义过，所以它的字符串长度仍然为0，尽管它未被定义过。 </p>
<h4 id="文件比较">文件比较</h4><p>最后一类比较测试很有可能是shell编程中最为强大、也是用得最多的比较形式。它允许你测试Linux文件系统上文件和目录的状态。下表列出了这些比较。<br><img src="https://s1.ax2x.com/2018/08/07/55MyEl.png" alt="55MyEl.png"><br>这些测试条件使你能够在shell脚本中检查文件系统中的文件。它们经常出现在需要进行文件访问的脚本中。鉴于其使用广泛，我们来逐个看看。 </p>
<h5 id="检查目录">检查目录</h5><p>-d测试会检查指定的目录是否存在于系统中。如果你打算将文件写入目录或是准备切换到某个目录中，先进行测试总是件好事情。  </p>
<pre><code class="language-sh">$ cat test11.sh 
#!/bin/bash 
# Look before you leap 
# 
jump_directory=/home/arthur 
# 
if [ -d $jump_directory ] 
then 
   echo &quot;The $jump_directory directory exists&quot; 
   cd $jump_directory 
   ls 
else 
   echo &quot;The $jump_directory directory does not exist&quot; 
fi 
#

$ sh test11.sh 
The /home/arthur directory does not exist 
</code></pre>
<p>示例代码中使用了-d测试条件来检查jump_directory变量中的目录是否存在：若存在，就使用cd命令切换到该目录并列出目录中的内容；若不存在，脚本就输出一条警告信息，然后退出。</p>
<h5 id="检查对象是否存在">检查对象是否存在</h5><p>-e比较允许你的脚本代码在使用文件或目录前先检查它们是否存在。 </p>
<pre><code class="language-sh">$ cat test12.sh 
#!/bin/bash 
# Check if either a directory or file exists 
# 
location=$HOME 
file_name=&quot;sentinel&quot; 
# 
if [ -e $location ] 
then  #Directory does exist 
   echo &quot;OK on the $location directory.&quot; 
   echo &quot;Now checking on the file, $file_name.&quot; 
   # 
   if [ -e $location/$file_name ] 
   then #File does exist 
       echo &quot;OK on the filename&quot; 
       echo &quot;Updating Current Date...&quot; 
       date &gt;&gt; $location/$file_name 
   # 
   else #File does not exist 
       echo &quot;File does not exist&quot; 
       echo &quot;Nothing to update&quot; 
   fi 
# 
else   #Directory does not exist 
   echo &quot;The $location directory does not exist.&quot; 
   echo &quot;Nothing to update&quot; 
fi 
# 
$ 
$ sh test12.sh 
OK on the /home/Christine directory. 
Now checking on the file, sentinel. 
File does not exist 
Nothing to update 

$ 
$ touch sentinel 
$
$ sh test12.sh 
OK on the /home/Christine directory. 
Now checking on the file, sentinel. 
OK on the filename 
Updating Current Date... 
$ </code></pre>
<p>第一次检查用-e比较来判断用户是否有$HOME目录。如果有，接下来的-e比较会检查sentinel文件是否存在于$HOME目录中。如果不存在，shell脚本就会提示该文件不存在，不需要进行更新。 </p>
<p>为确保更新操作能够正常进行，我们创建了sentinel文件，然后重新运行这个shell脚本。这一次在进行条件测试时，$HOME和sentinel文件都存在，因此当前日期和时间就被追加到了文件中。</p>
<h5 id="检查文件">检查文件</h5><p>-e比较可用于文件和目录。要确定指定对象为文件，必须用-f比较。 </p>
<pre><code class="language-sh">$ cat test13.sh 
#!/bin/bash 
# Check if either a directory or file exists 
# 
item_name=$HOME 
echo 
echo &quot;The item being checked: $item_name&quot; 
echo 
# 
if [ -e $item_name ] 
then  #Item does exist 
   echo &quot;The item, $item_name, does exist.&quot; 
   echo &quot;But is it a file?&quot; 
   echo 
   # 
   if [ -f $item_name ] 
   then #Item is a file 
       echo &quot;Yes, $item_name is a file.&quot; 
   # 
   else #Item is not a file 
       echo &quot;No, $item_name is not a file.&quot; 
   fi 
# 
else   #Item does not exist 
   echo &quot;The item, $item_name, does not exist.&quot; 
   echo &quot;Nothing to update&quot; 
fi 
# 
$ sh test13.sh 

The item being checked: /home/Christine 

The item, /home/Christine, does exist. 
But is it a file? 

No, /home/Christine is not a file. 
$ </code></pre>
<p>这一小段脚本进行了大量的检查！它首先使用-e比较测试$HOME是否存在。如果存在，继续用-f来测试它是不是一个文件。如果它不是文件（当然不会是了），就会显示一条消息，表明这不是一个文件。<br>我们对变量item_name作了一个小小的修改，将目录$HOME替换成文件$HOME/sentinel，结果就不一样了。 </p>
<pre><code class="language-sh">$ nano test13.sh 
$ 
$ cat test13.sh 
#!/bin/bash 
# Check if either a directory or file exists 
# 
item_name=$HOME/sentinel 

[...] 

$ 
$ ./test13.sh 

The item being checked: /home/Christine/sentinel 

The item, /home/Christine/sentinel, does exist. 
But is it a file? 

Yes, /home/Christine/sentinel is a file. 
$ </code></pre>
<p>这里只列出了脚本test13.sh的部分代码，因为只改变了脚本变量item_name的值。当运行这个脚本时，对$HOME/sentinel进行的-f测试所返回的退出状态码为0，then语句得以执行，然后输出消息：Yes, /home/Christine/sentinel is a file。 </p>
<h5 id="检查是否可读">检查是否可读</h5><p>在尝试从文件中读取数据之前，最好先测试一下文件是否可读。可以使用-r比较测试。</p>
<pre><code class="language-sh">$ cat test14.sh 
#!/bin/bash 
# testing if you can read a file 
pwfile=/etc/shadow 
# 
# first, test if the file exists, and is a file 
if [ -f $pwfile ] 
then 
   # now test if you can read it 
   if [ -r $pwfile ] 
   then 
      tail $pwfile 
   else 
      echo &quot;Sorry, I am unable to read the $pwfile file&quot; 
   fi 
else 
   echo &quot;Sorry, the file $file does not exist&quot; 
fi 
$  
$ ./test14.sh 
Sorry, I am unable to read the /etc/shadow file 
$ 
</code></pre>
<p>/etc/shadow文件含有系统用户加密后的密码，所以它对系统上的普通用户来说是不可读的。-r比较确定该文件不允许进行读取，因此测试失败，bash shell执行了if-then语句的else部分。</p>
<h5 id="检查空文件">检查空文件</h5><p>应该用-s比较来检查文件是否为空，尤其是在不想删除非空文件的时候。<strong>要留心的是，当-s比较成功时，说明文件中有数据。</strong> </p>
<pre><code class="language-sh">$ cat test15.sh 
#!/bin/bash 
# Testing if a file is empty 
# 
file_name=$HOME/sentinel 
# 
if [ -f $file_name ] 
then 
   if [ -s $file_name ] 
   then 
      echo &quot;The $file_name file exists and has data in it.&quot; 
      echo &quot;Will not remove this file.&quot; 
# 
   else 
      echo &quot;The $file_name file exists, but is empty.&quot; 
      echo &quot;Deleting empty file...&quot; 
      rm $file_name 
   fi 
else 
   echo &quot;File, $file_name, does not exist.&quot; 
fi 
# 
$ ls -l $HOME/sentinel 
-rw-rw-r--. 1 Christine Christine 29 Jun 25 05:32 /home/Christine/sentinel 
$ 
$ ./test15.sh 
The /home/Christine/sentinel file exists and has data in it. 
Will not remove this file. 
$</code></pre>
<p>-f比较测试首先测试文件是否存在。如果存在，由-s比较来判断该文件是否为空。空文件会被删除。可以从ls –l的输出中看出sentinel并不是空文件，因此脚本并不会删除它。 </p>
<h5 id="检查是否可写">检查是否可写</h5><p>-w比较会判断你对文件是否有可写权限。脚本test16.sh只是脚本test13.sh的修改版。现在不单检查item_name是否存在、是否为文件，还会检查该文件是否有写入权限。 </p>
<pre><code class="language-sh">$ cat test16.sh 
#!/bin/bash 
# Check if a file is writable. 
# 
item_name=$HOME/sentinel 
echo 
echo &quot;The item being checked: $item_name&quot; 
echo 
[...] 
       echo &quot;Yes, $item_name is a file.&quot; 
       echo &quot;But is it writable?&quot; 
       echo 
       # 
       if [ -w $item_name ] 
       then #Item is writable 
            echo &quot;Writing current time to $item_name&quot; 
            date +%H%M &gt;&gt; $item_name 
       # 
       else #Item is not writable 
            echo &quot;Unable to write to $item_name&quot; 
       fi 
   # 
   else #Item is not a file 
       echo &quot;No, $item_name is not a file.&quot; 
   fi 

[...]


$ 
$ ls -l sentinel 
-rw-rw-r--. 1 Christine Christine 0 Jun 27 05:38 sentinel 
$ 
$ sh test16.sh 

The item being checked: /home/Christine/sentinel 

The item, /home/Christine/sentinel, does exist. 
But is it a file? 

Yes, /home/Christine/sentinel is a file. 
But is it writable? 

Writing current time to /home/Christine/sentinel 
$ 
$ cat sentinel 
0543 
$ 
</code></pre>
<p>变量item_name被设置成$HOME/sentinel，该文件允许用户进行写入。因此当脚本运行时，-w测试表达式会返回非零退出状态，然后执行then代码块，将时间戳写入文件sentinel中.<br>如果使用chmod关闭文件sentinel的用户 写入权限，-w测试表达式会返回非零的退出状态码，时间戳不会被写入文件。</p>
<pre><code class="language-sh">$ chmod u-w sentinel 
$ 
$ ls -l sentinel 
-r--rw-r--. 1 Christine Christine 5 Jun 27 05:43 sentinel 
$ 
$ ./test16.sh 

The item being checked: /home/Christine/sentinel 
The item, /home/Christine/sentinel, does exist. 
But is it a file? 

Yes, /home/Christine/sentinel is a file. 
But is it writable? 

Unable to write to /home/Christine/sentinel 
$ </code></pre>
<p>chmod命令可用来为读者再次回授写入权限。这会使得写入测试表达式返回退出状态码0，并允许一次针对文件的写入尝试。</p>
<h5 id="检查文件是否可以执行">检查文件是否可以执行</h5><p>-x比较是判断特定文件是否有执行权限的一个简单方法。虽然可能大多数命令用不到它，但如果你要在shell脚本中运行大量脚本，它就能发挥作用。 </p>
<pre><code class="language-sh">$ cat test17.sh 
#!/bin/bash 
# testing file execution 
# 
if [ -x test16.sh ] 
then 
   echo &quot;You can run the script: &quot; 
   ./test16.sh 
else 
   echo &quot;Sorry, you are unable to execute the script&quot; 
fi 
$  
$ ./test17.sh 
You can run the script: 

[...] 

$  
$ chmod u-x test16.sh 
$  
$ ./test17.sh 
Sorry, you are unable to execute the script 
$ </code></pre>
<p>这段示例shell脚本用-x比较来测试是否有权限执行test16.sh脚本。如果有权限，它会运行这个脚本。在首次成功运行test16.sh脚本后，更改文件的权限。这次，-x比较失败了，因为你已经没有test16.sh脚本的执行权限了。 </p>
<h5 id="检查所属关系">检查所属关系</h5><p>-O比较可以测试出你是否是文件的属主。 </p>
<pre><code class="language-sh">$ cat test18.sh 
#!/bin/bash 
# check file ownership 
# 
if [ -O /etc/passwd ] 
then 
   echo &quot;You are the owner of the /etc/passwd file&quot; 
else 
   echo &quot;Sorry, you are not the owner of the /etc/passwd file&quot; 
fi 
$  
$ ./test18.sh 
Sorry, you are not the owner of the /etc/passwd file 
$  </code></pre>
<p>这段脚本用-O比较来测试运行该脚本的用户是否是/etc/passwd文件的属主。这个脚本是运行在普通用户账户下的，所以测试失败了。(就是看这个文件什么的是属于哪个账户的)))</p>
<h5 id="检查默认属组关系">检查默认属组关系</h5><p>-G比较会检查文件的默认组，如果它匹配了用户的默认组，则测试成功。由于-G比较只会检查默认组而非用户所属的所有组，这会叫人有点困惑。这里有个例子。 </p>
<pre><code class="language-sh">$ cat test19.sh 
#!/bin/bash 
# check file group test 
# 
if [ -G $HOME/testing ] 
then 
   echo &quot;You are in the same group as the file&quot; 
else 
   echo &quot;The file is not owned by your group&quot; 
fi 
$  
$ ls -l $HOME/testing 
-rw-rw-r-- 1 rich rich 58 2014-07-30 15:51 /home/rich/testing 
$  
$ ./test19.sh 
You are in the same group as the file 
$  
$ chgrp sharing $HOME/testing 
$  
$ ./test19 
The file is not owned by your group 
$ </code></pre>
<p>第一次运行脚本时，$HOME/testing文件属于rich组，所以通过了-G比较。接下来，组被改成了sharing组，用户也是其中的一员。但是，-G比较失败了，因为它只比较默认组，不会去比较其他的组。</p>
<h5 id="检查文件日期">检查文件日期</h5><p>最后一组方法用来对两个文件的创建日期进行比较。这在编写软件安装脚本时非常有用。有时候，你不会愿意安装一个比系统上已有文件还要旧的文件。 </p>
<p>-nt比较会判定一个文件是否比另一个文件新。如果文件较新，那意味着它的文件创建日期更近。-ot比较会判定一个文件是否比另一个文件旧。如果文件较旧，意味着它的创建日期更早。 </p>
<pre><code class="language-sh">$ cat test20.sh 
#!/bin/bash 
# testing file dates 
# 
if [ test19.sh -nt test18.sh ] 
then 
   echo &quot;The test19 file is newer than test18&quot; 
else 
   echo &quot;The test18 file is newer than test19&quot; 
fi 
if [ test17.sh -ot test19.sh ] 
then 
  echo &quot;The test17 file is older than the test19 file&quot; 
fi 
$  
$ ./test20.sh 
The test19 file is newer than test18 
The test17 file is older than the test19 file 
$  
$ ls -l test17.sh test18.sh test19.sh 
-rwxrw-r-- 1 rich rich 167 2014-07-30 16:31 test17.sh 
-rwxrw-r-- 1 rich rich 185 2014-07-30 17:46 test18.sh 
-rwxrw-r-- 1 rich rich 167 2014-07-30 17:50 test19.sh 
$ </code></pre>
<p>用于比较文件路径是相对你运行该脚本的目录而言的。如果你要检查的文件已经移走，就会出现问题。另一个问题是，这些比较都不会先检查文件是否存在。试试这个测试。 </p>
<pre><code class="language-sh">$ cat test21.sh 
#!/bin/bash 
# testing file dates 
# 
if [ badfile1 -nt badfile2 ] 
then 
   echo &quot;The badfile1 file is newer than badfile2&quot; 
else 
   echo &quot;The badfile2 file is newer than badfile1&quot; 
fi 
$  
$ ./test21.sh 
The badfile2 file is newer than badfile1 
$ </code></pre>
<blockquote>
<p>这个小例子演示了如果文件不存在，-nt比较会返回一个错误的结果。在你尝试使用-nt或-ot比较文件之前，必须先确认文件是存在的。</p>
</blockquote>
<h2 id="复合条件测试">复合条件测试</h2><p>if-then语句允许你使用布尔逻辑来组合测试。有两种布尔运算符可用： </p>
<pre><code>[ condition1 ] &amp;&amp; [ condition2 ] 
[ condition1 ] || [ condition2 ] </code></pre><p>第一种布尔运算使用AND布尔运算符来组合两个条件。要让then部分的命令执行，两个条件都必须满足。 </p>
<p>第二种布尔运算使用OR布尔运算符来组合两个条件。如果任意条件为TRUE，then部分的命令就会执行。 </p>
<p>下例展示了AND布尔运算符的使用。 </p>
<pre><code class="language-sh">$ cat test22.sh 
#!/bin/bash 
# testing compound comparisons 
# 
if [ -d $HOME ] &amp;&amp; [ -w $HOME/testing ] 
then 
   echo &quot;The file exists and you can write to it&quot; 
else 
   echo &quot;I cannot write to the file&quot; 
fi 
$  
$ ./test22.sh 
I cannot write to the file 
$ 
$ touch $HOME/testing 
$  
$ ./test22.sh 
The file exists and you can write to it 
$ </code></pre>
<p>使用AND布尔运算符时，两个比较都必须满足。第一个比较会检查用户的$HOME目录是否存在。第二个比较会检查在用户的$HOME目录是否有个叫testing的文件，以及用户是否有该文件的写入权限。如果两个比较中的一个失败了，if语句就会失败，shell就会执行else部分的命令。如果两个比较都通过了，则if语句通过，shell会执行then部分的命令。</p>
<h2 id="if-then的高级特性">if-then的高级特性</h2><p>bash shell提供了两项可在if-then语句中使用的高级特性： </p>
<ul>
<li>用于数学表达式的双括号 </li>
<li>用于高级字符串处理功能的双方括号 </li>
</ul>
<h4 id="使用双括号">使用双括号</h4><p>双括号命令允许你在比较过程中使用高级数学表达式。test命令只能在比较中使用简单的算术操作。双括号命令提供了更多的数学符号，这些符号对于用过其他编程语言的程序员而言并不陌生。双括号命令的格式如下：</p>
<pre><code>(( expression )) </code></pre><p>expression可以是任意的数学赋值或比较表达式。除了test命令使用的标准数学运算符，下表列出了双括号命令中会用到的其他运算符。<br><img src="https://s1.ax2x.com/2018/08/07/55MNYa.png" alt="55MNYa.png"><br>可以在if语句中用双括号命令，也可以在脚本中的普通命令里使用来赋值。 </p>
<pre><code class="language-sh">$ cat test23.sh 
#!/bin/bash 
# using double parenthesis 
# 
val1=10 
# 
if (( $val1 ** 2 &gt; 90 )) 
then 
   (( val2 = $val1 ** 2 )) 
   echo &quot;The square of $val1 is $val2&quot; 
fi 
$  
$ ./test23.sh 
The square of 10 is 100 
$</code></pre>
<p>注意，不需要将双括号中表达式里的大于号转义。这是双括号命令提供的另一个高级特性。</p>
<h4 id="使用双方括号">使用双方括号</h4><p>双方括号命令提供了针对字符串比较的高级特性。双方括号命令的格式如下： </p>
<pre><code>[[ expression ]] </code></pre><p>双方括号里的expression使用了test命令中采用的标准字符串比较。但它提供了test命令未提供的另一个特性——模式匹配（pattern matching）。 </p>
<p>在模式匹配中，可以定义一个正则表达式来匹配字符串值。 </p>
<pre><code class="language-sh">$ cat test24.sh 
#!/bin/bash 
# using pattern matching 
# 
if [[ $USER == r* ]] 
then 
   echo &quot;Hello $USER&quot; 
else 
   echo &quot;Sorry, I do not know you&quot; 
fi 
$  
$ ./test24.sh 
Hello rich</code></pre>
<p>在上面的脚本中，我们使用了双等号（==）。双等号将右边的字符串（r*）视为一个模式，并应用模式匹配规则。双方括号命令$USER环境变量进行匹配，看它是否以字母r开头。如果是的话，比较通过，shell会执行then部分的命令。 </p>
<h2 id="case命令">case命令</h2><p>你会经常发现自己在尝试计算一个变量的值，在一组可能的值中寻找特定值。在这种情形下，你不得不写出很长的if-then-else语句，就像下面这样。 </p>
<pre><code class="language-sh">$ cat test25.sh 
#!/bin/bash 
# looking for a possible value 
# 
if [ $USER = &quot;rich&quot; ] 
then 
   echo &quot;Welcome $USER&quot; 
   echo &quot;Please enjoy your visit&quot; 
elif [ $USER = &quot;barbara&quot; ] 
then 
   echo &quot;Welcome $USER&quot; 
   echo &quot;Please enjoy your visit&quot; 
elif [ $USER = &quot;testing&quot; ] 
then 
   echo &quot;Special testing account&quot; 
elif [ $USER = &quot;jessica&quot; ] 
then 
   echo &quot;Do not forget to logout when you&#39;re done&quot; 
else 
   echo &quot;Sorry, you are not allowed here&quot; 
fi 
$  
$ ./test25.sh 
Welcome rich 
Please enjoy your visit 
$ </code></pre>
<p>elif语句继续if-then检查，为比较变量寻找特定的值。</p>
<p>有了case命令，就不需要再写出所有的elif语句来不停地检查同一个变量的值了。case命令会采用列表格式来检查单个变量的多个值。 </p>
<pre><code class="language-sh">case variable in 
pattern1 | pattern2) commands1;; 
pattern3) commands2;; 
*) default commands;; 
esac</code></pre>
<p>case命令会将指定的变量与不同模式进行比较。如果变量和模式是匹配的，那么shell会执行为该模式指定的命令。可以通过竖线操作符在一行中分隔出多个模式模式。星号会捕获所有与已知模式不匹配的值。这里有个将if-then-else程序转换成用case命令的例子。 </p>
<pre><code class="language-sh">$ cat test26.sh 
#!/bin/bash 
# using the case command 
# 
case $USER in 
rich | barbara) 
   echo &quot;Welcome, $USER&quot; 
   echo &quot;Please enjoy your visit&quot;;; 
testing) 
  echo &quot;Special testing account&quot;;; 
jessica) 
   echo &quot;Do not forget to log off when you&#39;re done&quot;;; 
*) 
   echo &quot;Sorry, you are not allowed here&quot;;; 
esac 
$  
$ ./test26.sh 
Welcome, rich 
Please enjoy your visit 
$ </code></pre>
<p>case命令提供了一个更清晰的方法来为变量每个可能的值指定不同的选项。</p>
<h2 id="小结">小结</h2><ul>
<li>结构化命令允许你改变shell脚本的正常执行流。最基本的结构化命令是if-then语句。该语句允许你执行一个命令并根据该命令的输出来执行其他命令。 </li>
<li>也可以扩展if-then语句，加入一组当指定命令失败后由bash shell执行的命令。仅在测试命令返回非零退出状态码时，if-then-else语句才允许执行命令。 </li>
<li>也可以将if-then-else语句通过elif语句连接起来。elif等同于使用else if语句，会在测试命令失败时提供额外的检查。 </li>
<li>在很多脚本中，你可能希望测试一种条件而不是一个命令，比如数值、字符串内容、文件或目录的状态。test命令为你提供了测试这些条件的简单方法。如果条件为TRUE，test命令会为if-then语句产生退出状态码0。如果条件为FALSE，test命令会为if-then语句产生一个非零的退出状态码。</li>
<li>方括号是与test命令同义的特殊bash命令。可以在if-then语句中将测试条件放在方括号中来测试数值、字符串和文件条件。 </li>
<li>双括号使用另一种操作符进行高级数学运算。双方括号命令允许高级字符串模式匹配运算。</li>
<li>最后，本章讨论了case命令。该命令是执行多个if-then-else命令的简便方式，它会参照一个值列表来检查单个变量的值。 </li>
</ul>

            </div>
          </article>
        </div>
    
        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://wangxf133.github.io/post/shell-yu-yan-jiao-ben-gou-jian-1-shell-gou-jian-ji-ben-jiao-ben">
              <h3 class="post-title">
                shell语言脚本构建1-shell构建基本脚本
              </h3>
            </a>
          </div>  
        

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: '5debd0dd15fc74854e71',
    clientSecret: '45d803fcebed7f8b06629f3f1626d55f24a79c4f',
    repo: 'wangxf133.github.io',
    owner: 'wangxf133',
    admin: ['wangxf133'],
    id: location.pathname,      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        
    
        <div class="site-footer">
  Powered by Hve Notes
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>

      </div>
    </div>
  </body>
</html>
