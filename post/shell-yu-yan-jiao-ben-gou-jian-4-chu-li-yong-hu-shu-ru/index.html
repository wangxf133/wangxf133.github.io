<html>
  <head>
      <meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>生信学渣</title>
<link rel="shortcut icon" href="https://wangxf133.github.io/favicon.ico?v=1578404663540">
<link rel="stylesheet" href="https://wangxf133.github.io/styles/main.css">
<meta name="description" content="学习 记录 成长" />

<link rel="stylesheet" href="/media/fonts/font-awesome.css">
<link href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Rosario:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">

<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.ui.min.js"></script>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css" integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js" integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js" integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
    onload="renderMathInElement(document.body);"></script>
  </head>
  <body>
    <div class="head-top-line"></div>
    <div class="header-box">
      
<header class="header">
  <div class="blog-header" id="header">
    <div class="site-meta">
      <div class="nav-toggle" id="nav_toggle">
        <div class="toggle-box">
          <div class="line line-top"></div>
          <div class="line line-center"></div>
          <div class="line line-bottom"></div>
        </div>
      </div>
      <div class="site-title">
        <a href="/" class="brand">
          <span>生信学渣</span>
        </a>
      </div>
      <p class="subtitle">Quick notes</p>
    </div>
    <nav class="site-nav" id="site_nav">
      <ul id="nav_ul">
        
          <li class="nav-item ">
            
              <a href="/">
                <i class="fa fa-home"></i> 首页
              </a>
            
          </li>
        
          <li class="nav-item ">
            
              <a href="/archives">
                <i class="fa fa-archive"></i> 归档
              </a>
            
          </li>
        
          <li class="nav-item ">
            
              <a href="/tags">
                <i class="fa fa-tags"></i> 标签
              </a>
            
          </li>
        
          <li class="nav-item ">
            
              <a href="https://wangxf133.github.io/post/guan-yu/">
                <i class="fa fa-"></i> 关于
              </a>
            
          </li>
        
          <li class="nav-item ">
            
              <a href="https://wangxf133.github.io/post/jianli/">
                <i class="fa fa-"></i> 简历
              </a>
            
          </li>
        
        <li class="nav-item">
          <a>
            <i class="fa fa-search"></i> 搜索
          </a>
        </li>
      </ul>
    </nav>
  </div>
</header>
<script type="text/javascript"> 
 
  let showNav = true;

  let navToggle = document.querySelector('#nav_toggle'),
  siteNav = document.querySelector('#site_nav');
  
  function navClick() {
    let sideBar = document.querySelector('.sidebar');
    let navUl = document.querySelector('#nav_ul');
    navToggle.classList.toggle('nav-toggle-active');
    siteNav.classList.toggle('nav-menu-active');
    if (siteNav.classList.contains('nav-menu-active')) {
      siteNav.style = "height: " + (navUl.children.length * 42) +"px !important";
    } else {
      siteNav.style = "";
    }
  }

  navToggle.addEventListener('click',navClick);  
</script>
    </div>
    <div class="main-continer">
      <div class="section-layout">
        <div class="section-layout-wrapper">
          
<div class="sidebar">
    <div class="sidebar-wrapper" id="sidebar">
      
        <div class="post-list-sidebar">
          <div class="sidebar-title">
            <span id="tocSideBar" class="sidebar-title-item sidebar-title-active">文章目录</span>
            <span id="metaSideBar" class="sidebar-title-item">站点概览</span>
          </div>
        </div>
      
      <div class="sidebar-body" id="sidebar_body">
        
          <div class="post-side-meta" id="post_side_meta">
            <div class="sidebar-wrapper">
  <div class="sidebar-item">
    <img class="site-author-image" src="https://wangxf133.github.io/images/avatar.png"/>
    <p class="site-author-name">生信学渣</p>
    <p class="site-description">学习 记录 成长</p>
  </div>
  <div class="sidebar-item side-item-stat">
    <div class="sidebar-item-box">
      <a href="/archives/">
        
        <span class="site-item-stat-count">18</span>
        <span class="site-item-stat-name">文章</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="">
        <span class="site-item-stat-count">25</span>
        <span class="site-item-stat-name">分类</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="/tags/">
        <span class="site-item-stat-count">25</span>
        <span class="site-item-stat-name">标签</span>
      </a>
    </div>
  </div>
  <div class="sidebar-item">
    <span class="site-item-rss">
        <i class="fa fa-rss"></i>
        <a href="https://wangxf133.github.io/atom.xml" target="_blank">RSS</a>
    </span>
  </div>
  <div class="sidebar-item sidebar-item-social">
    <div class="social-item">
      <a href="">
        <i class="fa fa-github"></i> GitHub
      </a>
      <a href="">
        <i class="fa fa-twitter"></i> Twitter
      </a>
    </div>
    <div class="social-item">
      <a href="">
        <i class="fa fa-globe"></i> 豆瓣
      </a>
      <a href="">
        <i class="fa fa-globe"></i> 知乎
      </a>
    </div>
  </div>
</div>
          </div>
          <div class="post-toc sidebar-body-active" id="post_toc" style="opacity: 1;">
            <div class="toc-box">
  <div class="toc-wrapper" id="toc_wrapper">
    <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#1-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0">1. 命令行参数</a><br>
*
<ul>
<li><a href="#11-%E8%AF%BB%E5%8F%96%E5%8F%82%E6%95%B0">1.1 读取参数</a></li>
<li><a href="#12-%E8%AF%BB%E5%8F%96%E8%84%9A%E6%9C%AC%E5%90%8D">1.2 读取脚本名</a></li>
<li><a href="#13-%E6%B5%8B%E8%AF%95%E5%8F%82%E6%95%B0">1.3 测试参数</a></li>
</ul>
</li>
<li><a href="#2-%E7%89%B9%E6%AE%8A%E5%8F%82%E6%95%B0%E5%8F%98%E9%87%8F">2. 特殊参数变量</a><br>
*
<ul>
<li><a href="#21-%E5%8F%82%E6%95%B0%E7%BB%9F%E8%AE%A1">2.1 参数统计**</a></li>
<li><a href="#22-%E6%8A%93%E5%8F%96%E6%89%80%E6%9C%89%E7%9A%84%E6%95%B0%E6%8D%AE">2.2 抓取所有的数据</a></li>
</ul>
</li>
<li><a href="#3-%E7%A7%BB%E5%8A%A8%E5%8F%98%E9%87%8F">3. 移动变量</a></li>
<li><a href="#4-%E5%A4%84%E7%90%86%E9%80%89%E9%A1%B9">4. 处理选项</a><br>
*
<ul>
<li><a href="#41-%E6%9F%A5%E6%89%BE%E9%80%89%E9%A1%B9">4.1 查找选项</a></li>
<li><a href="#42-%E4%BD%BF%E7%94%A8getopt%E5%91%BD%E4%BB%A4">4.2 使用getopt命令</a></li>
<li><a href="#43-%E4%BD%BF%E7%94%A8%E6%9B%B4%E9%AB%98%E7%BA%A7%E7%9A%84-getopts">4.3 使用更高级的 getopts **</a></li>
</ul>
</li>
<li><a href="#5-%E5%B0%86%E9%80%89%E9%A1%B9%E6%A0%87%E5%87%86%E5%8C%96">5. 将选项标准化</a></li>
<li><a href="#6-%E8%8E%B7%E5%BE%97%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5">6. 获得用户输入</a><br>
*
<ul>
<li><a href="#61-%E5%9F%BA%E6%9C%AC%E7%9A%84%E8%AF%BB%E5%8F%96">6.1 基本的读取</a></li>
<li><a href="#62-%E8%B6%85%E6%97%B6">6.2 超时</a></li>
<li><a href="#63-%E9%9A%90%E8%97%8F%E6%96%B9%E5%BC%8F%E8%AF%BB%E5%8F%96">6.3 隐藏方式读取</a></li>
<li><a href="#64-%E4%BB%8E%E6%96%87%E4%BB%B6%E4%B8%AD%E8%AF%BB%E5%8F%96">6.4 从文件中读取</a></li>
</ul>
</li>
<li><a href="#7-%E5%B0%8F%E7%BB%93">7. 小结</a></li>
</ul>
</li>
</ul>

  </div>
</div>

<script>

let lastTop = 0, lList = [], hList = [], postBody, lastIndex = -1; 
let active = 'active-show', activeClass = 'active-current';
let tocWrapper = document.querySelector('#toc_wrapper');
let tocContent = tocWrapper.children[0];

function addTocNumber(elem, deep) {
  if (!elem) {
    return;
  }
  let prop = elem.__proto__;

  if (prop === HTMLUListElement.prototype) {
    for (let i = 0; i < elem.children.length; i++) {
      addTocNumber(elem.children[i], deep + (i + 1) + '.');
    }
  } else if (prop === HTMLLIElement.prototype) {
    // 保存li元素
    lList.push(elem);
    for (let i = 0; i < elem.children.length; i++) {
      let cur = elem.children[i];
      if (cur.__proto__ === HTMLAnchorElement.prototype) {
        cur.text =  deep + ' ' + cur.text;
      } else if (cur.__proto__ === HTMLUListElement.prototype) {
        addTocNumber(cur, deep);
      }
    }
  }
}


document.addEventListener('scroll', function(e) {
  if (lList.length <= 0) {
    return;
  }
  let scrollTop = document.body.scrollTop;
  let dir;

  if (lastTop - scrollTop > 0) {
    dir = 'up';
  } else {
    dir = 'down';
  }

  lastTop = scrollTop;
  if (scrollTop <= 0) {
    if (lastIndex >= 0 && lastIndex < hList.length) {
      lList[lastIndex].classList.remove(activeClass);
    }
    return;
  }

  let current = 0, hasFind = false;
  for (let i = 0; i < hList.length; i++) {
    if (hList[i].offsetTop > scrollTop) {
      current = i;
      hasFind = true;
      break;
    }
  }
  if (!hasFind && scrollTop > lList[lList.length - 1].offsetTop) {
    current = hList.length - 1;
  } else {
    current--;
  }
  if (dir === 'down') {
    if (current > lastIndex) {
      addActiveClass(current);
      removeActiveClass(lastIndex) 
      lastIndex = current;
      removeParentActiveClass();
      lList[current] && addActiveLiElemment(lList[current].parentElement,tocContent);
    }
  } else {
    if (current < lastIndex) {
      addActiveClass(current);
      removeActiveClass(lastIndex);
      lastIndex = current;
      removeParentActiveClass();
      lList[current] && addActiveLiElemment(lList[current].parentElement,tocContent);
    }
  }
});

function removeParentActiveClass() {
  let parents = tocContent.querySelectorAll('.'+active)
  parents.forEach(function(elem) {
    elem.classList.remove(active);
  });
}

function addActiveClass(index) {
  if (index >= 0 && index < hList.length) {
    lList[index].classList.add(activeClass);
  }
}

function removeActiveClass(index) {
  if (index >= 0 && index < hList.length) {
    lList[index].classList.remove(activeClass);
  }
}

function addActiveLiElemment(elem, parent) {
  if (!elem || elem === parent) {
    return;
  } else {
    if (elem.__proto__ === HTMLLIElement.prototype) {
      elem.classList.add(active);
    }
    addActiveLiElemment(elem.parentElement, parent);
  }
}

function showToc() {
  if (tocWrapper) {
    postBody = document.querySelector('#post_body');
    for (let i = 0; i < postBody.children.length; i++) {
      if (postBody.children[i].__proto__ === HTMLHeadingElement.prototype) {
        hList.push(postBody.children[i]);
      }
    }

    if (hList.length > 10) {
      active = 'active-hidden'
      tocContent.classList.add('closed');
    } else {
      tocContent.classList.add('expanded');
    }
  }
}
addTocNumber(tocContent, '');

window.addEventListener('load', function() {
  showToc();
  document.querySelector('#sidebar').style='display: block;';
  tocWrapper.classList.add('toc-active');
  setTimeout(function() {
    if ("createEvent" in document) {
      let evt = document.createEvent("HTMLEvents");
      evt.initEvent("scroll", false, true);
      document.dispatchEvent(evt);
    }
    else {
      document.fireEvent("scroll");
    }
  }, 500)
})

</script>
          </div>
        
      </div>
    </div>
</div>
<script>
  const SIDEBAR_TITLE_ACTIVE = 'sidebar-title-active';
  const SIDEBAR_BODY_ACTIVE = 'sidebar-body-active';
  const SLIDE_UP_IN = 'slide-up-in';

  let sidebar = document.querySelector('#sidebar'),
  tocSideBar = document.querySelector('#tocSideBar'),
  metaSideBar = document.querySelector('#metaSideBar'),
  postToc = document.querySelector('#post_toc'),
  postSiteMeta = document.querySelector('#post_side_meta'),
  sidebarTitle = document.querySelector('.sidebar-title'),
  sidebarBody = document.querySelector('#sidebar_body');

  tocSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  metaSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  function toggleSidebar(e) {
    let currentTitle = document.querySelector("."+SIDEBAR_TITLE_ACTIVE);
    if (currentTitle == e.srcElement) {
      return ;
    }
    let current, showElement, hideElement;
    if (e.srcElement == metaSideBar) {
      showElement = postSiteMeta;
      hideElement = postToc;
    } else if (e.srcElement == tocSideBar){
      showElement = postToc;
      hideElement = postSiteMeta;
    }
    currentTitle.classList.remove(SIDEBAR_TITLE_ACTIVE);
    e.srcElement.classList.add(SIDEBAR_TITLE_ACTIVE);

    window.Velocity(hideElement, 'stop');
    window.Velocity(hideElement, 'transition.slideUpOut', {
      display: 'none',
      duration: 200,
      complete: function () {
        window.Velocity(showElement, 'transition.slideDownIn', {
          duration: 200
        });
      }
    })
    hideElement.classList.remove(SIDEBAR_BODY_ACTIVE);
    showElement.classList.add(SIDEBAR_BODY_ACTIVE);

  }

  postToc.addEventListener('transitionend', function() {
    this.classList.remove(SLIDE_UP_IN);
  });

  let limitTop = document.querySelector('#nav_ul').children.length * 42 + 162;
  let hasFix = false;
  window.addEventListener('scroll', function(e) {
    if (document.body.scrollTop >= limitTop) {
      if (!hasFix) {
        sidebar.classList.add('sidebar-fixed');
        hasFix = true;
      }
    } else {
      if (hasFix) {
        sidebar.classList.remove('sidebar-fixed');
        hasFix = false;
      }
    }
  });
</script>
          <div class="section-box">
            <div class="section post">
              <div class="article-box">
    <header class="post-header">
  <h1 class="post-title">
    <a class="post-title-link" href="https://wangxf133.github.io/post/shell-yu-yan-jiao-ben-gou-jian-4-chu-li-yong-hu-shu-ru">
      shell语言脚本构建4-处理用户输入
    </a>
  </h1>
  <div class="post-meta">
    <span class="meta-item pc-show">
      <i class="fa fa-calendar-o"></i>
      <span>发布于</span>
      <span>2019-03-27</span>
    </span>
    
      <span class="meta-item">
        <span class="post-meta-divider pc-show">|</span>
        <i class="fa fa-folder-o"></i>
        <span class="pc-show">分类于</span>
        
          
            <a href="https://wangxf133.github.io/tag/cykUzrlw2">
              <span>脚本文件</span>
            </a>、
          
        
          
            <a href="https://wangxf133.github.io/tag/PvD-ng_cF">
              <span>shell语言</span>
            </a>
          
        
      </span>
    
    <span class="meta-item">
      <span class="post-meta-divider">|</span>
      <i class="fa fa-clock-o"></i>
      <span>37分钟</span>
    </span>
    <span class="meta-item">
      <span class="post-meta-divider">|</span>
      <i class="fa fa-file-word-o"></i>
      <span>8897<span class="pc-show">字数</span></span>
    </span>
  </div>
</header>
</div>
              <div class="post-body next-md-body" id="post_body">
                <p>目前为止，你已经看到了如何编写脚本，处理数据、变量和Linux系统上的文件。有时，你编写的脚本还得能够与使用者进行交互。bash shell提供了一些不同的方法来从用户处获得数据，包括命令行参数（添加在命令后的数据）、命令行选项（可修改命令行为的单个字母）以及直接从键盘读取输入的能力。本章将会讨论如何在你的bash shell脚本运用这些方法来从脚本用户处获得数据。</p>
<!--More-->
<h2 id="1-命令行参数">1. 命令行参数</h2>
<p>向shell脚本传递数据的最基本方法是使用命令行参数。命令行参数允许在运行脚本时向命令行添加数据。</p>
<pre><code>$ ./addem 10 30 
</code></pre>
<p>本例向脚本addem传递了两个命令行参数（10和30）。脚本会通过特殊的变量来处理命令行参数。后面几节将会介绍如何在bash shell脚本中使用命令行参数。</p>
<h4 id="11-读取参数">1.1 读取参数</h4>
<p>bash shell会将一些称为<strong>位置参数（positional parameter）的特殊变量分配给输入到命令行中的所有参数</strong>。这也包括shell所执行的脚本名称。<strong>位置参数变量是标准的数字：$0是程序名，$1是第一个参数，$2是第二个参数，依次类推，直到第九个参数$9。</strong></p>
<p>下面是在shell脚本中使用单个命令行参数的简单例子。</p>
<pre><code class="language-sh">$ cat test1.sh 
#!/bin/bash 
# using one command line parameter 
# 
factorial=1 
for (( number = 1; number &lt;= $1 ; number++ )) 
do 
   factorial=$[ $factorial * $number ] 
done 
echo The factorial of $1 is $factorial 
$  


$ ./test1.sh 5 
The factorial of 5 is 120 
$ 
</code></pre>
<p>可以在shell脚本中像使用其他变量一样使用$1变量。shell脚本会自动将命令行参数的值分配给变量，不需要你作任何处理。</p>
<p>如果需要输入更多的命令行参数，则每个参数都必须用空格分开。</p>
<pre><code class="language-sh">$ cat test2.sh 
#!/bin/bash 
# testing two command line parameters 
# 
total=$[ $1 * $2 ] 
echo The first parameter is $1. 
echo The second parameter is $2. 
echo The total value is $total. 
$  
$ ./test2.sh 2 5 
The first parameter is 2. 
The second parameter is 5. 
The total value is 10. 
$ 
</code></pre>
<p>shell会将每个参数分配给对应的变量。</p>
<p>在前面的例子中，用到的命令行参数都是数值。也可以在命令行上用文本字符串。</p>
<pre><code class="language-sh">$ cat test3.sh 
#!/bin/bash 
# testing string parameters 
# 
echo Hello $1, glad to meet you. 
$  
$ ./test3.sh Rich 
Hello Rich, glad to meet you. 
$ 
</code></pre>
<p>shell将输入到命令行的字符串值传给脚本。但碰到含有空格的文本字符串时就会出现问题：</p>
<pre><code class="language-sh">$ ./test3.sh Rich Blum 
Hello Rich, glad to meet you. 
$ 
</code></pre>
<p>记住，每个参数都是用空格分隔的，所以shell会将空格当成两个值的分隔符。要在参数值中包含空格，必须要用引号（单引号或双引号均可）。</p>
<pre><code class="language-sh">$ ./test3.sh 'Rich Blum' 
Hello Rich Blum, glad to meet you. 
$  
$ ./test3.sh &quot;Rich Blum&quot; 
Hello Rich Blum, glad to meet you. 
$ 
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://s1.ax2x.com/2018/08/12/55IbFe.png" alt="55IbFe.png" loading="lazy"></figure>
<pre><code class="language-sh">$ cat test4.sh 
#!/bin/bash 
# handling lots of parameters 
# 
total=$[ ${10} * ${11} ] 
echo The tenth parameter is ${10} 
echo The eleventh parameter is ${11} 
echo The total is $total 
$  
$ ./test4.sh 1 2 3 4 5 6 7 8 9 10 11 12 
The tenth parameter is 10 
The eleventh parameter is 11 
The total is 110 
$
</code></pre>
<p>这项技术允许你根据需要向脚本添加任意多的命令行参数。</p>
<h4 id="12-读取脚本名">1.2 读取脚本名</h4>
<pre><code class="language-sh">$ cat test5.sh 
#!/bin/bash 
# Testing the $0 parameter 
# 
echo The zero parameter is set to: $0 
# 
$ 
$ bash test5.sh 
The zero parameter is set to: test5.sh 
$ 
</code></pre>
<p>但是这里存在一个潜在的问题。如果使用另一个命令来运行shell脚本，命令会和脚本名混在一起，出现在$0参数中。</p>
<pre><code class="language-sh">$ ./test5.sh 
The zero parameter is set to: ./test5.sh 
$
</code></pre>
<p>这还不是唯一的问题。当传给$0变量的实际字符串不仅仅是脚本名，而是完整的脚本路径时，变量$0就会使用整个路径。</p>
<pre><code class="language-sh">$ bash /home/Christine/test5.sh 
The zero parameter is set to: /home/Christine/test5.sh 
$ 
</code></pre>
<p>如果你要编写一个根据脚本名来执行不同功能的脚本，就得做点额外工作。你得把脚本的运行路径给剥离掉。另外，还要删除与脚本名混杂在一起的命令。</p>
<p>幸好有个方便的小命令可以帮到我们。basename命令会返回不包含路径的脚本名。</p>
<pre><code class="language-sh">$ cat test5b.sh 
#!/bin/bash 
# Using basename with the $0 parameter 
# 
name=$(basename $0) 
echo 
echo The script name is: $name 
# 
$ bash /home/Christine/test5b.sh 
 
The script name is: test5b.sh 
$ 
$ ./test5b.sh 
 
The script name is: test5b.sh 
$ 
</code></pre>
<p>现在好多了。可以用这种方法来编写基于脚本名执行不同功能的脚本。这里有个简单的例子。</p>
<pre><code class="language-sh">$ cat test6.sh 
#!/bin/bash 
# Testing a Multi-function script 
# 
name=$(basename $0) 
# 
if [ $name = &quot;addem&quot; ] 
then 
   total=$[ $1 + $2 ] 
# 
elif [ $name = &quot;multem&quot; ] 
then 
   total=$[ $1 * $2 ] 
fi 
# 
echo 
echo The calculated value is $total 
#


$ 

$ chmod u+x addem 
$ 
$ ln -s test6.sh multem 
$ 
$ ls -l *em 
-rwxrw-r--. 1 Christine Christine 224 Jun 30 23:50 addem 
lrwxrwxrwx. 1 Christine Christine   8 Jun 30 23:50 multem -&gt; test6.sh 
$ 
$ ./addem 2 5 
 
The calculated value is 7 
$ 
$ ./multem 2 5 
 
The calculated value is 10 
$ 

</code></pre>
<p>本例从test6.sh脚本中创建了两个不同的文件名：一个通过复制文件创建（addem），另一个通过链接（参见第3章）创建（multem）。在两种情况下都会先获得脚本的基本名称，然后根据该值执行相应的功能。</p>
<h4 id="13-测试参数">1.3 测试参数</h4>
<p>在shell脚本中使用命令行参数时要小心些。如果脚本不加参数运行，可能会出问题。</p>
<pre><code class="language-sh">$ ./addem 2 
./addem: line 8: 2 +  : syntax error: operand expected (error 
 token is &quot; &quot;) 
The calculated value is 
$ 
</code></pre>
<p>当脚本认为参数变量中会有数据而实际上并没有时，脚本很有可能会产生错误消息。这种写脚本的方法并不可取。在使用参数前一定要检查其中是否存在数据。</p>
<pre><code class="language-sh">$ cat test7.sh 
#!/bin/bash 
# testing parameters before use 
# 
if [ -n &quot;$1&quot; ] 
then 
   echo Hello $1, glad to meet you. 
else 
   echo &quot;Sorry, you did not identify yourself. &quot; 
fi 
$  
$ ./test7.sh Rich 
Hello Rich, glad to meet you. 
$  
$ ./test7.sh 
Sorry, you did not identify yourself. 
$ 
</code></pre>
<p>在本例中，使用了-n测试来检查命令行参数$1中是否有数据。在下一节中，你会看到还有另一种检查命令行参数的方法。</p>
<h2 id="2-特殊参数变量">2. 特殊参数变量</h2>
<p>在bash shell中有些特殊变量，它们会记录命令行参数。本节将会介绍这些变量及其用法。</p>
<h4 id="21-参数统计">2.1 参数统计**</h4>
<p>如在上一节中看到的，在脚本中使用命令行参数之前应该检查一下命令行参数。对于使用多个命令行参数的脚本来说，这有点麻烦。</p>
<p>你可以统计一下命令行中输入了多少个参数，无需测试每个参数。bash shell为此提供了一个特殊变量。</p>
<p>特殊变量$#含有脚本运行时携带的命令行参数的个数。可以在脚本中任何地方使用这个特殊变量，就跟普通变量一样。</p>
<pre><code class="language-sh">$ cat test8.sh 
#!/bin/bash 
# getting the number of parameters 
# 
echo There were $# parameters supplied. 
$  
$ ./test8.sh 
There were 0 parameters supplied. 
$  
$ ./test8.sh 1 2 3 4 5 
There were 5 parameters supplied. 
$  
$ ./test8.sh 1 2 3 4 5 6 7 8 9 10 
There were 10 parameters supplied. 
$  
$ ./test8.sh &quot;Rich Blum&quot; 
There were 1 parameters supplied. 
$ 
</code></pre>
<p>现在你就能在使用参数前测试参数的总数了。</p>
<pre><code class="language-sh">$ cat test9.sh 
#!/bin/bash 
# Testing parameters 
# 
if [ $# -ne 2 ] 
then 
   echo 
   echo Usage: test9.sh a b 
   echo 
else 
   total=$[ $1 + $2 ] 
   echo 
   echo The total is $total 
   echo 
fi 
# 
$
$ bash test9.sh 
 
Usage: test9.sh a b 
 
$ bash test9.sh 10 
 
Usage: test9.sh a b 
 
$ bash test9.sh 10 15 
 
The total is 25 
 
$ 
</code></pre>
<p>if-then语句用-ne测试命令行参数数量。如果参数数量不对，会显示一条错误消息告知脚本的正确用法。</p>
<p>这个变量还提供了一个简便方法来获取命令行中最后一个参数，完全不需要知道实际上到底用了多少个参数。不过要实现这一点，得稍微多花点工夫。</p>
<figure data-type="image" tabindex="2"><img src="https://s1.ax2x.com/2018/08/12/55Ipud.png" alt="55Ipud.png" loading="lazy"></figure>
<pre><code class="language-sh">$ cat badtest1.sh 
#!/bin/bash 
# testing grabbing last parameter 
# 
echo The last parameter was ${$#} 
$  
$ ./badtest1.sh 10 
The last parameter was 15354 
$
</code></pre>
<p>怎么了？显然，出了点问题。它表明你不能在花括号内使用美元符。必须将美元符换成感叹号。很奇怪，但的确管用。</p>
<pre><code class="language-sh">$ cat test10.sh 
#!/bin/bash 
# Grabbing the last parameter 
# 
params=$# 
echo 
echo The last parameter is $params 
echo The last parameter is ${!#} 
echo 
# 
$ 
$ bash test10.sh 1 2 3 4 5 
The last parameter is 5 
The last parameter is 5 
 
$ 
$ bash test10.sh 
 
The last parameter is 0 
The last parameter is test10.sh 
 
$
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://s1.ax2x.com/2018/08/12/55IsAR.png" alt="55IsAR.png" loading="lazy"></figure>
<h4 id="22-抓取所有的数据">2.2 抓取所有的数据</h4>
<p>有时候需要抓取命令行上提供的所有参数。这时候不需要先用$#变量来判断命令行上有多少参数，然后再进行遍历，你可以使用一组其他的特殊变量来解决这个问题。</p>
<p>$*和$@变量可以用来轻松访问所有的参数。这两个变量都能够在单个变量中存储所有的命令行参数。</p>
<p>$*变量会将命令行上提供的所有参数当作一个单词保存。这个单词包含了命令行中出现的每一个参数值。基本上$*变量会将这些参数视为一个整体，而不是多个个体。</p>
<p>另一方面，$@变量会将命令行上提供的所有参数当作同一字符串中的多个独立的单词。这样你就能够遍历所有的参数值，得到每个参数。这通常通过for命令完成。</p>
<p>这两个变量的工作方式不太容易理解。看个例子，你就能理解二者之间的区别了。</p>
<pre><code class="language-sh">$ cat test11.sh 
#!/bin/bash 
# testing $* and $@ 
# 
echo 
echo &quot;Using the \$* method: $*&quot; 
echo 
echo &quot;Using the \$@ method: $@&quot; 
$  
$ ./test11.sh rich barbara katie jessica 
 
Using the $* method: rich barbara katie jessica 
 
Using the $@ method: rich barbara katie jessica 
$ 
</code></pre>
<p>注意，从表面上看，两个变量产生的是同样的输出，都显示出了所有命令行参数。</p>
<p>下面的例子给出了二者的差异。</p>
<pre><code class="language-sh">$ cat test12.sh 
#!/bin/bash 
# testing $* and $@ 
# 
echo 
count=1 
# 
for param in &quot;$*&quot; 
do 
   echo &quot;\$* Parameter #$count = $param&quot; 
   count=$[ $count + 1 ] 
done 
# 
echo 
count=1 
# 
for param in &quot;$@&quot; 
do 
   echo &quot;\$@ Parameter #$count = $param&quot; 
   count=$[ $count + 1 ] 
done 
$  
$ ./test12.sh rich barbara katie jessica 
 
$* Parameter #1 = rich barbara katie jessica 
 
$@ Parameter #1 = rich 
$@ Parameter #2 = barbara 
$@ Parameter #3 = katie 
$@ Parameter #4 = jessica 
$ 
</code></pre>
<p>现在清楚多了。通过使用for命令遍历这两个特殊变量，你能看到它们是如何不同地处理命令行参数的。$*变量会将所有参数当成单个参数，而$@变量会单独处理每个参数。这是遍历命令行参数的一个绝妙方法。</p>
<h2 id="3-移动变量">3. 移动变量</h2>
<p>bash shell工具箱中另一件工具是shift命令。bash shell的shift命令能够用来操作命令行参数。跟字面上的意思一样，shift命令会根据它们的相对位置来移动命令行参数。</p>
<p>在使用shift命令时，默认情况下它会将每个参数变量向左移动一个位置。所以，变量$3的值会移到$2中，变量$2的值会移到$1中，而变量$1的值则会被删除（注意，变量$0的值，也就是程序名，不会改变）。</p>
<p>这是遍历命令行参数的另一个好方法，尤其是在你不知道到底有多少参数时。你可以只操作第一个参数，移动参数，然后继续操作第一个参数。</p>
<p>这里有个例子来解释它是如何工作的。</p>
<pre><code class="language-sh">$ cat test13.sh 
#!/bin/bash 
# demonstrating the shift command 

echo 
count=1 
while [ -n &quot;$1&quot; ] 
do 
   echo &quot;Parameter #$count = $1&quot; 
   count=$[ $count + 1 ] 
   shift 
done 
$  
$ ./test13.sh rich barbara katie jessica 
 
Parameter #1 = rich 
Parameter #2 = barbara 
Parameter #3 = katie 
Parameter #4 = jessica 
$ 
</code></pre>
<p>这个脚本通过测试第一个参数值的长度执行了一个while循环。当第一个参数的长度为零时，循环结束。测试完第一个参数后，shift命令会将所有参数的位置移动一个位置。</p>
<p>另外，你也可以一次性移动多个位置，只需要给shift命令提供一个参数，指明要移动的位置数就行了。</p>
<pre><code class="language-sh">$ cat test14.sh 
#!/bin/bash 
# demonstrating a multi-position shift 
# 
echo 
echo &quot;The original parameters: $*&quot; 
shift 2 
echo &quot;Here's the new first parameter: $1&quot; 
$  
$ ./test14.sh 1 2 3 4 5 
 
The original parameters: 1 2 3 4 5 
Here's the new first parameter: 3 
$ 
</code></pre>
<p>通过使用shift命令的参数，就可以轻松地跳过不需要的参数。</p>
<h2 id="4-处理选项">4. 处理选项</h2>
<p>如果你认真读过本书前面的所有内容，应该就见过了一些同时提供了参数和选项的bash命令。<strong>选项是跟在单破折线后面的单个字母，它能改变命令的行为。本节将会介绍3种在脚本中处理选项的方法。</strong></p>
<h4 id="41-查找选项">4.1 查找选项</h4>
<p>表面上看，命令行选项也没什么特殊的。在命令行上，它们紧跟在脚本名之后，就跟命令行参数一样。实际上，如果愿意，你可以像处理命令行参数一样处理命令行选项。</p>
<ol>
<li>处理简单选项</li>
</ol>
<p>在前面的test13.sh脚本中，你看到了如何使用shift命令来依次处理脚本程序携带的命令行参数。你也可以用同样的方法来处理命令行选项。</p>
<p>在提取每个单独参数时，用case语句（参见第12章）来判断某个参数是否为选项。</p>
<pre><code class="language-sh">$ cat test15.sh 
#!/bin/bash 
# extracting command line options as parameters 
# 
echo 
while [ -n &quot;$1&quot; ] 
do 
   case &quot;$1&quot; in 
     -a) echo &quot;Found the -a option&quot; ;; 
     -b) echo &quot;Found the -b option&quot; ;; 
     -c) echo &quot;Found the -c option&quot; ;; 
      *) echo &quot;$1 is not an option&quot; ;; 
   esac 
   shift 
done 

$  
$ ./test15.sh -a -b -c -d 
 
Found the -a option 
Found the -b option 
Found the -c option 
-d is not an option 
$ 
</code></pre>
<p>case语句会检查每个参数是不是有效选项。如果是的话，就运行对应case语句中的命令。不管选项按什么顺序出现在命令行上，这种方法都适用。</p>
<pre><code class="language-sh">$ ./test15.sh -d -c -a 
 
-d is not an option 
Found the -c option 
Found the -a option 
$ 
</code></pre>
<p>case语句在命令行参数中找到一个选项，就处理一个选项。如果命令行上还提供了其他参数，你可以在case语句的通用情况处理部分中处理。</p>
<p>你会经常遇到想在shell脚本中同时使用选项和参数的情况。Linux中处理这个问题的标准方式是用特殊字符来将二者分开，该字符会告诉脚本何时选项结束以及普通参数何时开始。</p>
<p>对Linux来说，这个特殊字符是双破折线（--）。shell会用双破折线来表明选项列表结束。在双破折线之后，脚本就可以放心地将剩下的命令行参数当作参数，而不是选项来处理了。</p>
<p>要检查双破折线，只要在case语句中加一项就行了。</p>
<pre><code class="language-sh">$ cat test16.sh 
#!/bin/bash 
# extracting options and parameters 
echo 
while [ -n &quot;$1&quot; ] 
do 
   case &quot;$1&quot; in 
      -a) echo &quot;Found the -a option&quot; ;; 
      -b) echo &quot;Found the -b option&quot;;; 
      -c) echo &quot;Found the -c option&quot; ;; 
      --) shift 
          break ;; 
       *) echo &quot;$1 is not an option&quot;;; 
   esac 
   shift 
done 
# 
count=1 
for param in $@ 
do 
   echo &quot;Parameter #$count: $param&quot; 
   count=$[ $count + 1 ] 
done 
$
</code></pre>
<p>在遇到双破折线时，脚本用break命令来跳出while循环。由于过早地跳出了循环，我们需要再加一条shift命令来将双破折线移出参数变量。</p>
<p>对于第一个测试，试试用一组普通的选项和参数来运行这个脚本。</p>
<pre><code class="language-sh">$ ./test16.sh -c -a -b test1 test2 test3 
 
Found the -c option 
Found the -a option 
Found the -b option 
test1 is not an option 
test2 is not an option 
test3 is not an option 
$ 
</code></pre>
<p>结果说明在处理时脚本认为所有的命令行参数都是选项。接下来，进行同样的测试，只是这次会用双破折线来将命令行上的选项和参数划分开来。</p>
<pre><code class="language-sh">$ ./test16.sh -c -a -b -- test1 test2 test3 
 
Found the -c option 
Found the -a option 
Found the -b option 
Parameter #1: test1 
Parameter #2: test2 
Parameter #3: test3 
$ 
</code></pre>
<p>当脚本遇到双破折线时，它会停止处理选项，并将剩下的参数都当作命令行参数。</p>
<ol start="3">
<li>处理带值的选项</li>
</ol>
<p>有些选项会带上一个额外的参数值。在这种情况下，命令行看起来像下面这样。</p>
<pre><code class="language-sh">$ ./testing.sh -a test1 -b -c -d test2
</code></pre>
<p>当命令行选项要求额外的参数时，脚本必须能检测到并正确处理。下面是如何处理的例子。</p>
<pre><code class="language-sh">$ cat test17.sh 
#!/bin/bash 
# extracting command line options and values 
echo 
while [ -n &quot;$1&quot; ] 
do 
   case &quot;$1&quot; in 
      -a) echo &quot;Found the -a option&quot;;; 
      -b) param=&quot;$2&quot; 
          echo &quot;Found the -b option, with parameter value $param&quot; 
          shift ;; 
      -c) echo &quot;Found the -c option&quot;;; 
      --) shift 
          break ;; 
       *) echo &quot;$1 is not an option&quot;;; 
   esac 
   shift 
done 
# 
count=1 
for param in &quot;$@&quot; 
do 
   echo &quot;Parameter #$count: $param&quot; 
   count=$[ $count + 1 ] 
done 
$  
$ ./test17.sh -a -b test1 -d 
 
Found the -a option 
Found the -b option, with parameter value test1 
-d is not an option 
$
</code></pre>
<p>在这个例子中，case语句定义了三个它要处理的选项。-b选项还需要一个额外的参数值。由于要处理的参数是\1，额外的参数值就应该位于$2（因为所有的参数在处理完都会被移出）。只要将参数值从$2变量中提取出来就可以了。当然，因为这个选项占用了两个参数位，所以你还需要使用shift命令多移动一个位置。</p>
<p>只用这些基本的特性，整个过程就能正常工作，不管按什么顺序放置选项（但要记住包含每个选项相应的选项参数）。</p>
<pre><code class="language-sh">$ ./test17.sh -b test1 -a -d 
Found the -b option, with parameter value test1 
Found the -a option 
-d is not an option 
$
</code></pre>
<p>现在shell脚本中已经有了处理命令行选项的基本能力，但还有一些限制。比如，如果你想将多个选项放进一个参数中时，它就不能工作了。</p>
<pre><code class="language-sh">$ ./test17.sh -ac 
-ac is not an option 
$ 
</code></pre>
<p>在Linux中，合并选项是一个很常见的用法，而且如果脚本想要对用户更友好一些，也要给用户提供这种特性。幸好，有另外一种处理选项的方法能够帮忙。</p>
<h4 id="42-使用getopt命令">4.2 使用getopt命令</h4>
<p>getopt命令是一个在处理命令行选项和参数时非常方便的工具。它能够识别命令行参数，从而在脚本中解析它们时更方便。</p>
<ol>
<li>命令的格式</li>
</ol>
<p>getopt命令可以接受一系列任意形式的命令行选项和参数，并自动将它们转换成适当的格式。它的命令格式如下：</p>
<pre><code>getopt optstring parameters 
</code></pre>
<p><strong>optstring</strong>是这个过程的关键所在。它定义了命令行有效的选项字母，还定义了哪些选项字母需要参数值。</p>
<p>首先，在optstring中列出你要在脚本中用到的每个命令行选项字母。然后，在每个需要参数值的选项字母后加一个冒号。getopt命令会基于你定义的optstring解析提供的参数。</p>
<hr>
<p>窍门:</p>
<p>getopt命令有一个更高级的版本叫作getopts（注意这是复数形式）。getopts命令会在本文随后部分讲到。因为这两个命令的拼写几乎一模一样，所以很容易搞混。一定要小心！</p>
<hr>
<p>下面是个getopt如何工作的简单例子。</p>
<pre><code class="language-sh">$ getopt ab:cd -a -b test1 -cd test2 test3 
 -a -b test1 -c -d -- test2 test3 
$
</code></pre>
<p>optstring定义了四个有效选项字母：a、b、c和d。冒号（:）被放在了字母b后面，因为b选项需要一个参数值。当getopt命令运行时，它会检查提供的参数列表（-a -b test1 -cd test2 test3），并基于提供的optstring进行解析。注意，它会自动将-cd选项分成两个单独的选项，并插入双破折线来分隔行中的额外参数。</p>
<p>如果指定了一个不在optstring中的选项，默认情况下，getopt命令会产生一条错误消息。</p>
<pre><code class="language-sh">$ getopt ab:cd -a -b test1 -cde test2 test3 
getopt: invalid option -- e 
 -a -b test1 -c -d -- test2 test3 
$ 
</code></pre>
<p>如果想忽略这条错误消息，可以在命令后加-q选项。</p>
<pre><code class="language-sh">$ getopt -q ab:cd -a -b test1 -cde test2 test3 
 -a -b 'test1' -c -d -- 'test2' 'test3' 
$ 
</code></pre>
<p>注意，getopt命令选项必须出现在optstring之前。现在应该可以在脚本中使用此命令处理命令行选项了。</p>
<ol start="2">
<li>在脚本中使用getopt</li>
</ol>
<p>可以在脚本中使用getopt来格式化脚本所携带的任何命令行选项或参数，但用起来略微复杂。</p>
<p>可以在脚本中使用getopt来格式化脚本所携带的任何命令行选项或参数。</p>
<p>方法是用getopt命令生成的格式化后的版本来替换已有的命令行选项和参数。用set命令能够做到。</p>
<p>set命令能够处理shell中的各种变量。</p>
<p>set命令的选项之一是双破折线（--），它会将命令行参数替换成set命令的命令行值。</p>
<p>然后，该方法会将原始脚本的命令行参数传给getopt命令，之后再将getopt命令的输出传给set命令，用getopt格式化后的命令行参数来替换原始的命令行参数，看起来如下所示。</p>
<pre><code>set -- $(getopt -q ab:cd &quot;$@&quot;) 
</code></pre>
<p>现在原始的命令行参数变量的值会被getopt命令的输出替换，而getopt已经为我们格式化好了命令行参数。</p>
<p>利用该方法，现在就可以写出能帮我们处理命令行参数的脚本。</p>
<pre><code class="language-sh">$ cat test18.sh 
#!/bin/bash 
# Extract command line options &amp; values with getopt 
# 
set -- $(getopt -q ab:cd &quot;$@&quot;) 
# 
echo 
while [ -n &quot;$1&quot; ] 
do 
   case &quot;$1&quot; in 
   -a) echo &quot;Found the -a option&quot; ;; 
   -b) param=&quot;$2&quot; 
       echo &quot;Found the -b option, with parameter value $param&quot; 
       shift ;; 
   -c) echo &quot;Found the -c option&quot; ;; 
   --) shift 
       break ;; 
    *) echo &quot;$1 is not an option&quot;;; 
   esac 
   shift 
done 
# 
count=1 
for param in &quot;$@&quot; 
do 
   echo &quot;Parameter #$count: $param&quot; 
   count=$[ $count + 1 ] 
done 
# 
$
</code></pre>
<p>你会注意到它跟脚本test17.sh一样，唯一不同的是加入了getopt命令来帮助格式化命令行参数。</p>
<p>现在如果运行带有复杂选项的脚本，就可以看出效果更好了。</p>
<pre><code class="language-sh">$ ./test18.sh -ac 
 
Found the -a option 
Found the -c option 
$ 
</code></pre>
<p>当然，之前的功能照样没有问题。</p>
<pre><code class="language-sh">$ ./test18.sh -a -b test1 -cd test2 test3 test4 
 
Found the -a option 
Found the -b option, with parameter value 'test1' 
Found the -c option 
Parameter #1: 'test2' 
Parameter #2: 'test3' 
Parameter #3: 'test4' 
$ 
</code></pre>
<p>现在看起来相当不错了。但是，在getopt命令中仍然隐藏着一个小问题。看看这个例子。</p>
<pre><code class="language-sh">$ ./test18.sh -a -b test1 -cd &quot;test2 test3&quot; test4 
 
Found the -a option 
Found the -b option, with parameter value 'test1' 
Found the -c option 
Parameter #1: 'test2 
Parameter #2: test3' 

</code></pre>
<p>getopt命令并不擅长处理带空格和引号的参数值。它会将空格当作参数分隔符，而不是根据双引号将二者当作一个参数。幸而还有另外一个办法能解决这个问题。</p>
<h4 id="43-使用更高级的-getopts">4.3 使用更高级的 getopts **</h4>
<p>getopts命令（注意是复数）内建于bash shell。它跟近亲getopt看起来很像，但多了一些扩展功能。</p>
<p>与getopt不同，前者将命令行上选项和参数处理后只生成一个输出，而getopts命令能够和已有的shell参数变量配合默契。</p>
<p>每次调用它时，它一次只处理命令行上检测到的一个参数。处理完所有的参数后，它会退出并返回一个大于0的退出状态码。这让它非常适合用解析命令行所有参数的循环中。</p>
<p>getopts命令的格式如下：</p>
<pre><code>getopts optstring variable 
</code></pre>
<p>optstring值类似于getopt命令中的那个。有效的选项字母都会列在optstring中，如果选项字母要求有个参数值，就加一个冒号。<strong>要去掉错误消息的话，可以在optstring之前加一个冒号</strong>。getopts命令将当前参数保存在命令行中定义的variable中。</p>
<p>getopts命令会用到两个环境变量。如果选项需要跟一个参数值，<strong>OPTARG环境变量</strong>就会保存这个值。OPTIND环境变量保存了参数列表中getopts正在处理的参数位置。这样你就能在处理完选项之后继续处理其他命令行参数了。</p>
<p>让我们看个使用getopts命令的简单例子。</p>
<pre><code class="language-sh">$ cat test19.sh 
#!/bin/bash 
# simple demonstration of the getopts command 
# 
echo 
while getopts :ab:c opt 
do 
   case &quot;$opt&quot; in 
      a) echo &quot;Found the -a option&quot; ;; 
      b) echo &quot;Found the -b option, with value $OPTARG&quot;;; 
      c) echo &quot;Found the -c option&quot; ;; 
      *) echo &quot;Unknown option: $opt&quot;;; 
   esac 
done 
$ 


$ ./test19.sh -ab test1 -c 
 
Found the -a option 
Found the -b option, with value test1 
Found the -c option 
$ 
</code></pre>
<p>while语句定义了getopts命令，指明了要查找哪些命令行选项，以及每次迭代中存储它们的变量名（opt）。</p>
<p>你会注意到在本例中case语句的用法有些不同。getopts命令解析命令行选项时会移除开头的单破折线，所以在case定义中不用单破折线。</p>
<p>getopts命令有几个好用的功能。对新手来说，可以在参数值中包含空格。</p>
<pre><code class="language-sh">$ ./test19.sh -b &quot;test1 test2&quot; -a 
 
Found the -b option, with value test1 test2 
Found the -a option 
$ 
</code></pre>
<p>另一个好用的功能是将选项字母和参数值放在一起使用，而不用加空格。</p>
<pre><code class="language-sh">$ ./test19.sh -abtest1 
 
Found the -a option 
Found the -b option, with value test1 
$
</code></pre>
<p>getopts命令能够从-b选项中正确解析出test1值。除此之外，getopts还能够将命令行上找到的所有未定义的选项统一输出成问号。</p>
<pre><code class="language-sh">$ ./test19.sh -d 
 
Unknown option: ? 
$  
$ ./test19.sh -acde 
 
Found the -a option 
Found the -c option 
Unknown option: ? 
Unknown option: ? 
$ 
</code></pre>
<p>optstring中未定义的选项字母会以问号形式发送给代码。</p>
<p>getopts命令知道何时停止处理选项，并将参数留给你处理。在getopts处理每个选项时，它会将OPTIND环境变量值增一。在getopts完成处理时，你可以使用shift命令和OPTIND值来移动参数。</p>
<pre><code class="language-sh">$ cat test20.sh 
#!/bin/bash 
# Processing options &amp; parameters with getopts 
# 
echo 
while getopts :ab:cd opt 
do 
   case &quot;$opt&quot; in 
   a) echo &quot;Found the -a option&quot;  ;; 
   b) echo &quot;Found the -b option, with value $OPTARG&quot; ;; 
   c) echo &quot;Found the -c option&quot;  ;; 
   d) echo &quot;Found the -d option&quot;  ;; 
   *) echo &quot;Unknown option: $opt&quot; ;; 
   esac 
done 
# 
shift $[ $OPTIND - 1 ] 
# 
echo 
count=1 
for param in &quot;$@&quot; 
do 
   echo &quot;Parameter $count: $param&quot; 
   count=$[ $count + 1 ] 
done 
# 
$  
$ ./test20.sh -a -b test1 -d test2 test3 test4 
 
Found the -a option 
Found the -b option, with value test1 
Found the -d option 
 
Parameter 1: test2 
Parameter 2: test3 
Parameter 3: test4 
$
</code></pre>
<p>现在你就拥有了一个能在所有shell脚本中使用的全功能命令行选项和参数处理工具。</p>
<h2 id="5-将选项标准化">5. 将选项标准化</h2>
<p>在创建shell脚本时，显然可以控制具体怎么做。你完全可以决定用哪些字母选项以及它们的用法。</p>
<p>表14-1显示了Linux中用到的一些命令行选项的常用含义。</p>
<figure data-type="image" tabindex="4"><img src="https://s1.ax2x.com/2018/08/10/55Cxz3.png" alt="55Cxz3.png" loading="lazy"></figure>
<p>通过学习本书时遇到的各种bash命令，你大概已经知道这些选项中大部分的含义了。如果你的选项也采用同样的含义，这样用户在使用你的脚本时就不用去查手册了。</p>
<h2 id="6-获得用户输入">6. 获得用户输入</h2>
<p>尽管命令行选项和参数是从脚本用户处获得输入的一种重要方式，但有时脚本的交互性还需要更强一些。比如你想要在脚本运行时问个问题，并等待运行脚本的人来回答。bash shell为此提供了read命令。</p>
<h4 id="61-基本的读取">6.1 基本的读取</h4>
<p>read命令从标准输入（键盘）或另一个文件描述符中接受输入。在收到输入后，read命令会将数据放进一个变量。下面是read命令的最简单用法。</p>
<pre><code class="language-sh">$ cat test21.sh 
#!/bin/bash 
# testing the read command 
# 
echo -n &quot;Enter your name: &quot; 
read name 
echo &quot;Hello $name, welcome to my program. &quot; 
# 
$  
$ ./test21.sh 
Enter your name: Rich Blum 
Hello Rich Blum, welcome to my program. 
$ 
</code></pre>
<p>相当简单。注意，<strong>生成提示的echo命令使用了-n选项。该选项不会在字符串末尾输出换行符，允许脚本用户紧跟其后输入数据，而不是下一行</strong>。这让脚本看起来更像表单。</p>
<p>实际上，read命令包含了-p选项，允许你直接在read命令行指定提示符。</p>
<pre><code class="language-sh">$ cat test22.sh 
#!/bin/bash 
# testing the read -p option 
# 
read -p &quot;Please enter your age: &quot; age 
days=$[ $age * 365 ] 
echo &quot;That makes you over $days days old! &quot; 
# 
$  
$ ./test22.sh 
Please enter your age: 10 
That makes you over 3650 days old! 
$ 
</code></pre>
<p>你会注意到，在第一个例子中当有名字输入时，read命令会将姓和名保存在同一个变量中。read命令会将提示符后输入的所有数据分配给单个变量，要么你就指定多个变量。输入的每个数据值都会分配给变量列表中的下一个变量。如果变量数量不够，剩下的数据就全部分配给最后一个变量。</p>
<pre><code class="language-sh">$ cat test23.sh 
#!/bin/bash 

# entering multiple variables 
# 
read -p &quot;Enter your name: &quot; first last 
echo &quot;Checking data for $last, $first…&quot; 
$  
$ ./test23.sh 
Enter your name: Rich Blum 
Checking data for Blum, Rich... 
$ 
</code></pre>
<p>也可以在read命令行中不指定变量。如果是这样，read命令会将它收到的任何数据都放进<strong>特殊环境变量REPLY中</strong>。</p>
<pre><code class="language-sh">$ cat test24.sh 
#!/bin/bash 
# Testing the REPLY Environment variable 
# 
read -p &quot;Enter your name: &quot; 
echo 
echo Hello $REPLY, welcome to my program. 
# 
$  
$ ./test24.sh 
Enter your name: Christine 
 
Hello Christine, welcome to my program. 
$ 
</code></pre>
<p>REPLY环境变量会保存输入的所有数据，可以在shell脚本中像其他变量一样使用。</p>
<h4 id="62-超时">6.2 超时</h4>
<p>使用read命令时要当心。脚本很可能会一直苦等着脚本用户的输入。如果不管是否有数据输入，脚本都必须继续执行，你可以用-t选项来指定一个计时器。-t选项指定了read命令等待输入的秒数。当计时器过期后，read命令会返回一个非零退出状态码。</p>
<pre><code class="language-sh">$ cat test25.sh 
#!/bin/bash 
# timing the data entry 
# 
if read -t 5 -p &quot;Please enter your name: &quot; name 
then 
   echo &quot;Hello $name, welcome to my script&quot; 
else 
   echo 
   echo &quot;Sorry, too slow! &quot; 
fi 
$ 

$ ./test25.sh 
Please enter your name: Rich 
Hello Rich, welcome to my script 
$  

$ ./test25.sh 
Please enter your name: 
Sorry, too slow! 
$ 
</code></pre>
<p>如果计时器过期，read命令会以非零退出状态码退出，可以使用如if-then语句或while循环这种标准的结构化语句来理清所发生的具体情况。在本例中，计时器过期时，if语句不成立，shell会执行else部分的命令。</p>
<p>也可以不对输入过程计时，而是让read命令来统计输入的字符数。当输入的字符达到预设的字符数时，就自动退出，将输入的数据赋给变量。</p>
<pre><code class="language-sh">$ cat test26.sh 
#!/bin/bash 
# getting just one character of input 
# 
read -n1 -p &quot;Do you want to continue [Y/N]? &quot; answer 
case $answer in 
Y | y) echo 
       echo &quot;fine, continue on…&quot;;; 
N | n) echo 
       echo OK, goodbye 
       exit;; 
esac 
echo &quot;This is the end of the script&quot; 
$  
$ ./test26.sh 
Do you want to continue [Y/N]? Y 
fine, continue on… 
This is the end of the script 
$  
$ ./test26.sh 
Do you want to continue [Y/N]? n 
OK, goodbye 
$ 
</code></pre>
<p>本例中将-n选项和值1一起使用，告诉read命令在接受单个字符后退出。只要按下单个字符回答后，read命令就会接受输入并将它传给变量，无需按回车键。</p>
<h4 id="63-隐藏方式读取">6.3 隐藏方式读取</h4>
<p>有时你需要从脚本用户处得到输入，但又在屏幕上显示输入信息。其中典型的例子就是输入的密码，但除此之外还有很多其他需要隐藏的数据类型。</p>
<p>-s选项可以避免在read命令中输入的数据出现在显示器上（实际上，数据会被显示，只是read命令会将文本颜色设成跟背景色一样）。这里有个在脚本中使用-s选项的例子。</p>
<pre><code class="language-sh">$ cat test27.sh 
#!/bin/bash 
# hiding input data from the monitor 
# 
read -s -p &quot;Enter your password: &quot; pass 
echo 
echo &quot;Is your password really $pass? &quot; 
$  
$ ./test27.sh 
Enter your password: 
Is your password really T3st1ng? 
$
</code></pre>
<p>输入提示符输入的数据不会出现在屏幕上，但会赋给变量，以便在脚本中使用。</p>
<h4 id="64-从文件中读取">6.4 从文件中读取</h4>
<p>最后，也可以用read命令来读取Linux系统上文件里保存的数据。每次调用read命令，它都会从文件中读取一行文本。当文件中再没有内容时，read命令会退出并返回非零退出状态码。</p>
<p>其中最难的部分是将文件中的数据传给read命令。最常见的方法是对文件使用cat命令，将结果通过管道直接传给含有read命令的while命令。下面的例子说明怎么处理。</p>
<pre><code class="language-sh">$ cat test28.sh  
#!/bin/bash 
# reading data from a file 
# 
count=1 
cat test | while read line 
do 
   echo &quot;Line $count: $line&quot; 
   count=$[ $count + 1] 
done 
echo &quot;Finished processing the file&quot; 
$  
$ cat test 
The quick brown dog jumps over the lazy fox. 
This is a test, this is only a test. 
O Romeo, Romeo! Wherefore art thou Romeo? 
$  
$ ./test28.sh 
Line 1: The quick brown dog jumps over the lazy fox. 
Line 2: This is a test, this is only a test. 
Line 3: O Romeo, Romeo! Wherefore art thou Romeo? 
Finished processing the file 
$ 
</code></pre>
<p>while循环会持续通过read命令处理文件中的行，直到read命令以非零退出状态码退出。</p>
<h2 id="7-小结">7. 小结</h2>
<p>本章描述了3种不同的方法来从脚本用户处获得数据。命令行参数允许用户运行脚本时直接从命令行输入数据。脚本通过位置参数来取回命令行参数并将它们赋给变量。</p>
<p>shift命令通过对位置参数进行轮转的方式来操作命令行参数。就算不知道有多少个参数，这个命令也可以让你轻松遍历参数。</p>
<p>有三个特殊变量可以用来处理命令行参数。shell会将$#变量设为命令行输入的参数总数。$*变量会将所有参数保存为一个字符串。$@变量将所有变量都保存为单独的词。这些变量在处理长参数列表时非常有用。</p>
<p>除了参数外，脚本用户还可以用命令行选项来给脚本传递信息。命令行选项是前面带有单破折线的单个字母。可以给不同的选项赋值，从而改变脚本的行为。</p>
<p>bash shell提供了三种方式来处理命令行选项。</p>
<p>第一种方式是将它们像命令行参数一样处理。可以利用位置参数变量来遍历选项，在每个选项出现在命令行上时处理它。</p>
<p>另一种处理命令行选项的方式是用getopt命令。该命令会将命令行选项和参数转换成可以在脚本中处理的标准格式。getopt命令允许你指定将哪些字母识别成选项以及哪些选项需要额外的参数值。getopt命令会处理标准的命令行参数并按正确顺序输出选项和参数。</p>
<p>处理命令行选项的最后一种方法是通过getopts命令（注意是复数）。getopts命令提供了处理命令行参数的高级功能。它支持多值的参数，能够识别脚本未定义的选项。</p>
<p>从脚本用户处获得数据的一种交互方法是read命令。read命令支持脚本向用户提问并等待。read命令会将脚本用户输入的数据赋给一个或多个变量，你在脚本中可以使用它们。</p>
<p>read命令有一些选项支持定制脚本的输入数据，比如隐藏输入数据选项、超时选项以及要求输入特定数目字符的选项。</p>

              </div>
              <div class="post-footer">
  <ul class="post-copyright">
    <li class="post-copyright-author">
      <strong>本文作者：</strong>
      生信学渣
    </li>
    <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://wangxf133.github.io/post/shell-yu-yan-jiao-ben-gou-jian-4-chu-li-yong-hu-shu-ru" title="shell语言脚本构建4-处理用户输入">shell语言脚本构建4-处理用户输入</a>
    </li>
    <li class="post-copyright-license">
      <strong>版权声明： </strong>
      本博客所有文章除特别声明外，转载请注明出处！
    </li>
  </ul>
  <div class="tags">
    
      <a href="https://wangxf133.github.io/tag/cykUzrlw2"># 脚本文件</a>
    
      <a href="https://wangxf133.github.io/tag/PvD-ng_cF"># shell语言</a>
    
  </div>
  <div class="nav">
    <div class="nav-prev">
      
        <i class="fa fa-chevron-left"></i>
        <a class="nav-pc-next" href="https://wangxf133.github.io/post/shell-yu-yan-jiao-ben-gou-jian-5-cheng-xian-shu-ju-yu-jie-guo-shu-chu">shell语言脚本构建5-呈现数据与结果输出</a class="nav-pc-next">
        <a class="nav-mobile-prev" href="https://wangxf133.github.io/post/shell-yu-yan-jiao-ben-gou-jian-5-cheng-xian-shu-ju-yu-jie-guo-shu-chu">上一篇</a>
      
    </div>
    <div class="nav-next">
      
        <a class="nav-pc-next" href="https://wangxf133.github.io/post/shell-yu-yan-jiao-ben-gou-jian-3-geng-duo-de-jie-gou-hua-ming-ling">shell语言脚本构建3-更多的结构化命令</a>
        <a class="nav-mobile-next" href="https://wangxf133.github.io/post/shell-yu-yan-jiao-ben-gou-jian-3-geng-duo-de-jie-gou-hua-ming-ling">下一篇</a>
        <i class="fa fa-chevron-right"></i>
      
    </div>
  </div>
</div>
              
                
                  <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>
  var gitalk = new Gitalk({
    clientID: '5debd0dd15fc74854e71',
    clientSecret: '45d803fcebed7f8b06629f3f1626d55f24a79c4f',
    repo: 'wangxf133.github.io',
    owner: 'wangxf133',
    admin: ['wangxf133'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })
  gitalk.render('gitalk-container')
</script>
                
                
              
            </div>
          </div>
        </div>
      </div>
      <div class="footer-box">
  <footer class="footer">
    <div class="copyright">
      © 2019-2020 <i class="fa fa-heart"></i> HsxyHao
    </div>
    <div class="poweredby">
      <div class="power-left">Power By<a href="https://github.com/hsxyhao"> HsxyHao</a></div>
      <div>Copy<a href="https://github.com/iissnan/hexo-theme-next"> Hexo Next Theme</a></div>
    </div>
  </footer>
  <div class="back-to-top" id="back_to_top">
    <i class="fa fa-arrow-up"></i>
    <span class="scrollpercent">
      <span id="back_to_top_text">100</span>%
    </span>
  </div>
</div>

<script>

  let body = document.body;

  let back2Top = document.querySelector('#back_to_top'),
  back2TopText = document.querySelector('#back_to_top_text');

  function scrollAnimation(currentY, targetY) {
   
    let needScrollTop = targetY - currentY
    let _currentY = currentY
    setTimeout(() => {
      const dist = Math.ceil(needScrollTop / 10)
      _currentY += dist
      window.scrollTo(_currentY, currentY)
      if (needScrollTop > 10 || needScrollTop < -10) {
        scrollAnimation(_currentY, targetY)
      } else {
        window.scrollTo(_currentY, targetY)
      }
    }, 1)
  }

  back2Top.addEventListener("click", function(e) {
    scrollAnimation(body.scrollTop, 0);
    e.stopPropagation();
    return false;
  });
  
  window.addEventListener('scroll', function(e) {
    let percent = body.scrollTop / (body.scrollHeight - body.clientHeight) * 100;
    if (percent > 1 && !back2Top.classList.contains('back-top-active')) {
      back2Top.classList.add('back-top-active');
    }
    if (percent == 0) {
      back2Top.classList.remove('back-top-active');
    }
    back2TopText.textContent = Math.floor(percent);
  });

  // 动态调整站点概览高度
  let sideBar = document.querySelector('.sidebar');
  let navUl = document.querySelector('#nav_ul');
  sideBar.style = 'margin-top:' + (navUl.children.length * 42 + 162) + 'px; opacity: 1;';
  // 代码高亮
  hljs.initHighlightingOnLoad();
</script>
    </div>
  </body>
  <script src="/media/js/motion.js"></script>
</html>