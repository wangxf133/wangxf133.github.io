<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://wangxf133.github.io</id>
    <title>想知道柚子的滋味，你就要亲口尝一尝</title>
    <updated>2019-07-23T10:59:59.104Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://wangxf133.github.io"/>
    <link rel="self" href="https://wangxf133.github.io/atom.xml"/>
    <subtitle>东北师范大学-在读博士</subtitle>
    <logo>https://wangxf133.github.io/images/avatar.png</logo>
    <icon>https://wangxf133.github.io/favicon.ico</icon>
    <rights>All rights reserved 2019, 想知道柚子的滋味，你就要亲口尝一尝</rights>
    <entry>
        <title type="html"><![CDATA[ggplot2详细主题设置(2)]]></title>
        <id>https://wangxf133.github.io/post/ggplot2-xiang-xi-zhu-ti-she-zhi-2</id>
        <link href="https://wangxf133.github.io/post/ggplot2-xiang-xi-zhu-ti-she-zhi-2">
        </link>
        <updated>2019-03-27T11:45:32.000Z</updated>
        <content type="html"><![CDATA[<!--more-->
<p><strong>theme()</strong>,本文将专门讲解一下。凡是与数据无关的图形设置可以归为主题类，ggplot2中主题设置十分多，根本不可能讲解完，只能稍微讲点皮毛，灵活运用才是关键，本文只是总体上略作介绍。正如R语言大神Hadley Wickham所讲的，ggplot2只是提供了一个平台，可以根据自己的需要无限创造。理论上来讲，只要能想到的图形，ggplot2都能实现。</p>
<p>参考文章： <a href="http://ytlogos.coding.me/2017/06/25/ggplot2%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%B3%BB%E5%88%97%E4%B9%8B%E4%B8%BB%E9%A2%98%EF%BC%88theme%EF%BC%89%E8%AE%BE%E7%BD%AE/">Logos的博客</a></p>
<p><img src="http://ww1.sinaimg.cn/large/734cbfa0ly1g3cei9jzdvj20yg0om74d.jpg" alt=""></p>
<pre><code>library(ggplot2)
#我们先来看看ggplot2默认的主题设置函数theme_gray()的源代码
theme_gray#函数名不加括号可获得函数源代码
## function (base_size = 11, base_family = &quot;&quot;) 
## {
## half_line &lt;- base_size/2
## theme(line = element_line(colour = &quot;black&quot;, size = 0.5, linetype = 1, 
## lineend = &quot;butt&quot;), rect = element_rect(fill = &quot;white&quot;, 
## colour = &quot;black&quot;, size = 0.5, linetype = 1), text = element_text(family = base_family, 
## face = &quot;plain&quot;, colour = &quot;black&quot;, size = base_size, lineheight = 0.9, 
## hjust = 0.5, vjust = 0.5, angle = 0, margin = margin(), 
## debug = FALSE), axis.line = element_blank(), axis.line.x = NULL, 
## axis.line.y = NULL, axis.text = element_text(size = rel(0.8),
## colour = &quot;grey30&quot;), axis.text.x = element_text(margin = margin(t = 0.8 * 
## half_line/2), vjust = 1), axis.text.x.top = element_text(margin = margin(b = 0.8 * ## half_line/2), vjust = 0), axis.text.y = element_text(margin = margin(r = 0.8 * 
## half_line/2), hjust = 1), axis.text.y.right = element_text(margin = margin(l = 0.8 * ## half_line/2), hjust = 0), axis.ticks = element_line(colour = &quot;grey20&quot;), 
## axis.ticks.length = unit(half_line/2, &quot;pt&quot;), axis.title.x = element_text(margin = margin(t = half_line), 
## vjust = 1), axis.title.x.top = element_text(margin = margin(b = half_line), 
## vjust = 0), axis.title.y = element_text(angle = 90, 
## margin = margin(r = half_line), vjust = 1), axis.title.y.right = element_text(angle = -90, 
## margin = margin(l = half_line), vjust = 0), legend.background = element_rect(colour = NA), 
## legend.spacing = unit(0.4, &quot;cm&quot;), legend.spacing.x = NULL, 
## legend.spacing.y = NULL, legend.margin = margin(0.2, 
## 0.2, 0.2, 0.2, &quot;cm&quot;), legend.key = element_rect(fill = &quot;grey95&quot;, 
## colour = &quot;white&quot;), legend.key.size = unit(1.2, &quot;lines&quot;), 
## legend.key.height = NULL, legend.key.width = NULL, legend.text = element_text(size = rel(0.8)), 
## legend.text.align = NULL, legend.title = element_text(hjust = 0), 
## legend.title.align = NULL, legend.position = &quot;right&quot;, 
## legend.direction = NULL, legend.justification = &quot;center&quot;, 
## legend.box = NULL, legend.box.margin = margin(0, 0, 0, 
## 0, &quot;cm&quot;), legend.box.background = element_blank(),
## legend.box.spacing = unit(0.4, &quot;cm&quot;), panel.background = element_rect(fill = &quot;grey92&quot;, 
## colour = NA), panel.border = element_blank(), panel.grid.major = element_line(colour = &quot;white&quot;), 
## panel.grid.minor = element_line(colour = &quot;white&quot;, size = 0.25), 
## panel.spacing = unit(half_line, &quot;pt&quot;), panel.spacing.x = NULL, 
## panel.spacing.y = NULL, panel.ontop = FALSE, strip.background = element_rect(fill = &quot;grey85&quot;, 
## colour = NA), strip.text = element_text(colour = &quot;grey10&quot;, 
## size = rel(0.8)), strip.text.x = element_text(margin = margin(t = half_line, 
## b = half_line)), strip.text.y = element_text(angle = -90, 
## margin = margin(l = half_line, r = half_line)), strip.placement = &quot;inside&quot;, 
## strip.placement.x = NULL, strip.placement.y = NULL, strip.switch.pad.grid = unit(0.1, 
## &quot;cm&quot;), strip.switch.pad.wrap = unit(0.1, &quot;cm&quot;), plot.background = element_rect(colour = &quot;white&quot;), 
## plot.title = element_text(size = rel(1.2), hjust = 0, 
## vjust = 1, margin = margin(b = half_line * 1.2)), 
## plot.subtitle = element_text(size = rel(0.9), hjust = 0, 
## vjust = 1, margin = margin(b = half_line * 0.9)),
## plot.caption = element_text(size = rel(0.9), hjust = 1, 
## vjust = 1, margin = margin(t = half_line * 0.9)),
## plot.margin = margin(half_line, half_line, half_line, 
## half_line), complete = TRUE)
## }
## &lt;environment: namespace:ggplot2&gt;
</code></pre>
<p>可以看出，源代码主要是theme()函数，设置也很简单：theme(..., complete = FALSE),但是其内含的参数则十分多。</p>
<p><img src="http://ww1.sinaimg.cn/large/734cbfa0ly1g3ceimjov5j20jc0imwgq.jpg" alt=""><br>
<img src="http://ww1.sinaimg.cn/large/734cbfa0ly1g3ceis7x13j20r50mjqa4.jpg" alt=""></p>
<p>几乎所有元素在theme()里都使用element_line，element_rect，element_text和element_blank函数设置. 下面就举例稍微讲解一下</p>
<pre><code>#利用数据集mtcars演示head(mtcars)
#先创建p图层
p&lt;- ggplot(data=mtcars, aes(x=wt, y=mpg))+
geom_point(aes(color=factor(cyl)))#先试试图例修改
p+theme(legend.position = &quot;none&quot;)#无图例
</code></pre>
<p><img src="http://ww1.sinaimg.cn/large/734cbfa0ly1g3cej78cwjj20uu0gujrr.jpg" alt=""></p>
<pre><code>p+theme(legend.position = &quot;bottom&quot;)#图例在底部
</code></pre>
<p><img src="http://ww1.sinaimg.cn/large/734cbfa0ly1g3cejd86jtj20qn0gr3z0.jpg" alt=""></p>
<p>#也可以自定义</p>
<pre><code>p+theme(legend.position = c(0.5, 0.7))
</code></pre>
<p><img src="http://ww1.sinaimg.cn/large/734cbfa0ly1g3cejjwu4nj20sv0guq3g.jpg" alt=""></p>
<pre><code>#为图例加边界
p+theme(legend.background = element_rect(color=&quot;red&quot;))
</code></pre>
<p><img src="http://ww1.sinaimg.cn/large/734cbfa0ly1g3cejq3p82j20pu0gywez.jpg" alt=""></p>
<pre><code>#或者为图例中的每个元素进行设置，如加边界
p+theme(legend.key =element_rect(color=&quot;red&quot;))
</code></pre>
<p><img src="http://ww1.sinaimg.cn/large/734cbfa0ly1g3cejv8e6gj20yg0omaa5.jpg" alt=""></p>
<pre><code>#进行填充
p+theme(legend.key = element_rect(fill=&quot;yellow&quot;))
</code></pre>
<p><img src="http://ww1.sinaimg.cn/large/734cbfa0ly1g3cek0lb3wj20yg0omjrg.jpg" alt=""></p>
<pre><code>#图例内容字体大小、颜色、角度等设置
p+theme(legend.text = element_text(size=25, color=&quot;darkred&quot;, angle=45))
</code></pre>
<p><img src="http://ww1.sinaimg.cn/large/734cbfa0ly1g3cek5umidj20q80h0wf3.jpg" alt=""></p>
<pre><code>#为图例标题设置字体、颜色、大小等
p+theme(legend.title = element_text(face=&quot;italic&quot;, size=25, color=&quot;red&quot;))
</code></pre>
<p><img src="http://ww1.sinaimg.cn/large/734cbfa0ly1g3cekd0l39j20oj0gwmxs.jpg" alt=""></p>
<p>接下来是坐标以及网格等的自定义</p>
<pre><code>#修改背景颜色
p+theme(panel.background = element_rect(fill=&quot;black&quot;))
</code></pre>
<p><img src="http://ww1.sinaimg.cn/large/734cbfa0ly1g3ceklgogtj20r60gzaam.jpg" alt=""></p>
<pre><code>#修改边界线类型、颜色
p+theme(panel.border = element_rect(linetype = &quot;dashed&quot;, color=&quot;red&quot;))
</code></pre>
<p><img src="http://ww1.sinaimg.cn/large/734cbfa0ly1g3cektm6uqj20yg0omjrc.jpg" alt=""></p>
<pre><code>#修改网格线p+theme(panel.grid.major = element_line(color=&quot;blue&quot;, size= 3))
</code></pre>
<p><img src="http://ww1.sinaimg.cn/large/734cbfa0ly1g3cel0cukej20q50h0q3h.jpg" alt=""></p>
<pre><code>p+theme(panel.grid.minor = element_line(linetype = &quot;dotted&quot;, color=&quot;red&quot;))
</code></pre>
<p><img src="http://ww1.sinaimg.cn/large/734cbfa0ly1g3cel72cigj20qr0h0mxz.jpg" alt=""></p>
<blockquote>
<p>还可以修改x、y轴等，这里懒得讲了，有兴趣的可以自己捣鼓捣鼓</p>
</blockquote>
<p>了解theme之后就可以自己定义自己的主题，以后作图就直接像格式刷一样就行</p>
<pre><code>
#下面是我比较常用的主题，画图时刷一下就行了
windowsFonts(CA=windowsFont(&quot;Calibri&quot;))
mytheme &lt;- theme_bw()+
theme(legend.position = 'top', panel.border = element_blank(), 
panel.grid.major = element_line(linetype = 'dashed'), panel.grid.minor = 
element_blank(), legend.text = element_text(size=9,color='#003087',family = &quot;CA&quot;), 
plot.title = element_text(size=15,color=&quot;#003087&quot;,family = &quot;CA&quot;), legend.key = 
element_blank(), axis.text = element_text(size=10,color='#003087',family = &quot;CA&quot;), 
strip.text = element_text(size=12,color=&quot;#EF0808&quot;,family = &quot;CA&quot;), 
strip.background = element_blank())
pie_theme &lt;- mytheme+
theme(axis.text = element_blank(), axis.ticks = element_blank(), axis.title = 
element_blank(), panel.grid.major = element_blank())
myline_blue &lt;- geom_line(color=&quot;#085A9C&quot;, size=2)
myline_red &lt;- geom_line(color=&quot;#EF0808&quot;,size=2)
myarea &lt;- geom_area(color=NA,fill=&quot;#003087&quot;,alpha=0.2)
mypoint &lt;- geom_point(size=3,shape=21,color=&quot;#003087&quot;,fill=&quot;white&quot;)
mybar &lt;- geom_bar(fill=&quot;#0C8DC4&quot;,stat = &quot;identity&quot;)
mycolor_3 &lt;- scale_fill_manual(values = c(&quot;#085A9C&quot;,&quot;#EF0808&quot;,&quot;#526373&quot;))
mycolor_7 &lt;- scale_fill_manual(values=c (&quot;#085A9C&quot;,&quot;#EF0808&quot;,&quot;#526373&quot;,&quot;#FFFFE7&quot;,&quot;#FF9418&quot;,&quot;#219431&quot;,&quot;#9C52AD&quot;))
mycolor_line_7 &lt;- scale_color_manual(values=c (&quot;#085A9C&quot;,&quot;#EF0808&quot;,&quot;#526373&quot;,&quot;#FFFFE7&quot;,&quot;#FF9418&quot;,&quot;#219431&quot;,&quot;#9C52AD&quot;))
</code></pre>
<pre><code>#可以来刷一刷#随便建个数据集
x &lt;-rep(1:5, each = 3)
y &lt;-rep(c('A','B','C'),times = 5)
set.seed(1111)
z &lt;-round(runif(min = 10, max = 30, n = 15))
df &lt;-data.frame(x = x, y = y, z = z)
head(df)
##   x   y   z
## 1 1   A   19
## 2 1   B   18
## 3 1   C   28
## 4 2   A   13
## 5 2   B   25
## 6 2   C   30
#柱形图
(p1 &lt;- ggplot(data=df, aes(x=factor(x), y=z, fill=y))+
geom_bar(stat = &quot;identity&quot;, position = &quot;dodge&quot;)+
ggtitle(&quot;自定义主题theme并应用实践&quot;))+
xlab(&quot;随便定义了个x&quot;)+ylab(&quot;随机数&quot;)
</code></pre>
<p><img src="http://ww1.sinaimg.cn/large/734cbfa0ly1g3celisf60j20py0h6mxt.jpg" alt=""></p>
<pre><code>p1+mytheme
</code></pre>
<p><img src="http://ww1.sinaimg.cn/large/734cbfa0ly1g3celnnf2aj20yg0omglp.jpg" alt=""></p>
<pre><code>p1+mytheme+mycolor_7
</code></pre>
<p><img src="http://ww1.sinaimg.cn/large/734cbfa0ly1g3celsy7kzj20yg0om74d.jpg" alt=""></p>
<p>还有线图、饼图等有兴趣的也可以自己刷一刷，你会发现ggplot2的魅力所在就是它拥有无穷的可能性。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ggplot2详细主题设置(1)]]></title>
        <id>https://wangxf133.github.io/post/ggplot2-xiang-xi-zhu-ti-she-zhi-1</id>
        <link href="https://wangxf133.github.io/post/ggplot2-xiang-xi-zhu-ti-she-zhi-1">
        </link>
        <updated>2019-03-27T11:44:47.000Z</updated>
        <content type="html"><![CDATA[<!--more-->
<p>参考文章： http://www.rpubs.com/lihaoyi/156592</p>
<pre><code># install.packages('ggplot2') 安装ggplot2包

# install.packages('gcookbook') 安装gcookbook包
library(ggplot2)  #加载ggplot2包
library(gcookbook)  #加载本书的数据包
</code></pre>
<h1 id="主题theme参数设置">主题theme参数设置</h1>
<p>改变字体类型、大小，图例、坐标轴、背景等各种元素，可通过theme()函数来完成</p>
<pre><code>library(ggplot2)
library(grid)  #为了使用unit函数
p0 &lt;- ggplot(data = mpg, aes(x = displ, fill = factor(cyl))) + geom_bar(colour = 1, 
    binwidth = 0.2) + labs(title = &quot;plot title&quot;)
p0  #基础图
</code></pre>
<p><img src="http://ww1.sinaimg.cn/large/734cbfa0ly1g3ceevs97fj20qo0ao0sm.jpg" alt=""></p>
<h2 id="图片区参数设置">图片区参数设置</h2>
<ul>
<li>plot.background： 图片区背景设置</li>
<li>plot.title： 图片标题设置</li>
<li>plot.margin： 图片区边缘距离设置</li>
</ul>
<p>将图片区背景填充色设置为lightblue，边框颜色设置为黑色，宽度设置为3，线型设置为虚线，图标题的字体颜色为黑色，粗体，字体大小30，顶部对齐，同时设置图边沿距离</p>
<pre><code>p0 + theme(plot.background = element_rect(colour = &quot;black&quot;, size = 3, linetype = 4, 
    fill = &quot;lightblue&quot;), plot.title = element_text(colour = &quot;black&quot;, face = &quot;bold&quot;, 
    size = 30, vjust = 1), plot.margin = unit(c(0.2, 0.2, 0.2, 0.2), &quot;inches&quot;))
</code></pre>
<p><img src="http://ww1.sinaimg.cn/large/734cbfa0ly1g3cef1ii2xj20qo0ao746.jpg" alt=""></p>
<h2 id="绘图区轴线围城的区域参数设置">绘图区（轴线围城的区域）参数设置</h2>
<ul>
<li>panel.background： 绘图区背景色，colour可以设置边框颜色，fill为填充色</li>
<li>panel.border： 绘图区边框</li>
<li>panel.grid： 网格线</li>
<li>panel.grid.major： 主要网格线</li>
<li>panel.grid.minor： 次要网格线</li>
<li>panel.grid.major.x： x轴主要网格线</li>
<li>panel.grid.major.y： y轴主要网格线</li>
<li>panel.grid.minor.x： x轴次要网格线</li>
<li>panel.grid.minor.y： y轴次要网格线</li>
</ul>
<pre><code>p0
</code></pre>
<p><img src="http://ww1.sinaimg.cn/large/734cbfa0ly1g3cefdjafvj20qo0ao0sm.jpg" alt=""></p>
<pre><code>p0 + theme(panel.background = element_rect(fill = &quot;lightblue&quot;))  #将图片区的背景色设置为lightblue
</code></pre>
<p><img src="http://ww1.sinaimg.cn/large/734cbfa0ly1g3cefjl7tuj20qo0ao0sm.jpg" alt=""></p>
<pre><code>p0 + theme(panel.background = element_rect(fill = &quot;lightblue&quot;, colour = &quot;red&quot;, 
    size = 3))  #将图片区的背景色设置为lightblue，边框颜色为红色，边框宽度为3
</code></pre>
<p><img src="http://ww1.sinaimg.cn/large/734cbfa0ly1g3cefo0hoaj20qo0aomx1.jpg" alt=""></p>
<h2 id="坐标轴参数设置">坐标轴参数设置</h2>
<ul>
<li>axis.title： 轴标题</li>
<li>axis.title.x： x轴标题</li>
<li>axis.title.y： y轴标题</li>
<li>axis.text： 轴刻度值</li>
<li>axis.text.x： x轴刻度值</li>
<li>axis.text.y： y轴刻度值</li>
<li>axis.ticks： 轴刻度线</li>
<li>axis.ticks.x： x轴刻度线</li>
<li>axis.ticks.y： y轴刻度线</li>
<li>axis.ticks.length： 轴刻度线长度，负值向里</li>
<li>axis.ticks.margin： 轴刻度线与轴刻度值的距离</li>
<li>axis.line： 轴线</li>
<li>axis.line.x： x轴线</li>
<li>axis.line.y： y轴线</li>
</ul>
<pre><code>p0
</code></pre>
<p><img src="http://ww1.sinaimg.cn/large/734cbfa0ly1g3cefurvyzj20qo0ao0sm.jpg" alt=""></p>
<pre><code>axis_theme&lt;-theme(
  axis.title=element_text(
    #family=NULL,
    face = &quot;bold&quot;, #字体(&quot;plain&quot;, &quot;italic&quot;, &quot;bold&quot;, &quot;bold.italic&quot;)
    colour = &quot;red&quot;, #字体颜色
    size = 25,#字体大小
    hjust = .5, #调整轴标题1：纵轴靠上，横轴靠右；0.5居中；0：纵轴靠下，横轴靠左
    vjust = .5, #1：靠图边框；0靠近轴线；.5居中
    angle = 0 #为什么只对横轴标题有作用？
 ),
  axis.title.x=element_text(colour=&quot;blue&quot;),#x轴标题设置，优先级高于axis.title
  axis.title.y=element_text(colour=&quot;orange&quot;),#同上
  axis.text=element_text(colour=&quot;red&quot;),#设置坐标轴刻度数字
  axis.text.x=element_text(colour=&quot;blue&quot;),#优先级高于aixis.text
  axis.text.y=element_text(colour=&quot;orange&quot;),#同上
  axis.ticks=element_line(#坐标轴刻度线的设置
    colour=&quot;red&quot;,
    size=.5,
    linetype=1,
    lineend=1),
  axis.ticks.x=element_line(colour=&quot;blue&quot;),#优先级高于axis.ticks
  axis.ticks.y=element_line(colour=&quot;orange&quot;),#同上
  axis.ticks.length=unit(.4,&quot;lines&quot;),#设置刻度线的高度
  axis.ticks.margin=unit(.4,&quot;cm&quot;),#设置刻度数字与刻度线的距离
  axis.line=element_line(#设置轴线
    colour=&quot;red&quot;),
  axis.line.x=element_line(colour=&quot;blue&quot;),#设置x轴线，优先于axis.line
  axis.line.y=element_line(colour=&quot;orange&quot;))#类似axis.line.x

p0+axis_theme
</code></pre>
<p><img src="http://ww1.sinaimg.cn/large/734cbfa0ly1g3ceg1oorsj20qo0ao0sm.jpg" alt=""></p>
<h2 id="图例参数设置">图例参数设置</h2>
<ul>
<li>legend.background： 图例背景色</li>
<li>legend.margin： 图例边界</li>
<li>legend.key： 图例分类标识底部背景颜色</li>
<li>legend.key.size： 图例标识大小</li>
<li>legend.key.height： 图例标识的高度</li>
<li>legend.key.width： 图例标识的宽度</li>
<li>legend.text： 图例分类标签</li>
<li>legend.text.align： 图例分类标签对齐方式</li>
<li>legend.title： 图例标题</li>
<li>legend.title.align： 图例标题的对齐方式</li>
<li>legend.position： 图例位置</li>
<li>legend.direction： 图例类别排列方向</li>
<li>legend.justification： 图例位置的偏移调整</li>
<li>legend.box： 有多个图例时的排列方式</li>
</ul>
<pre><code>p0
</code></pre>
<p><img src="http://ww1.sinaimg.cn/large/734cbfa0ly1g3ceg6jtzvj20qo0ao0sm.jpg" alt=""></p>
<pre><code>legend_theme&lt;-theme(
  legend.background=element_rect(
    colour=NA,#图例边框颜色
    fill=&quot;lightblue&quot;),#图例背景填充色
  legend.margin=unit(.2,&quot;inches&quot;),#图例与图片区边缘的距离
  legend.key=element_rect(fill=&quot;yellow&quot;),
  legend.key.size=unit(.2,&quot;inches&quot;),#图例分类符号的大小
  legend.key.height=unit(.5,&quot;inches&quot;),#图例分类符号高度
  legend.key.width=unit(.5,&quot;inches&quot;),#图例符号的宽度
  legend.text=element_text(colour=&quot;red&quot;,size=20),#图例分类标签设置
  legend.text.align=0,#0左，1右，0.5居中， 图例分类标签的对齐方式
  legend.title=element_text(colour=&quot;blue&quot;,size=20),#图例标题设置
  legend.title.align=1,#图例标题对齐方式
  legend.position=c(0.6,.7),#&quot;none&quot;,&quot;left&quot;,&quot;right&quot;,&quot;bottom&quot;,&quot;top&quot;,or 
  # two-element numeric vector,(0,0)-(1,1)
  legend.direction=&quot;horizontal&quot;,#&quot;vertical&quot; 图例排列方向
  legend.justification=c(.4,.4),#&quot;center&quot; or two-element numeric vector
  legend.box=&quot;vertical&quot;,#&quot;horizontal&quot;,对图例的排列方式
  legend.box.just=&quot;top&quot;#多图例的居中方式
)

p0+legend_theme
</code></pre>
<p><img src="http://ww1.sinaimg.cn/large/734cbfa0ly1g3cega6j84j20qo0ao0sn.jpg" alt=""></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Circos配置文件]]></title>
        <id>https://wangxf133.github.io/post/circos-pei-zhi-wen-jian</id>
        <link href="https://wangxf133.github.io/post/circos-pei-zhi-wen-jian">
        </link>
        <updated>2019-03-27T11:43:07.000Z</updated>
        <content type="html"><![CDATA[<!--more-->
<p>主要参考博客：http://ytlogos.coding.me/</p>
<h1 id="circos的配置文件准备">Circos的配置文件准备</h1>
<p>Circos的使用主要通过输入一个配置文件，改配置文件的主要内容以各种区块表示，大区块中可以包含小区快。区块中以”变量=值”的方式来进行参数的设定：</p>
<pre><code>&lt;links&gt;
&lt;link&gt;
  file = data/set1.txt
  color = black
  ...
&lt;/link&gt;
&lt;link&gt;
  file = data/set2.txt
  color = red
  ...
&lt;/link&gt;
&lt;/links&gt;
</code></pre>
<blockquote>
<p>有些配置文件不需要改动，比如颜色、字体等，一般将这类信息保存到一个独立的配置文件中。只需要在主配置文件中声明包含这些独立的配置文件名及其路径，即表示使用这些配置信息。最常用的放置到主配置文件尾部的数行</p>
</blockquote>
<h2 id="设置生成的图片参数">设置生成的图片参数</h2>
<pre><code>&lt;image&gt;
&lt;&lt;include etc/image.conf&gt;&gt;
&lt;/image&gt;
</code></pre>
<p>##设置颜色、字体、填充模式的配置信息、</p>
<pre><code>&lt;&lt;include etc/colors_fonts_patterns.conf&gt;&gt;
</code></pre>
<h2 id="系统与debug参数">系统与debug参数</h2>
<pre><code>&lt;&lt;include etc/housekeeping.conf&gt;&gt;
</code></pre>
<h1 id="circos的使用参数">Circos的使用参数</h1>
<pre><code>-version
查询Circos版本
-modules
检测perl模块
-conf &lt;string&gt;
输入主文件配置
-outputdir &lt;string&gt;
设置输出文件名，该参数的值以.png为后缀
-svg
生成svg结果文件
-nosvg
不生成svg结果文件
</code></pre>
<h1 id="circos配置文件详解">Circos配置文件详解</h1>
<h2 id="ideogram-block显示染色体">ideogram block显示染色体</h2>
<p>将染色体在圈图上展示出来，代表每个染色体的图形，称为ideogram。将以下配置信息放入一个单独的配置文件中，命名为ideogram.conf</p>
<pre><code>&lt;ideogram&gt;
##设定ideogram之间的间隙
  &lt;spacing&gt;
  #设置圈图染色体之间的间隙大小，以下设置为每个间隙大小为周长的0.5%
  default = 0.005r
#也可以设置指定的两条染色体之间的间隙
  #&lt;pairwise chrA01;chrA02&gt;
  #以下设定为两条染色体之间的间隙为圆的20度角
  #spacing = 20r
  #&lt;/pairwise&gt;
&lt;/spacing&gt;
##设定ideogram
#设定ideogram的位置，一下设定为ideograms在图离圆心的90%处
radius = 0.90r
#设定ideograms是否填充颜色。填充的颜色取决于karyotype指定的文件的最后一列
fill = yes
#设定ideograms轮廓的颜色及其厚度。如果没有该参数或设定其厚度为0，则表示没有轮廓
stroke_color = dgrey
stroke_thickness = 2p
## 设定label的显示信息
#设定是否显示label，label对应着karyotype文件的第四列，如果其值为yes，则必须要有label_radius参数来设定label的位置，否则会报错无法生成结果
show_label = yes
# 设定label的字体
label_font = default
# 设定label字体大小
label_size = 40
# 设定label的字体方向，yes是易于浏览的方向
label_parallel = yes
&lt;/ideogram&gt;
</code></pre>
<h2 id="ticks-block以刻度形式显示染色体大小">ticks block以刻度形式显示染色体大小</h2>
<p>将染色体的大小以刻度的形式在圈图上展示出来，将以下配置信息放入到一个独立的配置文件中，命名为ticks.conf</p>
<pre><code>#是否显示ticks
show_ticks = yes
#是否显示ticks的labels
show_ticks_labels = yes
#设定ticks
&lt;ticks&gt;
##ticks的设置
#设定ticks的位置
radius = 1r
#设置ticks的颜色
color = black
#设置ticks的厚度
thickness = 2p
#设置ticks'label的值的计算，将改刻度对应的值*multiplier得到展示到圈图上的label值
multiplier = 1e-6
#label值的格式化方法，%d表示结果为整数；%f表示结果为浮点数；%.nf表示结果保留小数点后n位
format = %d
## 以下设置了2个ticks，前者是小刻度，后者是大刻度
&lt;tick&gt;
#设置每个刻度代表的长度，若其单位为u，则必须要设置chromosome_units参数，比如设置chromosome_units=1000000,则如下5u表示每个刻度代表5M长度的基因组序列
spacing = 5u
#设置tick的长度
size = 10p
&lt;/tick&gt;
&lt;tick&gt;
spacing = 25u
size = 15p
#由于设置的是大刻度，以下用于设置展示ticks'label
show_label = yes
#设置ticks'label字体大小
label_size= 20p
#设置ticks'label离ticks的距离
label_offset = 10p
format = %d
&lt;/tick&gt;
&lt;/ticks&gt;
</code></pre>
<h2 id="links-block以曲线连接显示基因组内部之间的联系">links block以曲线连接显示基因组内部之间的联系</h2>
<p>基因组内部不同的序列区域之间有联系，将之使用线条进行连接，从而展示到圈图上，常见的是重复序列之间的连接，将以下配置信息放入到一个独立的配置文件中，命名为links.conf</p>
<pre><code>&lt;links&gt;
&lt;link&gt;
#指定link文件的路径，其文件格式为：
# chr1 start end chr2 start end
# chrA01 1 10 chrC01 10 45
#表明这两条染色体区域有联系，例如这个区域的序列长度&gt;1kb且序列相似性&gt;=90%
file = data/segdup.txt
#设置link曲线的半径
radius = 0.8r
#设置贝塞尔曲线半径，该值越大曲线越扁平，不好看
bezier_radius = 0r
#设置link曲线的颜色
color = black_a4
#设置link曲线的厚度
thickness = 2
&lt;rules&gt;
#以下可以设置多个rule，用来对link文件的每一行进行过滤或展示进行设定。每个rule都有一个condition参数，如果该condition为真，执行该block的内容，除非flow=continue，则不执行，检测下一个rule
#下面如果link文件中该行数据是染色体内部的link，则不进行展示
&lt;rule&gt;
condition = var(intrachr)
show = no
&lt;/rule&gt;
#设置link曲线的颜色与ideogram的颜色一致，否则为统一的颜色
&lt;rule&gt;
#若condition为真，则执行该block的内容
condition = 1
#设置link曲线的颜色为第二条染色体的颜色，对应着link文件中第四列数据对应的染色体的名称
color = eval(var(chrC02))
#虽然condition为真，但依然检测下一个rule
flow = continue
&lt;/rule&gt;
#如果link起始于chrA01，则其link曲线半径为0.99r
&lt;rule&gt;
contidition = from(chrA01)
radius1 = 0.99r
&lt;/rule&gt;
#如果link结束于chrC01，则其link曲线半径为0.99r
&lt;rule&gt;
condition = to(chrC01)
radius2 = 0.99r
&lt;/rule&gt;
&lt;/rules&gt;
&lt;/link&gt;
&lt;/links&gt;
</code></pre>
<h2 id="plots-block以直方图形式展示数据">plots block以直方图形式展示数据</h2>
<pre><code>&lt;plot&gt;
#设定直方图
type = histogram
#数据文件路径，4列
#chromosome start end data
# chrA01 0 2000000 155.0000
file = data/Bna1234.hist.txt
#设置直方图的位置，r1要比r0大，直方图的方向默许为向外
r1 = 0.88r
r0 = 0.81r
#直方图的填充颜色
fill_color = vdgrey
#默认下直方图轮廓厚度为1px，若不需要轮廓，将其设置为9，或者直接在etc/tracks/histogram.conf中修改
thickness = 0p
#直方图是由bins所构成的，若bins在坐标轴上不相连，最好设置不要将其bins连接到一起，例如：
# chrA01 10 20 0.5
# chrA01 30 40 0.25
#上述数据设置值为yes和no时，图形是不一样的
extend_bin = no
#以下添加rule，不在chrA01上添加直方图
&lt;rules&gt;
&lt;&lt;include exclude.chrA01.rule&gt;&gt;
&lt;/rules&gt;
#设置直方图的背景颜色
&lt;backgrounds&gt;
show = data
&lt;background&gt;
color = vvlgrey
&lt;/background&gt;
&lt;background&gt;
color = vlgrey
y0 = 0.2r
y1 = 0.5r
&lt;/background&gt;
&lt;background&gt;
color = lgrey
y0 = 0.5r
y1 = 0.8r
&lt;/background&gt;
&lt;background&gt;
color = grey
y0 = 0.8r
&lt;/background&gt;
&lt;/backgrounds&gt;
&lt;/plot&gt;
&lt;plot&gt;
type = histogram
#此处直方图的数据文件第4列是由多个由逗号分隔的数值，需要制作叠加的直方图
file = data/Bna.stacked.txt
r1 = 0.99r
r0 = 0.92r
#给4个值按顺序填充不同的颜色
fill_color = chrA01,chrA02,chrA03,chrA04
thickness = 0p
orientation = in
extend_bin = no
&lt;rules&gt;
&lt;&lt;include exclude.chrA01.rule&gt;&gt;
&lt;/rules&gt;
#在直方图中添加坐标网格线
&lt;axes&gt;
show = data
thickness = 1
color = lgrey
&lt;axis&gt;
spacing = 0.1r
&lt;/axis&gt;
&lt;axis&gt;
spacing = 0.2r
color = grey
&lt;/axis&gt;
&lt;axis&gt;
position = 0.5r
color = red
&lt;/axis&gt;
&lt;axis&gt;
position = 0.85r
color = green
thickness = 2
&lt;/axis&gt;
&lt;/axes&gt;
&lt;/plot&gt;
</code></pre>
<h2 id="plots-block以热图形式显示数据">plots block以热图形式显示数据</h2>
<p>基因组一个区域内有多组数据时，适合以热图的形式显示数据，比如基因表达量，将以下配置信息放入一个单独的配置文件中，命名为plots_heatmap.conf</p>
<pre><code>&lt;plot&gt;
#绘制heatmap
type = haetmap
#设置数据文件路径，文件有5列
# chrID start end data class
# chrA01 0 1999999 113.0000 id=chrA01
# chrA01 0 1999999 40.0000 id=chrA04
# chrA01 0 1999999 20.0000 id=chrA02
# chrA01 0 1999999 7.0000 id=chrA03
file = data/Bna.heatmap.txt
#设置图形所处位置
r1 = 0.89r
r0 = 0.88r
#设置热图的颜色，颜色为chrA01，以及相应带不同透明程度的5中颜色
color = chrA01_a5,chrA01_a4,chrA01_a3,chrA01_a2,chrA01_a1,chrA01
#设定scale_log_base参数，计算颜色的方法如下：
# f = (value - min)/(max - min)热图中每个方块代表着一个值，并给予相应的颜色标示，一系列的值[min,max]对应一系列的颜色c[n],i=0..N
#n=N*f**(1/scale_log_base)
#若scale_log_base = 1，则数值与颜色的变化是线性的
#若scale_log_base &gt; 1，则颜色向小方向靠近
#若scale_log_base &lt; 1，则颜色向大方向靠近
scale_log_base = 5
&lt;rules&gt;
&lt;&lt;include exclude.chrA01.rule&gt;&gt;
#仅显示id = chrA01的数据
&lt;rule&gt;
condition = var(id) ne &quot;chrA01&quot;
show = no
&lt;/rule&gt;
&lt;/rules&gt;
&lt;plot&gt;
 type = heatmap
 file = data/Bna.heatmap.txt
 r1 = 0.90r
 r0 = 0.89r
 color = chrA02_a5,chrA02_a4,chrA02_a3,chrA02_a2,chrA02_a1,chrA02
 scale_log_base = 5
&lt;rules&gt;
 &lt;&lt;include exclude.chrA01.rule&gt;&gt;
&lt;rule&gt;
 condition = var(id) ne &quot;chrA02&quot;
 show = no
 &lt;/rule&gt;
&lt;/rules&gt;
&lt;/plot&gt;
&lt;plot&gt;
 type = heatmap
 file = data/Bna.heatmap.txt
 r1 = 0.91r
 r0 = 0.90r
 color = chrA03_a5,chrA03_a4,chrA03_a3,chrA03_a2,chrA03_a1,chrA03
 scale_log_base = 5
&lt;rules&gt;
 &lt;&lt;include exclude.chrA01.rule&gt;&gt;
&lt;rule&gt;
 condition = var(id) ne &quot;chrA03&quot;
 show = no
 &lt;/rule&gt;
&lt;/rules&gt;
&lt;/plot&gt;
&lt;plot&gt;
 type = heatmap
 file = data/Bna.heatmap.txt
 r1 = 0.92r
 r0 = 0.91r
 color = chrA04_a5,chrA04_a4,chrA04_a3,chrA04_a2,chrA04_a1,chrA04
 scale_log_base = 5
&lt;rules&gt;
 &lt;&lt;include exclude.chrA01.rule&gt;&gt;
&lt;rule&gt;
 condition = var(id) ne &quot;chrA04&quot;
 show = no
 &lt;/rule&gt;
&lt;/rules&gt;
&lt;/plot&gt;
</code></pre>
<h2 id="plots-block以文本形式显示数据">plots block以文本形式显示数据</h2>
<p>若需要在圈图上显示基因名称，需要以文本形式展示，将以下配置信息放入到一个单独的配置文件中，命名为plots_text.conf</p>
<pre><code>&lt;plot&gt;
#表示文字
type = text
#数据文件路径
file = data/Bnagene.labels.txt
#显示在图形中的位置
r1 = 0.8r
r0 = 0.6r
#标签的字体
label_font = light
#标签大小
label_size = 12p 
#文字边缘的大小，设置较小则不同单词就可能会连在一块
#padding - text margin in angular direction
#rpadding - text margin in radial direction
rpadding = 5p
#设置是否需要在label前加一条线用来指出label的位置
show_links = no
link_dims = 0p,2p,5p,2p,2p
link_thickness = 2p
link_color = black
&lt;rules&gt;
&lt;&lt;include exclude.chrA01.rule&gt;&gt;
#设置rule，对label中含有字母a或b的特异性显示
&lt;rule&gt;
condition = var(value) =~ /a/i
label_font = bold
flow = continue
&lt;/rule&gt;
&lt;rule&gt;
condition = var(value) =~ /b/i
color = blue
&lt;/rule&gt;
&lt;/rules&gt;
&lt;/plot&gt;
</code></pre>
<h2 id="rules-block放置常用的规则配置">rules block放置常用的规则配置</h2>
<p>上述配置文件中，很多track没有在1号染色体上展示，需要设置如下规则信息，将之写入到文件exclude.chrA01.rule中</p>
<pre><code>&lt;rule&gt;
condition = on(chrA01)
show = no
&lt;/rule&gt;
</code></pre>
<h2 id="主配置文件">主配置文件</h2>
<p>在主配置文件circos.conf中，包含以上所有需要的配置文件信息，则可以会出所需要的track，此外，可以设置一些全局设置。</p>
<pre><code>#指定染色体组型的文件，该文件有7列：
#chr - ID LABEL START END COLOR
#chr - chrA01 1 0 2154635789 chr1
#chr - chrA02 2 0 2451545665 chr2
karyotype = data/karyotype/karyotype.Bna.txt
#设置长度单位，以下设置表示1M长度的序列代表为1u
chromosomes_units = 1000000
#默认设置下是将karyotype文件中所有染色体都展示出来，当然也可以根据需要仅展示指定的染色体，使用如下的参数设置：
chromosomes_display_default = no
#以下参数设置指定的chromosome用于展示到圈图中，//中是一个正则表达式，匹配的chromosomes用于展示到圈图中，其匹配的对象是karyotype文件中的第3列，也可以直接列出需要展示的chromosomes，例如：chrA01;chrA02;chrA03;chrA04;chrA05
chromosomes = /chrA0[1-5]$/
#以下设置各个ideograms的大小，其总长度为1，chrA01的长度为0.5，chrA02,chrA03,chrA04这三条染色体的总长度为0.5，并且这三条染色体的长度是均匀分布的，注意前者的单位是r，后者使用了正则表达式匹配多条染色体，其单位于是为rn
chromosomes_scale = chrA01=0.5r,/chrA0[234]/=0.5rn
#使chrA02、chrA03和chrA04在圈图上展示的方向是相反的
chromosomes_reverse = /chrA0[234]/
#设置各个ideograms的颜色
chromosomes_color= chrA01=red,chrA02=orange,chrA03=green,chrA04=blue
#默认下在ideogram block中统一shezhileideograms的位置，可以使用此参数调整指定ideograms的位置
chromosomes_radius = chrA04:0.9r
#chromosomes_radius = chrA02:0.9r;chrA03:0.8r;chrA04:0.7r
#karyotype文件最后一行指定了各个chromosomes的颜色，而使用chromosomes_color参数也能修改颜色。使用如下方法进行颜色修改则更加直观，以下方式是对颜色重新定义。chr1,chr2,chr3,chr4对应着karyotype文件最后一行的值，代表着颜色的类型。此处使用color block来对其进行重新定义。注意重新定义的时候需要加符号*
&lt;colors&gt;
chr1* = red
chr2* = orange
chr3* = green
chr4* = blue
&lt;/colors&gt;
###绘制plot图,将上述设置好的配置文件添加进来
&lt;plots&gt;
&lt;&lt;include plots_histogram.conf&gt;&gt;
&lt;&lt;include plots_heatmap.conf&gt;&gt;
&lt;&lt;include plots_text.conf&gt;&gt;
&lt;/plots&gt;
&lt;&lt;include ideogram.conf&gt;&gt;
&lt;&lt;inlcude ticks.conf&gt;&gt;
&lt;&lt;include links.conf&gt;&gt;
#########################################################
#插入必须的但不常修改的标准参数
&lt;image&gt;
&lt;&lt;include etc/image.conf&gt;&gt;
&lt;/image&gt;
&lt;&lt;include etc/color_fonts_pattern.conf&gt;&gt;
&lt;&lt;include etc/housekeeping.conf&gt;&gt;
</code></pre>
<h2 id="使用circos命令绘图">使用Circos命令绘图</h2>
<p>先安装</p>
<pre><code>##第一步先去官网下载最新版本
$ cd circos
$ tar zxf circos-tutorials-0.66.tgz
$ mv data data.bak
$ mv circos-tutorials-0.66/data/ ./
</code></pre>
<p>所有文件包括配置文件、数据文件等放置于当前目录文件夹中，运行circos绘图</p>
<pre><code>$ ./bin/circos -conf circos.conf
</code></pre>
<p>这篇文章主要来自于<a href="http://ytlogos.coding.me/2018/07/20/Circos%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/#more">Circos配置文件</a>和<a href="https://www.plob.org/article/8424.html">Circos的安装和简单使用</a>,可以说是十分详细了。当然最好的文档还是官方提供的<a href="http://circos.ca/">文档Circos</a>。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Science重磅|历时13年六倍体小麦基因组图谱终完成（详细解读）]]></title>
        <id>https://wangxf133.github.io/post/science-chong-bang-orli-shi-13-nian-liu-bei-ti-xiao-mai-ji-yin-zu-tu-pu-zhong-wan-cheng-xiang-xi-jie-du</id>
        <link href="https://wangxf133.github.io/post/science-chong-bang-orli-shi-13-nian-liu-bei-ti-xiao-mai-ji-yin-zu-tu-pu-zhong-wan-cheng-xiang-xi-jie-du">
        </link>
        <updated>2019-03-27T11:42:08.000Z</updated>
        <content type="html"><![CDATA[ <!--more-->
<p>转自 生新人发表的<a href="https://mp.weixin.qq.com/s?__biz=MzA5NjU5NjQ4MA==&amp;mid=2651160081&amp;idx=1&amp;sn=2bc94fcce9b3c939110448b99f710c3a&amp;chksm=8b5c797ebc2bf06847d02884e19b0281752a796dc8df1897c5f7cae78e0eeef25a36eb58bb1a&amp;mpshare=1&amp;scene=23&amp;srcid=0817my25QXeITXGASjxPCXwz#rd">Science重磅|历时13年六倍体小麦基因组图谱终完成（详细解读）</a></p>
<p>2018年8月17日Science杂志在线刊发题为“Shifting the limits in wheat research and breeding using a fully annotated reference genome”的研究论文，相比于2014年7月发布的草图序列，该版本序列组装指标明显提升，基因组序列由原先的10.2Gb上升到14.5Gb，Scaffold N50提升到22.8Mb。该研究论文是在国际小麦基因组测序联盟（International Wheat Genome Sequencing Consortium，IWGSC）协作下完成的，西北农林科技大学旱区作物逆境生物学国家重点实验室的宋卫宁教授团队作为中国唯一参与并承担实质性研究工作的团队，完成了其中7DL染色体物理图谱构建及序列图谱破译工作。</p>
<h2 id="1-国际小麦基因组测序联盟">1. 国际小麦基因组测序联盟</h2>
<p>IWGSC在68个国家有2400个成员，是一个由小麦种植者、植物科学家、公共和私人育种家在2005年成立的一个国际合作联盟。IWGSC的愿景是获得面包小麦的高质量基因组序列，它是加速品种改良发展的基础。</p>
<p>为了实现此愿景，联盟采用来自捷克的Jaroslav Doležel教授高精湛的流式细胞仪分离技术，将普通小麦中国春（Chinese Spring）的21条染色体进行了分离。除了3B染色体之外，其余染色体均分为长臂（L）和短臂（S），并构建了相应的BAC文库，后续的物理图谱构建和BAC测序则由IWGSC的各成员国分担，我们国家西北农林科技大学主要是负责7DL物理图谱构建与BAC测序。</p>
<p><img src="https://s1.ax2x.com/2018/08/17/59W4RB.png" alt="59W4RB.png"></p>
<h2 id="2-iwgsc的四个关键里程碑">2. IWGSC的四个关键里程碑</h2>
<p>面包小麦是世界上种植面积最大的小麦栽培作物，覆盖世界小麦种植区域的95%以上。获取它的基因组序列对于基因的改良是至关重要的。IWGSC采用分步走的策略，以确保小麦育种和小麦产业能够与小麦基因组基础研究并行并立即获得显著产出。IWGSC在进行小麦基因组组装过程中四个里程碑：</p>
<ol>
<li>利用21个面包小麦染色体的基因组survey序列,实现对小麦基因的每条染色体的定位；</li>
<li>开发物理地图，为测序提供资源；</li>
<li>建立每个染色体一个参考序列；</li>
<li>通过整合基于染色体的基因组资源与IWGSC组装的全基因组序列，获得金标准的小麦参考基因组序列。</li>
</ol>
<p>第一个里程碑是2014年7月发表在《科学》杂志上的以染色体为基础的基因组草图序列。所有染色体的物理图谱（里程碑2）在2015年底完成。在2016年1月底，全基因组鸟枪法获得每个染色体（IWGSC WGAV0.4-里程碑3）参考序列，这是在2016年6月前已经公布的。通过整合基于染色体图谱和序列资源与全基因组组装（IWGSC RefSeq v1.0）获得一个高质量的被注释的参考基因组序列，已在2017年1月公布，但限制使用。在2018年7月，所有IWGSC参考序列资源被公开提供，任何科研工作者均可以使用。</p>
<p><img src="https://s1.ax2x.com/2018/08/17/59WvS3.png" alt="59WvS3.png"></p>
<p>小麦相关数据主要位于URGI网站上：https://wheat-urgi.versailles.inra.fr/</p>
<p><img src="https://s1.ax2x.com/2018/08/17/59Wa4G.png" alt="59Wa4G.png"></p>
<h2 id="3-基因组测序材料-中国春品种">3. 基因组测序材料-中国春品种</h2>
<p>普通小麦是由祖先野生的一粒小麦(乌拉尔图小麦，含AA基因组)与拟斯卑尔托山羊草(Aegilops speltoides，含BB基因组)杂交形成四倍体野生二粒小麦(Triticum turgidum，含有AABB基因组)。在大约8000以前，亚洲西部肥沃新月地带，野生粗山羊草双二倍体(2n = 14; DD)和四倍体小麦 (2n = 4x = 28; AABB)自发杂交进而产生了六倍体小麦(T. aestivum; 2n = 6x = 42; AABBDD)。六倍体小麦的各祖先种均已完成测序，相关文献见下文。</p>
<p><img src="https://s1.ax2x.com/2018/08/17/59WC3E.png" alt="59WC3E.png"></p>
<p>此次六倍体小麦测序品种选择了中国春，顾名思义，其来源肯定是中国呀。那么为什么全世界会选择它作为测序材料呢？</p>
<p>因为它有非常重要的遗传价值。中国春是种植在四川成都平原的一个地方品种，最早是通过传教士传入西方的，起初被称作为Chinese White，后来被改为Chinese Spring，即中国春。早在20世纪初，学者就发现中国春与黑麦非常容易杂交，并且利用中国春材料可以制造出单体、单端体、双端体、缺体、三体、缺体一四体等一系列非整倍体材料，推动了小麦遗传学研究领域的发展。后来研究者们又以人工的方式使中国春突变得到能够诱导部分同源染色体配对的基因突变体phlb，并被广泛地应用于远缘杂交进行小麦外源基因转移。因此中国春系列材料成了众所周知的小麦遗传学和外源基因转移等研究的工具和对照材料（摘自：刘登才, 郑有良, &amp; 兰秀锦. (2003). 小麦中国春遗传背景的育种改良. 中国农业科学, 36(11), 1383-1389.），而选择它作为基因组测序材料，也是必然的。</p>
<h2 id="4-文章解读">4. 文章解读</h2>
<p>研究背景</p>
<p>小麦是作为世界各地最为广泛种植的谷物之一，提供了19%人类能量消耗，相较于其他作物，小麦是唯一一个尚未完成全基因组测序的物种。究其原因，小麦基因组体量庞大，是人类基因组的5倍，是水稻基因组的40倍，作为典型的异源多倍体基因组，小麦基因组由三套相似而又不同的基因组整合在一起，最终形成一个极为复杂的六倍体基因组，同时其重复序列高，给研究工作带来巨大障碍。</p>
<p>研究结果<br>
<img src="https://s1.ax2x.com/2018/08/17/59WeRa.png" alt="59WeRa.png"></p>
<ol>
<li>研究以小麦模式品系CS（Chinese Spring）“中国春”为材料，整合现有的各种数据资源，包括遗传图谱，以及单染色体BAC序列信息等。重新修正基因组大小，推测为为15.4~15.8Gb；利用DeNovoMAGIC2(来自NRgene公司)软件进行短片段组装，然后利用Hi-C技术和高密度遗传图谱（POPSEQ）进行染色体挂载。错误的组装的序列利用CSS（chromosome survey sequence）、Hi-C和POPSEQ进行识别和断开纠正。另外还测了大量的8-16fold的BAC，这些对于连接scaffold组成超大scaffold起了重要作用。 最终拼装获得了1,601条super-scaffold，大小为~14.5 GB， scaffold N50为22.8 Mb 的小麦基因组序列。研究中对A、B及D三套异源染色体组进行了严格区分，其中97%的序列被定位到ABD亚基因组上，只有大约481Mb的序列没有挂载到染色体。</li>
</ol>
<p><img src="https://s1.ax2x.com/2018/08/17/59W1PS.png" alt="59W1PS.png"></p>
<p>文章对获得的基因组进行了较为严格的评估。</p>
<blockquote>
<p>1.遗传图评估，利用A、B、D的遗传图和染色体进行共线性评估，其中平均相关系数在0.98。</p>
</blockquote>
<blockquote>
<p>2.利用了7832个genetic position和4745个GBS数据得到的遗传标记跟染色体上位置的对应分析，其中相关系数在0.986和0.987。</p>
</blockquote>
<blockquote>
<p>3.1.24百万个neighbor insertion site（ISBPs）其中97%在BAC和基因组直接存在共线性（误差2Kb内）</p>
</blockquote>
<blockquote>
<p>4.从CSS或者ISBP中获的编码或者非编码的基因序列，在基因组中出现的比例分别为99%和97%。</p>
</blockquote>
<p>可以说这是迄今为止完成度最高且质量值最好的小麦基因组序列。</p>
<ol start="2">
<li>
<p>研究整合了21条小麦染色体参考序列、物理图谱及多种公共资源数据，获得了超过470万个分子标记，该数据将极大的推动后续的分子育种水平上的应用。</p>
</li>
<li>
<p>利用Hi-C染色质构象捕获技术及CSS数据，首次对小麦着丝粒区间大小进行了估算，大小估值为4.9MB。整个基因组重复序列含量为85%，三套亚基因组之间无明显差异。</p>
</li>
<li>
<p>在完整拼装的染色体序列基础上，注释并获得了共107,891个小麦基因，较此前公开的小麦基因组注释信息，这是最为完整和全面的小麦基因组注释版本。注释流程部分分别采用了TriAnnot和MIPS/PGSB两套流程，然后利用Mikado进行整合。其中得到了107,891个高可信度的基因，此外还有161,537个低可信度的基因。BUSCO评估有3个complete copy的占比达到了90%，至少一个complete copy的占到了99%，证明基因组与基因预测的完整性很高。</p>
</li>
</ol>
<p><img src="https://s1.ax2x.com/2018/08/17/59WASh.png" alt="59WASh.png"></p>
<p>此外通过探究了同源基因的亚基因组的分布模式及动态演化规律，结果发现三套染色体组之间的同源基因比例基本持平，鉴于D基因组进入小麦的时间较为落后，其同源基因含量水平相对较高，且假基因数量较少。同时小麦中未发现因植物多倍化过程中基因的缺失将导致基因组间的分歧显现，小麦基因组中的基因丢失及基因的位移是与其杂交事件发生的先后顺序的时间跨度成正比的。</p>
<p><img src="https://s1.ax2x.com/2018/08/17/59W6TH.png" alt="59W6TH.png"></p>
<ol start="5">
<li>该研究整合了850个转录组数据，探究了小麦不同生长发育时期及生态环境下的表达谱模式，通过共表达网络模块分析及GO term富集分析，揭示了一系列开花时间相关的上下游基因。</li>
</ol>
<p><img src="https://s1.ax2x.com/2018/08/17/59WI4N.png" alt="59WI4N.png"></p>
<ol start="6">
<li>
<p>研究对小麦特有的扩张的基因家族进行了功能富集分析，结果发现扩张的基因显著富集在籽粒产量，生物非生物胁迫逆境胁迫相应，花粉育性等类组之下，这与人工育种中倾向与选择适应不同气候环境并具高产量的小麦品种的倾向相关联。</p>
</li>
<li>
<p>研究对响应非生物胁迫及抗虫性的SSt1 QTL基因进行剖析，以此为例探究了该小麦基因组在实际生产过程中的应用价值。</p>
</li>
</ol>
<p>小麦染色体基因组测序和注释的全面完成，可以大大加快研究小麦育种研究的步伐，有利于培育高产、抗旱、抗盐、抗病虫的小麦新品种，更好全球气候变化及人口膨胀带来的食品短缺的挑战，为小麦基因组改良工作奠定了基础。</p>
<h2 id="5-数据资源">5. 数据资源</h2>
<p>IWGSC RefSeq v1.0参考基因组、注释信息及其余该文章相关数据均可从https://wheat-urgi.versailles.inra.fr/Seq-Repository下载获得，测序原始数据存于SRA下登录号为SRP114784，全染色体/染色体臂BAC文库数据信息位于https://cnrgv.toulouse.inra.fr/en/Library/Wheat。</p>
<h2 id="6-小麦基因组主要已发表文献">6. 小麦基因组主要已发表文献</h2>
<p>小编总结目前二倍体、四倍体和六倍体小麦的组装情况</p>
<p><img src="https://s1.ax2x.com/2018/08/17/59W7SR.png" alt="59W7SR.png"></p>
<ol>
<li>
<p>Brenchley, R., Spannagl, M., Pfeifer, M., Barker, G. L., D'Amore, R., &amp; Allen, A. M., et al. (2012). Analysis of the bread wheat genome using whole-genome shotgun sequencing. Nature, 491(7426), 705-710.</p>
</li>
<li>
<p>Jia, J., Zhao, S., Kong, X., Li, Y., Zhao, G., He, W., ... &amp; Jing, R. (2013). Aegilops tauschii draft genome sequence reveals a gene repertoire for wheat adaptation. Nature, 496(7443), 91.</p>
</li>
<li>
<p>Ling, H. Q., Zhao, S., Liu, D., Wang, J., Sun, H., Zhang, C., ... &amp; Gao, C. (2013). Draft genome of the wheat A-genome progenitor Triticum urartu. Nature, 496(7443), 87.</p>
</li>
<li>
<p>International Wheat Genome Sequencing Consortium. (2014). A chromosome-based draft sequence of the hexaploid bread wheat (Triticum aestivum) genome. Science, 345(6194), 1251788.</p>
</li>
<li>
<p>Choulet, F., Alberti, A., Theil, S., Glover, N., Barbe, V., &amp; Daron, J., et al. (2014). Structural and functional partitioning of bread wheat chromosome 3b. Science, 345(6194), 1249721.</p>
</li>
<li>
<p>Chapman, J. A., Mascher, M., Buluç, A., Barry, K., Georganas, E., Session, A., ... &amp; Schmutz, J. (2015). A whole-genome shotgun approach for assembling and anchoring the hexaploid bread wheat genome. Genome biology, 16(1), 26.</p>
</li>
<li>
<p>Zimin, A. V., Puiu, D., Hall, R., Kingan, S., Clavijo, B. J., &amp; Salzberg, S. L. (2017). The first near-complete assembly of the hexaploid bread wheat genome, Triticum aestivum. Gigascience.</p>
</li>
<li>
<p>Clavijo, B. J., Venturini, L., Schudoma, C., Accinelli, G. G., Kaithakottil, G., Wright, J., ... &amp; Lipscombe, J. (2017). An improved assembly and annotation of the allohexaploid wheat genome identifies complete families of agronomic genes and provides genomic evidence for chromosomal translocations. Genome research.</p>
</li>
<li>
<p>Zimin, A. V., Puiu, D., Luo, M. C., Zhu, T., Koren, S., Marçais, G., ... &amp; Salzberg, S. L. (2017). Hybrid assembly of the large and highly repetitive genome of Aegilops tauschii, a progenitor of bread wheat, with the MaSuRCA mega-reads algorithm. Genome research.</p>
</li>
<li>
<p>Avni, R., Nave, M., Barad, O., Baruch, K., Twardziok, S. O., Gundlach, H., ... &amp; Jordan, K. W. (2017). Wild emmer genome architecture and diversity elucidate wheat evolution and domestication. Science, 357(6346), 93-97.</p>
</li>
<li>
<p>Luo, M. C., Gu, Y. Q., Puiu, D., Wang, H., Twardziok, S. O., Deal, K. R., ... &amp; McGuire, P. E. (2017). Genome sequence of the progenitor of the wheat D genome Aegilops tauschii. Nature, 551(7681).</p>
</li>
<li>
<p>Zhao, G., Zou, C., Li, K., Wang, K., Li, T., Gao, L., ... &amp; Jiang, W. (2017). The Aegilops tauschii genome reveals multiple impacts of transposons. Nature plants, 3(12), 946.</p>
</li>
<li>
<p>Ling, H. Q., Ma, B., Shi, X., Liu, H., Dong, L., Sun, H., ... &amp; Yu, Y. (2018). Genome sequence of the progenitor of wheat A subgenome Triticum urartu. Nature, 557(7705), 424.</p>
</li>
</ol>
<hr>
<p><a href="http://note.youdao.com/noteshare?id=260623028fc72ab9492f5289cfcd4f12&amp;sub=ABC82BFDA35F40DAA3D7C004438A404A">以前自己下载的路径</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[shell语言脚本构建5-呈现数据与结果输出]]></title>
        <id>https://wangxf133.github.io/post/shell-yu-yan-jiao-ben-gou-jian-5-cheng-xian-shu-ju-yu-jie-guo-shu-chu</id>
        <link href="https://wangxf133.github.io/post/shell-yu-yan-jiao-ben-gou-jian-5-cheng-xian-shu-ju-yu-jie-guo-shu-chu">
        </link>
        <updated>2019-03-27T11:41:10.000Z</updated>
        <content type="html"><![CDATA[<!--more-->
<p>到目前为止，本系列出现的脚本都是通过将数据打印在屏幕上或将数据重定向到文件中来显示信息。本文将会展开这个主题，演示如何将脚本的输出重定向到Linux系统的不同位置。</p>
<h2 id="1-理解输入和输出">1. 理解输入和输出</h2>
<p>至此你已经知道了两种显示脚本输出的方法：</p>
<ul>
<li>在显示器屏幕上显示输出</li>
<li>将输出重定向到文件中</li>
</ul>
<p>这两种方法要么将数据输出全部显示，要么什么都不显示。但有时将一部分数据在显示器上显示，另一部分数据保存到文件中也是不错的。对此，了解Linux如何处理输入输出能够帮助你就能将脚本输出放到正确位置。</p>
<p>下面几节会介绍如何用标准的Linux输入和输出系统来将脚本输出导向特定位置。</p>
<h4 id="11-标准文件描述符">1.1 标准文件描述符</h4>
<p>Linux系统将每个对象当作文件处理。这包括输入和输出进程。Linux用文件描述符（file descriptor）来标识每个文件对象。文件描述符是一个非负整数，可以唯一标识会话中打开的文件。每个进程一次最多可以有九个文件描述符。出于特殊目的，bash shell保留了前三个文件描述符（0、1和2），见表15-1。</p>
<p><img src="https://s1.ax2x.com/2018/08/10/55Cqo2.png" alt="55Cqo2.png"></p>
<p>这三个特殊文件描述符会处理脚本的输入和输出。shell用它们将shell默认的输入和输出导向到相应的位置。下面几节将会进一步介绍这些标准文件描述符。</p>
<ol>
<li><strong>STDIN</strong></li>
</ol>
<p>STDIN文件描述符代表shell的标准输入。对终端界面来说，标准输入是键盘。shell从STDIN文件描述符对应的键盘获得输入，在用户输入时处理每个字符。</p>
<p>在使用输入重定向符号（&lt;）时，Linux会用重定向指定的文件来替换标准输入文件描述符。它会读取文件并提取数据，就如同它是键盘上键入的。</p>
<p>许多bash命令能接受STDIN的输入，尤其是没有在命令行上指定文件的话。下面是个用cat命令处理STDIN输入的数据的例子。</p>
<pre><code class="language-SH">$ cat 
this is a test 
this is a test 
this is a second test. 
this is a second test. 
</code></pre>
<p>当在命令行上只输入cat命令时，它会从STDIN接受输入。输入一行，cat命令就会显示出一行。</p>
<p>但你也可以通过STDIN重定向符号强制cat命令接受来自另一个非STDIN文件的输入。</p>
<pre><code class="language-sh">$ cat &lt; testfile 
This is the first line. 
This is the second line. 
This is the third line. 
$ 
</code></pre>
<p>现在cat命令会用testfile文件中的行作为输入。你可以使用这种技术将数据输入到任何能从STDIN接受数据的shell命令中。</p>
<ol start="2">
<li><strong>STDOUT</strong></li>
</ol>
<p>STDOUT文件描述符代表shell的标准输出。在终端界面上，标准输出就是终端显示器。shell的所有输出（包括shell中运行的程序和脚本）会被定向到标准输出中，也就是显示器。</p>
<p>默认情况下，大多数bash命令会将输出导向STDOUT文件描述符。</p>
<pre><code class="language-sh">$ ls -l &gt; test2 
$ cat test2 
total 20 
-rw-rw-r-- 1 rich rich 53 2014-10-16 11:30 test 
-rw-rw-r-- 1 rich rich  0 2014-10-16 11:32 test2 
-rw-rw-r-- 1 rich rich 73 2014-10-16 11:23 testfile 
$ 
</code></pre>
<p>通过输出重定向符号，通常会显示到显示器的所有输出会被shell重定向到指定的重定向文件。</p>
<p>你也可以将数据追加到某个文件。这可以用&gt;&gt;符号来完成。</p>
<pre><code class="language-sh">$ who &gt;&gt; test2 
$ cat test2 
total 20 
-rw-rw-r-- 1 rich rich 53 2014-10-16 11:30 test 
-rw-rw-r-- 1 rich rich  0 2014-10-16 11:32 test2 
-rw-rw-r-- 1 rich rich 73 2014-10-16 11:23 testfile 
rich     pts/0        2014-10-17 15:34 (192.168.1.2) 
$ 
</code></pre>
<p>who命令生成的输出会被追加到test2文件中已有数据的后面。</p>
<p>但是，如果你对脚本使用了标准输出重定向，你会遇到一个问题。下面的例子说明了可能会出现什么情况。</p>
<pre><code class="language-sh">$ ls -al badfile &gt; test3 
ls: cannot access badfile: No such file or directory 
$ cat test3 
$ 
</code></pre>
<p>当命令生成错误消息时，shell并未将错误消息重定向到输出重定向文件。shell创建了输出重定向文件，但错误消息却显示在了显示器屏幕上。注意，在显示test3文件的内容时并没有任何错误。test3文件创建成功了，只是里面是空的。</p>
<p>shell对于错误消息的处理是跟普通输出分开的。如果你创建了在后台模式下运行的shell脚本，通常你必须依赖发送到日志文件的输出消息。用这种方法的话，如果出现了错误信息，这些信息是不会出现在日志文件中的。你需要换种方法来处理。</p>
<ol start="3">
<li><strong>STDERR</strong></li>
</ol>
<p>shell通过特殊的STDERR文件描述符来处理错误消息。STDERR文件描述符代表shell的标准错误输出。shell或shell中运行的程序和脚本出错时生成的错误消息都会发送到这个位置。</p>
<p>默认情况下，STDERR文件描述符会和STDOUT文件描述符指向同样的地方（尽管分配给它们的文件描述符值不同）。也就是说，默认情况下，错误消息也会输出到显示器输出中。</p>
<p>但从上面的例子可以看出，STDERR并不会随着STDOUT的重定向而发生改变。使用脚本时，你常常会想改变这种行为，尤其是当你希望将错误消息保存到日志文件中的时候。</p>
<h4 id="12-重定向错误">1.2 重定向错误</h4>
<p>你已经知道如何用重定向符号来重定向STDOUT数据。重定向STDERR数据也没太大差别，只要在使用重定向符号时定义STDERR文件描述符就可以了。有几种办法实现方法。</p>
<ol>
<li>只重定向错误</li>
</ol>
<p>你在表15-1中已经看到，STDERR文件描述符被设成2。可以选择只重定向错误消息，<strong>将该文件描述符值放在重定向符号前</strong>。该值必须紧紧地放在重定向符号前，否则不会工作。</p>
<pre><code class="language-sh">$ ls -al badfile 2&gt; test4 
$ cat test4 
ls: cannot access badfile: No such file or directory 
$
</code></pre>
<p>现在运行该命令，错误消息不会出现在屏幕上了。该命令生成的任何错误消息都会保存在输出文件中。用这种方法，shell会只重定向错误消息，而非普通数据。这里是另一个将STDOUT和STDERR消息混杂在同一输出中的例子。</p>
<pre><code class="language-sh">$ ls -al test badtest test2 2&gt; test5 
-rw-rw-r-- 1 rich rich 158 2014-10-16 11:32 test2 
$ cat test5 
ls: cannot access test: No such file or directory 
ls: cannot access badtest: No such file or directory 
$
</code></pre>
<p>ls命令的正常STDOUT输出仍然会发送到默认的STDOUT文件描述符，也就是显示器。由于该命令将文件描述符2的输出（STDERR）重定向到了一个输出文件，shell会将生成的所有错误消息直接发送到指定的重定向文件中。</p>
<ol start="2">
<li>重定向错误和数据</li>
</ol>
<p>如果想重定向错误和正常输出，必须用两个重定向符号。需要在符号前面放上待重定向数据所对应的文件描述符，然后指向用于保存数据的输出文件。</p>
<pre><code class="language-sh">$ ls -al test test2 test3 badtest 2&gt; test6 1&gt; test7 
$ cat test6 
ls: cannot access test: No such file or directory 
ls: cannot access badtest: No such file or directory 
$ cat test7 
-rw-rw-r-- 1 rich rich 158 2014-10-16 11:32 test2 
-rw-rw-r-- 1 rich rich   0 2014-10-16 11:33 test3 
$ 
</code></pre>
<p>shell利用1&gt;符号将ls命令的正常输出重定向到了test7文件，而这些输出本该是进入STDOUT的。所有本该输出到STDERR的错误消息通过2&gt;符号被重定向到了test6文件。</p>
<p>可以用这种方法将脚本的正常输出和脚本生成的错误消息分离开来。这样就可以轻松地识别出错误信息，再不用在成千上万行正常输出数据中翻腾了。</p>
<p>另外，如果愿意，也可以将STDERR和STDOUT的输出重定向到同一个输出文件。为此bash shell提供了特殊的重定向符号&amp;&gt;。</p>
<pre><code class="language-sh">$ ls -al test test2 test3 badtest &amp;&gt; test7 
$ cat test7 
ls: cannot access test: No such file or directory 
ls: cannot access badtest: No such file or directory 
-rw-rw-r-- 1 rich rich 158 2014-10-16 11:32 test2 
-rw-rw-r-- 1 rich rich   0 2014-10-16 11:33 test3 
$ 
</code></pre>
<p>当使用&amp;&gt;符时，命令生成的所有输出都会发送到同一位置，包括数据和错误。你会注意到其中一条错误消息出现的位置和预想中的不一样。badtest文件（列出的最后一个文件）的这条错误消息出现在输出文件中的第二行。为了避免错误信息散落在输出文件中，相较于标准输出，bash shell自动赋予了错误消息更高的优先级。这样你能够集中浏览错误信息了。</p>
<h2 id="2-在脚本中重定向输出">2. 在脚本中重定向输出</h2>
<p>可以在脚本中用STDOUT和STDERR文件描述符以在多个位置生成输出，只要简单地重定向相应的文件描述符就行了。有两种方法来在脚本中重定向输出：</p>
<ul>
<li>临时重定向行输出</li>
<li>永久重定向脚本中的所有命令</li>
</ul>
<h4 id="21-临时重定向">2.1 临时重定向</h4>
<p>如果有意在脚本中生成错误消息，可以将单独的一行输出重定向到STDERR。你所需要做的是使用输出重定向符来将输出信息重定向到STDERR文件描述符。在重定向到文件描述符时，你必须在文件描述符数字之前加一个&amp;：</p>
<pre><code class="language-sh">echo &quot;This is an error message&quot; &gt;&amp;2 
</code></pre>
<p>这行会在脚本的STDERR文件描述符所指向的位置显示文本，而不是通常的STDOUT。下面这个例子就利用了这项功能。</p>
<pre><code class="language-sh">$ cat test8 
#!/bin/bash 
# testing STDERR messages 
 
echo &quot;This is an error&quot; &gt;&amp;2 
echo &quot;This is normal output&quot; 
$ 
</code></pre>
<p>如果像平常一样运行这个脚本，你可能看不出什么区别。</p>
<pre><code class="language-sh">$ ./test8 
This is an error 
This is normal output 
$ 
</code></pre>
<p>记住，默认情况下，Linux会将STDERR导向STDOUT。但是，如果你在运行脚本时重定向了STDERR，脚本中所有导向STDERR的文本都会被重定向。</p>
<pre><code class="language-sh">$ ./test8 2&gt; test9 
This is normal output 
$ cat test9 
This is an error 
$ 
</code></pre>
<p>通过STDOUT显示的文本显示在了屏幕上，而发送给STDERR的echo语句的文本则被重定向到了输出文件。</p>
<p>这个方法非常适合在脚本中生成错误消息。如果有人用了你的脚本，他们可以像上面的例子中那样轻松地通过STDERR文件描述符重定向错误消息。</p>
<h4 id="22-永久重定向">2.2 永久重定向</h4>
<p>如果脚本中有大量数据需要重定向，那重定向每个echo语句就会很烦琐。取而代之，你可以用<strong>exec命令</strong>告诉shell在脚本执行期间重定向某个特定文件描述符。</p>
<pre><code class="language-sh">$ cat test10 
#!/bin/bash 
# redirecting all output to a file 
exec 1&gt;testout 
 
echo &quot;This is a test of redirecting all output&quot; 
echo &quot;from a script to another file.&quot; 
echo &quot;without having to redirect every individual line&quot; 


$ ./test10 
$ cat testout 
This is a test of redirecting all output 
from a script to another file. 
without having to redirect every individual line 
$ 
</code></pre>
<p>exec命令会启动一个新shell并将STDOUT文件描述符重定向到文件。脚本中发给STDOUT的所有输出会被重定向到文件。</p>
<p>可以在脚本执行过程中重定向STDOUT。</p>
<pre><code class="language-sh">$ cat test11 
#!/bin/bash 
# redirecting output to different locations 
 
exec 2&gt;testerror 
 
echo &quot;This is the start of the script&quot; 
echo &quot;now redirecting all output to another location&quot; 
 
exec 1&gt;testout 
 
echo &quot;This output should go to the testout file&quot; 
echo &quot;but this should go to the testerror file&quot; &gt;&amp;2 
$ 
$ ./test11 
This is the start of the script 
now redirecting all output to another location 
$ cat testout 
This output should go to the testout file 
$ cat testerror 
but this should go to the testerror file 
$ 
</code></pre>
<p>这个脚本用exec命令来将发给STDERR的输出重定向到文件testerror。接下来，脚本用echo语句向STDOUT显示了几行文本。随后再次使用exec命令来将STDOUT重定向到testout文件。注意，尽管STDOUT被重定向了，但你仍然可以将echo语句的输出发给STDERR，在本例中还是重定向到testerror文件。</p>
<p>当你只想将脚本的部分输出重定向到其他位置时（如错误日志），这个特性用起来非常方便。不过这样做的话，会碰到一个问题。</p>
<p>一旦重定向了STDOUT或STDERR，就很难再将它们重定向回原来的位置。如果你需要在重定向中来回切换的话，有个办法可以用。后节将会讨论该方法以及如何在脚本中使用。</p>
<h2 id="3-在脚本中重定向输入">3. 在脚本中重定向输入</h2>
<p>你可以使用与脚本中重定向STDOUT和STDERR相同的方法来将STDIN从键盘重定向到其他位置。exec命令允许你将STDIN重定向到Linux系统上的文件中：</p>
<p>这个命令会告诉shell它应该从文件testfile中获得输入，而不是STDIN。这个重定向只要在脚本需要输入时就会作用。下面是该用法的实例。</p>
<pre><code class="language-sh">$ cat test12 
#!/bin/bash 
# redirecting file input 
 
exec 0&lt; testfile 
count=1 
 
while read line 
do 
   echo &quot;Line #$count: $line&quot; 
   count=$[ $count + 1 ] 
done 
$ ./test12 
Line #1: This is the first line. 
Line #2: This is the second line. 
Line #3: This is the third line. 
$ 
</code></pre>
<p>使用read命令读取用户在键盘上输入的数据。将STDIN重定向到文件后，当read命令试图从STDIN读入数据时，它会到文件去取数据，而不是键盘。</p>
<p>这是在脚本中从待处理的文件中读取数据的绝妙办法。</p>
<h2 id="4-创建自己的重定向">4. 创建自己的重定向</h2>
<p>在脚本中重定向输入和输出时，并不局限于这3个默认的文件描述符。我曾提到过，在shell中最多可以有9个打开的文件描述符。其他6个从3~8的文件描述符均可用作输入或输出重定向。你可以将这些文件描述符中的任意一个分配给文件，然后在脚本中使用它们。本节将介绍如何在脚本中使用其他文件描述符。</p>
<h4 id="41-创建输出文件描述符">4.1 创建输出文件描述符</h4>
<p>可以用exec命令来给输出分配文件描述符。和标准的文件描述符一样，一旦将另一个文件描述符分配给一个文件，这个重定向就会一直有效，直到你重新分配。这里有个在脚本中使用其他文件描述符的简单例子。</p>
<pre><code class="language-sh">$ cat test13 
#!/bin/bash 
# using an alternative file descriptor 
 
exec 3&gt;test13out 
 
echo &quot;This should display on the monitor&quot; 
echo &quot;and this should be stored in the file&quot; &gt;&amp;3 
echo &quot;Then this should be back on the monitor&quot; 
$ ./test13 
This should display on the monitor 
Then this should be back on the monitor 
$ cat test13out 
and this should be stored in the file 
$
</code></pre>
<p>这个脚本用exec命令将文件描述符3重定向到另一个文件。当脚本执行echo语句时，输出内容会像预想中那样显示在STDOUT上。但你重定向到文件描述符3的那行echo语句的输出却进入了另一个文件。这样你就可以在显示器上保持正常的输出，而将特定信息重定向到文件中（比如日志文件）。</p>
<p>也可以不用创建新文件，而是使用exec命令来将输出追加到现有文件中。</p>
<pre><code>exec 3&gt;&gt;test13out 
</code></pre>
<p>现在输出会被追加到test13out文件，而不是创建一个新文件。</p>
<h4 id="42-重定向文件描述符-没看懂">4.2 重定向文件描述符 (没看懂....)</h4>
<p>现在介绍怎么恢复已重定向的文件描述符。你可以分配另外一个文件描述符给标准文件描述符，反之亦然。这意味着你可以将STDOUT的原来位置重定向到另一个文件描述符，然后再利用该文件描述符重定向回STDOUT。听起来可能有点复杂，但实际上相当直接。这个简单的例子能帮你理清楚。</p>
<pre><code class="language-sh">$ cat test14 
#!/bin/bash 
# storing STDOUT, then coming back to it 
 
exec 3&gt;&amp;1 
exec 1&gt;test14out 
 
echo &quot;This should store in the output file&quot; 
echo &quot;along with this line.&quot; 

exec 1&gt;&amp;3 
 
echo &quot;Now things should be back to normal&quot; 
$ 
$ ./test14 
Now things should be back to normal 
$ cat test14out 
This should store in the output file 
along with this line. 
$ 
</code></pre>
<p>这个例子有点叫人抓狂，来一段一段地看。首先，脚本将文件描述符3重定向到文件描述符1的当前位置，也就是STDOUT。这意味着任何发送给文件描述符3的输出都将出现在显示器上。</p>
<p>第二个exec命令将STDOUT重定向到文件，shell现在会将发送给STDOUT的输出直接重定向到输出文件中。但是，文件描述符3仍然指向STDOUT原来的位置，也就是显示器。如果此时将输出数据发送给文件描述符3，它仍然会出现在显示器上，尽管STDOUT已经被重定向了。</p>
<p>在向STDOUT（现在指向一个文件）发送一些输出之后，脚本将STDOUT重定向到文件描述符3的当前位置（现在仍然是显示器）。这意味着现在STDOUT又指向了它原来的位置：显示器。</p>
<p>这个方法可能有点叫人困惑，但这是一种在脚本中临时重定向输出，然后恢复默认输出设置的常用方法。</p>
<h4 id="43-创建输入文件描述符-没看懂">4.3 创建输入文件描述符 (没看懂....)</h4>
<p>可以用和重定向输出文件描述符同样的办法重定向输入文件描述符。在重定向到文件之前，先将STDIN文件描述符保存到另外一个文件描述符，然后在读取完文件之后再将STDIN恢复到它原来的位置。</p>
<pre><code class="language-sh">$ cat test15 
#!/bin/bash 
# redirecting input file descriptors 
 
exec 6&lt;&amp;0 
 
exec 0&lt; testfile 
 
count=1 
while read line 
do 
   echo &quot;Line #$count: $line&quot; 
   count=$[ $count + 1 ] 
done 
exec 0&lt;&amp;6 
read -p &quot;Are you done now? &quot; answer 
case $answer in 
Y|y) echo &quot;Goodbye&quot;;; 
N|n) echo &quot;Sorry, this is the end.&quot;;; 
esac 
$ ./test15 
Line #1: This is the first line. 
Line #2: This is the second line. 
Line #3: This is the third line. 
Are you done now? y 
Goodbye 
$ 
</code></pre>
<p>在这个例子中，文件描述符6用来保存STDIN的位置。然后脚本将STDIN重定向到一个文件。read命令的所有输入都来自重定向后的STDIN（也就是输入文件）。</p>
<p>在读取了所有行之后，脚本会将STDIN重定向到文件描述符6，从而将STDIN恢复到原先的位置。该脚本用了另外一个read命令来测试STDIN是否恢复正常了。这次它会等待键盘的输入。</p>
<h4 id="44-创建读写文件描述符-没看懂">4.4 创建读写文件描述符 (没看懂....)</h4>
<p>尽管看起来可能会很奇怪，但是你也可以打开单个文件描述符来作为输入和输出。可以用同一个文件描述符对同一个文件进行读写。</p>
<p>不过用这种方法时，你要特别小心。由于你是对同一个文件进行数据读写，shell会维护一个内部指针，指明在文件中的当前位置。任何读或写都会从文件指针上次的位置开始。如果不够小心，它会产生一些令人瞠目的结果。看看下面这个例子。</p>
<pre><code class="language-sh">$ cat test16 
#!/bin/bash 
# testing input/output file descriptor 
 
exec 3&lt;&gt; testfile 
read line &lt;&amp;3 
echo &quot;Read: $line&quot; 
echo &quot;This is a test line&quot; &gt;&amp;3 
$ cat testfile 
This is the first line. 
This is the second line. 
This is the third line. 
$ ./test16 
Read: This is the first line. 
$ cat testfile 
This is the first line. 
This is a test line 
ine. 
This is the third line. 
$ 
</code></pre>
<p>这个例子用了exec命令将文件描述符3分配给文件testfile以进行文件读写。接下来，它通过分配好的文件描述符，使用read命令读取文件中的第一行，然后将这一行显示在STDOUT上。最后，它用echo语句将一行数据写入由同一个文件描述符打开的文件中。</p>
<p>在运行脚本时，一开始还算正常。输出内容表明脚本读取了testfile文件中的第一行。但如果你在脚本运行完毕后，查看testfile文件内容的话，你会发现写入文件中的数据覆盖了已有的数据。</p>
<p>当脚本向文件中写入数据时，它会从文件指针所处的位置开始。read命令读取了第一行数据，所以它使得文件指针指向了第二行数据的第一个字符。在echo语句将数据输出到文件时，它会将数据放在文件指针的当前位置，覆盖了该位置的已有数据。</p>
<h4 id="45-关闭文件描述符">4.5 关闭文件描述符</h4>
<p>如果你创建了新的输入或输出文件描述符，shell会在脚本退出时自动关闭它们。然而在有些情况下，你需要在脚本结束前手动关闭文件描述符。</p>
<p>要关闭文件描述符，将它重定向到特殊符号&amp;-。脚本中看起来如下：</p>
<pre><code class="language-sh">exec 3&gt;&amp;- 
</code></pre>
<p>该语句会关闭文件描述符3，不再在脚本中使用它。这里有个例子来说明当你尝试使用已关闭的文件描述符时会怎样。</p>
<pre><code class="language-sh">$ cat badtest 
#!/bin/bash 
# testing closing file descriptors 
 
exec 3&gt; test17file 
 
echo &quot;This is a test line of data&quot; &gt;&amp;3 
 
exec 3&gt;&amp;- 
 
echo &quot;This won't work&quot; &gt;&amp;3 
$ ./badtest 
./badtest: 3: Bad file descriptor 
$ 

</code></pre>
<p>一旦关闭了文件描述符，就不能在脚本中向它写入任何数据，否则shell会生成错误消息。</p>
<p>在关闭文件描述符时还要注意另一件事。如果随后你在脚本中打开了同一个输出文件，shell会用一个新文件来替换已有文件。这意味着如果你输出数据，它就会覆盖已有文件。考虑下面这个问题的例子。</p>
<pre><code class="language-sh">$ cat test17 
#!/bin/bash 
# testing closing file descriptors 
 
exec 3&gt; test17file 
echo &quot;This is a test line of data&quot; &gt;&amp;3 
exec 3&gt;&amp;- 
 
cat test17file 
 
exec 3&gt; test17file 
echo &quot;This'll be bad&quot; &gt;&amp;3 
$ ./test17 
This is a test line of data 
$ cat test17file 
This'll be bad 
$ 
</code></pre>
<p>在向test17file文件发送一个数据字符串并关闭该文件描述符之后，脚本用了cat命令来显示文件的内容。到目前为止，一切都还好。下一步，脚本重新打开了该输出文件并向它发送了另一个数据字符串。当显示该输出文件的内容时，你所能看到的只有第二个数据字符串。shell覆盖了原来的输出文件。</p>
<h2 id="5-列出打开的文件描述符">5. 列出打开的文件描述符</h2>
<p>你能用的文件描述符只有9个，你可能会觉得这没什么复杂的。但有时要记住哪个文件描述符被重定向到了哪里很难。为了帮助你理清条理，bash shell提供了lsof命令。</p>
<p>lsof命令会列出整个Linux系统打开的所有文件描述符。这是个有争议的功能，因为它会向非系统管理员用户提供Linux系统的信息。鉴于此，许多Linux系统隐藏了该命令，这样用户就不会一不小心就发现了。</p>
<p>在很多Linux系统中（如Fedora），lsof命令位于/usr/sbin目录。要想以普通用户账户来运行它，必须通过全路径名来引用：</p>
<pre><code>$ /usr/sbin/lsof
</code></pre>
<p>该命令会产生大量的输出。它会显示当前Linux系统上打开的每个文件的有关信息。这包括后台运行的所有进程以及登录到系统的任何用户。</p>
<p>有大量的命令行选项和参数可以用来帮助过滤lsof的输出。最常用的有-p和-d，前者允许指定进程ID（PID），后者允许指定要显示的文件描述符编号。</p>
<p>要想知道进程的当前PID，可以用特殊环境变量$$（shell会将它设为当前PID）。-a选项用来对其他两个选项的结果执行布尔AND运算，这会产生如下输出。</p>
<pre><code class="language-sh">$ /usr/sbin/lsof -a -p $$ -d 0,1,2 
COMMAND  PID USER   FD   TYPE DEVICE SIZE NODE NAME 
bash    3344 rich    0u   CHR  136,0         2 /dev/pts/0 
bash    3344 rich    1u   CHR  136,0         2 /dev/pts/0 
bash    3344 rich    2u   CHR  136,0         2 /dev/pts/0 
$ 
</code></pre>
<p>上例显示了当前进程（bash shell）的默认文件描述符（0、1和2）。lsof的默认输出中有7列信息，见表15-2。</p>
<p><img src="https://s1.ax2x.com/2018/08/12/55NDMr.png" alt="55NDMr.png"><br>
<img src="https://s1.ax2x.com/2018/08/12/55NBeY.png" alt="55NBeY.png"></p>
<p>与STDIN、STDOUT和STDERR关联的文件类型是字符型。因为STDIN、STDOUT和STDERR文件描述符都指向终端，所以输出文件的名称就是终端的设备名。所有3种标准文件都支持读和写（尽管向STDIN写数据以及从STDOUT读数据看起来有点奇怪）。</p>
<p>现在看一下在打开了多个替代性文件描述符的脚本中使用lsof命令的结果。</p>
<pre><code class="language-sh">$ cat test18 
#!/bin/bash 
# testing lsof with file descriptors 
 
exec 3&gt; test18file1 
exec 6&gt; test18file2 
exec 7&lt; testfile 
 
/usr/sbin/lsof -a -p $$ -d0,1,2,3,6,7 
$ ./test18 
COMMAND  PID USER   FD   TYPE DEVICE SIZE   NODE NAME 
test18  3594 rich    0u   CHR  136,0           2 /dev/pts/0 
test18  3594 rich    1u   CHR  136,0           2 /dev/pts/0 
test18  3594 rich    2u   CHR  136,0           2 /dev/pts/0 
18  3594 rich    3w   REG  253,0    0 360712 /home/rich/test18file1 
18  3594 rich    6w   REG  253,0    0 360715 /home/rich/test18file2 
18  3594 rich    7r   REG  253,0   73 360717 /home/rich/testfile 
$ 
</code></pre>
<p>该脚本创建了3个替代性文件描述符，两个作为输出（3和6），一个作为输入（7）。在脚本运行lsof命令时，可以在输出中看到新的文件描述符。我们去掉了输出中的第一部分，这样你就能看到文件名的结果了。文件名显示了文件描述符所使用的文件的完整路径名。它将每个文件都显示成REG类型的，这说明它们是文件系统中的常规文件。</p>
<h2 id="6-阻止命令输出">6. 阻止命令输出</h2>
<p>有时候，你可能不想显示脚本的输出。这在将脚本作为后台进程运行时很常见。如果在运行在后台的脚本出现错误消息，shell会通过电子邮件将它们发给进程的属主。这会很麻烦，尤其是当运行会生成很多烦琐的小错误的脚本时。</p>
<p>要解决这个问题，可以将STDERR重定向到一个叫作null文件的特殊文件。null文件跟它的名字很像，文件里什么都没有。shell输出到null文件的任何数据都不会保存，全部都被丢掉了。</p>
<p>在Linux系统上null文件的标准位置是/dev/null。你重定向到该位置的任何数据都会被丢掉，不会显示。</p>
<pre><code class="language-sh">$ ls -al &gt; /dev/null 
$ cat /dev/null 
$
</code></pre>
<p>这是避免出现错误消息，也无需保存它们的一个常用方法。</p>
<pre><code class="language-sh">$ ls -al badfile test16 2&gt; /dev/null 
-rwxr--r--    1 rich     rich          135 Oct 29 19:57 test16* 
$
</code></pre>
<p>也可以在输入重定向中将/dev/null作为输入文件。由于/dev/null文件不含有任何内容，程序员通常用它来快速清除现有文件中的数据，而不用先删除文件再重新创建。</p>
<pre><code class="language-sh">$ cat testfile 
This is the first line. 
This is the second line. 
This is the third line. 
$ cat /dev/null &gt; testfile 
$ cat testfile 
$ 
</code></pre>
<p>文件testfile仍然存在系统上，但现在它是空文件。这是清除日志文件的一个常用方法，因为日志文件必须时刻准备等待应用程序操作。</p>
<h2 id="7-创建临时文件">7. 创建临时文件</h2>
<p>Linux系统有特殊的目录，专供临时文件使用。Linux使用/tmp目录来存放不需要永久保留的文件。大多数Linux发行版配置了系统在启动时自动删除/tmp目录的所有文件。</p>
<p>系统上的任何用户账户都有权限在读写/tmp目录中的文件。这个特性为你提供了一种创建临时文件的简单方法，而且还不用操心清理工作。</p>
<p>有个特殊命令可以用来创建临时文件。mktemp命令可以在/tmp目录中创建一个唯一的临时文件。shell会创建这个文件，但不用默认的umask值（参见第7章）。它会将文件的读和写权限分配给文件的属主，并将你设成文件的属主。一旦创建了文件，你就在脚本中有了完整的读写权限，但其他人没法访问它（当然，root用户除外）。</p>
<h4 id="71-创建本地临时文件">7.1 创建本地临时文件</h4>
<p>默认情况下，mktemp会在本地目录中创建一个文件。要用mktemp命令在本地目录中创建一个临时文件，你只要指定一个文件名模板就行了。模板可以包含任意文本文件名，在文件名末尾加上6个X就行了。</p>
<pre><code class="language-sh">$ mktemp testing.XXXXXX 
$ ls -al testing* 
-rw-------   1 rich     rich      0 Oct 17 21:30 testing.UfIi13 
$ 
</code></pre>
<p>mktemp命令会用6个字符码替换这6个X，从而保证文件名在目录中是唯一的。你可以创建多个临时文件，它可以保证每个文件都是唯一的。</p>
<pre><code class="language-sh">$ mktemp testing.XXXXXX 
testing.1DRLuV 
$ mktemp testing.XXXXXX 
testing.lVBtkW 
$ mktemp testing.XXXXXX 
testing.PgqNKG 
$ ls -l testing* 
-rw-------    1 rich     rich     0 Oct 17 21:57 testing.1DRLuV 
-rw-------    1 rich     rich     0 Oct 17 21:57 testing.PgqNKG 
-rw-------    1 rich     rich     0 Oct 17 21:30 testing.UfIi13 
-rw-------    1 rich     rich     0 Oct 17 21:57 testing.lVBtkW 
$ 
</code></pre>
<p>如你所看到的，mktemp命令的输出正是它所创建的文件的名字。在脚本中使用mktemp命令时，可能要将文件名保存到变量中，这样就能在后面的脚本中引用了。</p>
<pre><code class="language-sh">$ cat test19 
#!/bin/bash 
# creating and using a temp file 
tempfile=$(mktemp test19.XXXXXX) 
 
exec 3&gt;$tempfile 
 
echo &quot;This script writes to temp file $tempfile&quot; 
 
echo &quot;This is the first line&quot; &gt;&amp;3 
echo &quot;This is the second line.&quot; &gt;&amp;3 
echo &quot;This is the last line.&quot; &gt;&amp;3 
exec 3&gt;&amp;- 
 
echo &quot;Done creating temp file. The contents are:&quot; 
cat $tempfile 
rm -f $tempfile 2&gt; /dev/null 
$ ./test19 
This script writes to temp file test19.vCHoya 
Done creating temp file. The contents are: 
This is the first line 
This is the second line. 
This is the last line. 
$ ls -al test19* 
-rwxr--r--    1 rich     rich          356 Oct 29 22:03 test19* 
$ 
</code></pre>
<p>这个脚本用mktemp命令来创建临时文件并将文件名赋给$tempfile变量。接着将这个临时文件作为文件描述符3的输出重定向文件。在将临时文件名显示在STDOUT之后，向临时文件中写入了几行文本，然后关闭了文件描述符。最后，显示出临时文件的内容，并用rm命令将其删除。</p>
<h4 id="72-在tmp-目录创建临时文件">7.2  在/tmp 目录创建临时文件</h4>
<p>-t选项会强制mktemp命令来在系统的临时目录来创建该文件。在用这个特性时，mktemp命令会返回用来创建临时文件的全路径，而不是只有文件名。</p>
<pre><code class="language-sh">$ mktemp -t test.XXXXXX 
/tmp/test.xG3374 
$ ls -al /tmp/test* 
-rw------- 1 rich rich 0 2014-10-29 18:41 /tmp/test.xG3374 
$ 
</code></pre>
<p>由于mktemp命令返回了全路径名，你可以在Linux系统上的任何目录下引用该临时文件，不管临时目录在哪里。</p>
<pre><code class="language-sh">$ cat test20 
#!/bin/bash 
# creating a temp file in /tmp 
 
tempfile=$(mktemp -t tmp.XXXXXX) 
 
echo &quot;This is a test file.&quot; &gt; $tempfile 
echo &quot;This is the second line of the test.&quot; &gt;&gt; $tempfile 
 
echo &quot;The temp file is located at: $tempfile&quot; 
cat $tempfile 
rm -f $tempfile 
$ ./test20 
The temp file is located at: /tmp/tmp.Ma3390 
This is a test file. 
This is the second line of the test. 
$
</code></pre>
<p>在mktemp创建临时文件时，它会将全路径名返回给变量。这样你就能在任何命令中使用该值来引用临时文件了。</p>
<h4 id="73-创建临时目录">7.3 创建临时目录</h4>
<p>-d选项告诉mktemp命令来创建一个临时目录而不是临时文件。这样你就能用该目录进行任何需要的操作了，比如创建其他的临时文件。</p>
<pre><code class="language-sh">$ cat test21 
#!/bin/bash 
# using a temporary directory 
 
tempdir=$(mktemp -d dir.XXXXXX) 
cd $tempdir 
tempfile1=$(mktemp temp.XXXXXX) 
tempfile2=$(mktemp temp.XXXXXX) 
exec 7&gt; $tempfile1 
exec 8&gt; $tempfile2 
 
echo &quot;Sending data to directory $tempdir&quot; 
echo &quot;This is a test line of data for $tempfile1&quot; &gt;&amp;7 
echo &quot;This is a test line of data for $tempfile2&quot; &gt;&amp;8 
$ ./test21 
Sending data to directory dir.ouT8S8 
$ ls -al 
total 72 
drwxr-xr-x    3 rich     rich         4096 Oct 17 22:20 ./ 
drwxr-xr-x    9 rich     rich         4096 Oct 17 09:44 ../ 
drwx------    2 rich     rich         4096 Oct 17 22:20 dir.ouT8S8/ 
-rwxr--r--    1 rich     rich          338 Oct 17 22:20 test21* 
$ cd dir.ouT8S8 
[dir.ouT8S8]$ ls -al 
total 16 
drwx------    2 rich     rich         4096 Oct 17 22:20 ./ 
drwxr-xr-x    3 rich     rich         4096 Oct 17 22:20 ../ 
-rw-------    1 rich     rich           44 Oct 17 22:20 temp.N5F3O6 
-rw-------    1 rich     rich           44 Oct 17 22:20 temp.SQslb7 
[dir.ouT8S8]$ cat temp.N5F3O6 
This is a test line of data for temp.N5F3O6 
[dir.ouT8S8]$ cat temp.SQslb7 
This is a test line of data for temp.SQslb7 
[dir.ouT8S8]$
</code></pre>
<p>这段脚本在当前目录创建了一个目录，然后它用cd命令进入该目录，并创建了两个临时文件。之后这两个临时文件被分配给文件描述符，用来存储脚本的输出。</p>
<h2 id="8-记录消息">8. 记录消息 ***</h2>
<p>将输出同时发送到显示器和日志文件，这种做法有时候能够派上用场。你不用将输出重定向两次，只要用特殊的tee命令就行。</p>
<p>tee命令相当于管道的一个T型接头。它将从STDIN过来的数据同时发往两处。一处是STDOUT，另一处是tee命令行所指定的文件名：</p>
<pre><code>tee filename 
</code></pre>
<p>由于tee会重定向来自STDIN的数据，你可以用它配合管道命令来重定向命令输出。</p>
<pre><code class="language-sh">$ date | tee testfile 
Sun Oct 19 18:56:21 EDT 2014 
$ cat testfile 
Sun Oct 19 18:56:21 EDT 2014 
$
</code></pre>
<p>输出出现在了STDOUT中，同时也写入了指定的文件中。注意，默认情况下，tee命令会在每次使用时覆盖输出文件内容。</p>
<pre><code>$ who | tee testfile 
rich     pts/0        2014-10-17 18:41 (192.168.1.2) 
$ cat testfile 
rich     pts/0        2014-10-17 18:41 (192.168.1.2) 
$ 
</code></pre>
<p>如果你想将数据追加到文件中，必须用-a选项。</p>
<pre><code class="language-sh">$ date | tee -a testfile 
Sun Oct 19 18:58:05 EDT 2014 
$ cat testfile 
rich     pts/0        2014-10-17 18:41 (192.168.1.2) 
Sun Oct 19 18:58:05 EDT 2014 
$ 
</code></pre>
<p>利用这个方法，既能将数据保存在文件中，也能将数据显示在屏幕上。</p>
<pre><code class="language-sh">$ cat test22 
#!/bin/bash 
# using the tee command for logging 
 
tempfile=test22file 
 
echo &quot;This is the start of the test&quot; | tee $tempfile 
echo &quot;This is the second line of the test&quot; | tee -a $tempfile 
echo &quot;This is the end of the test&quot; | tee -a $tempfile 
$ ./test22 
This is the start of the test 
This is the second line of the test 
This is the end of the test 
$ cat test22file 
This is the start of the test 
This is the second line of the test 
This is the end of the test 
$ 
</code></pre>
<p>现在你就可以在为用户显示输出的同时再永久保存一份输出内容了。</p>
<h2 id="9-实例-暂不学习了有兴趣可以-linux命令行与shell脚本编程大全第3版-159章节-有兴趣了可以在好好学习一下">9. 实例 --(暂不学习了，有兴趣可以 “Linux命令行与shell脚本编程大全.第3版” 15.9章节 有兴趣了可以在好好学习一下)</h2>
<p>...</p>
<h2 id="10-小结">10. 小结</h2>
<ul>
<li>
<p>在创建脚本时，理解了bash shell如何处理输入和输出会给你带来很多方便。你可以改变脚本获取数据以及显示数据的方式，从而在任何环境中定制脚本。脚本的输入/输出都可以从标准输入（STDIN）/标准输出（STDOUT）重定向到系统中的任意文件。除了STDOUT，你可以通过重定向STDERR输出来重定向由脚本产生的错误消息。这可以通过重定向与STDERR输出关联的文件描述符（也就是文件描述符2）来实现。可以将STDERR输出和STDOUT输出到同一个文件中，也可以输出到完全不同的文件中。这样就可以将脚本的正常消息同错误消息分离开。</p>
</li>
<li>
<p>bash shell允许在脚本中创建自己的文件描述符。你可以创建文件描述符3~9，并将它们分配给要用到的任何输出文件。一旦创建了文件描述符，你就可以利用标准的重定向符号将任意命令的输出重定向到那里。</p>
</li>
<li>
<p>bash shell也允许将输入重定向到一个文件描述符，这给出了一种将文件数据读入到脚本中的简便途径。你可以用lsof命令来显示shell中在用的文件描述符。</p>
</li>
<li>
<p>Linux系统提供了一个特殊的文件（称为/dev/null）来重定向不需要的输出。Linux系统会删掉任何重定向到/dev/null文件的东西。你也可以通过将/dev/null文件的内容重定向到一个文件中来产生空文件。</p>
</li>
<li>
<p>mktemp命令是bash shell中一个很方便的特性，可以轻松地创建临时文件和目录。只需要给mktemp命令指定一个模板，它就能在每次调用时基于该文件模板的格式创建一个唯一的文件。也可以在Linux系统的/tmp目录创建临时文件和目录，系统启动时会清空这个特殊位置中的内容。</p>
</li>
<li>
<p>tee命令便于将输出同时发送给标准输出和日志文件。这样就可以在显示器上显示脚本的消息的同时，又能将它们保存在日志文件中。</p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[shell语言脚本构建4-处理用户输入]]></title>
        <id>https://wangxf133.github.io/post/shell-yu-yan-jiao-ben-gou-jian-4-chu-li-yong-hu-shu-ru</id>
        <link href="https://wangxf133.github.io/post/shell-yu-yan-jiao-ben-gou-jian-4-chu-li-yong-hu-shu-ru">
        </link>
        <updated>2019-03-27T11:40:14.000Z</updated>
        <content type="html"><![CDATA[<!--More-->
<p>目前为止，你已经看到了如何编写脚本，处理数据、变量和Linux系统上的文件。有时，你编写的脚本还得能够与使用者进行交互。bash shell提供了一些不同的方法来从用户处获得数据，包括命令行参数（添加在命令后的数据）、命令行选项（可修改命令行为的单个字母）以及直接从键盘读取输入的能力。本章将会讨论如何在你的bash shell脚本运用这些方法来从脚本用户处获得数据。</p>
<h2 id="1-命令行参数">1. 命令行参数</h2>
<p>向shell脚本传递数据的最基本方法是使用命令行参数。命令行参数允许在运行脚本时向命令行添加数据。</p>
<pre><code>$ ./addem 10 30 
</code></pre>
<p>本例向脚本addem传递了两个命令行参数（10和30）。脚本会通过特殊的变量来处理命令行参数。后面几节将会介绍如何在bash shell脚本中使用命令行参数。</p>
<h4 id="11-读取参数">1.1 读取参数</h4>
<p>bash shell会将一些称为<strong>位置参数（positional parameter）的特殊变量分配给输入到命令行中的所有参数</strong>。这也包括shell所执行的脚本名称。<strong>位置参数变量是标准的数字：$0是程序名，$1是第一个参数，$2是第二个参数，依次类推，直到第九个参数$9。</strong></p>
<p>下面是在shell脚本中使用单个命令行参数的简单例子。</p>
<pre><code class="language-sh">$ cat test1.sh 
#!/bin/bash 
# using one command line parameter 
# 
factorial=1 
for (( number = 1; number &lt;= $1 ; number++ )) 
do 
   factorial=$[ $factorial * $number ] 
done 
echo The factorial of $1 is $factorial 
$  


$ ./test1.sh 5 
The factorial of 5 is 120 
$ 
</code></pre>
<p>可以在shell脚本中像使用其他变量一样使用$1变量。shell脚本会自动将命令行参数的值分配给变量，不需要你作任何处理。</p>
<p>如果需要输入更多的命令行参数，则每个参数都必须用空格分开。</p>
<pre><code class="language-sh">$ cat test2.sh 
#!/bin/bash 
# testing two command line parameters 
# 
total=$[ $1 * $2 ] 
echo The first parameter is $1. 
echo The second parameter is $2. 
echo The total value is $total. 
$  
$ ./test2.sh 2 5 
The first parameter is 2. 
The second parameter is 5. 
The total value is 10. 
$ 
</code></pre>
<p>shell会将每个参数分配给对应的变量。</p>
<p>在前面的例子中，用到的命令行参数都是数值。也可以在命令行上用文本字符串。</p>
<pre><code class="language-sh">$ cat test3.sh 
#!/bin/bash 
# testing string parameters 
# 
echo Hello $1, glad to meet you. 
$  
$ ./test3.sh Rich 
Hello Rich, glad to meet you. 
$ 
</code></pre>
<p>shell将输入到命令行的字符串值传给脚本。但碰到含有空格的文本字符串时就会出现问题：</p>
<pre><code class="language-sh">$ ./test3.sh Rich Blum 
Hello Rich, glad to meet you. 
$ 
</code></pre>
<p>记住，每个参数都是用空格分隔的，所以shell会将空格当成两个值的分隔符。要在参数值中包含空格，必须要用引号（单引号或双引号均可）。</p>
<pre><code class="language-sh">$ ./test3.sh 'Rich Blum' 
Hello Rich Blum, glad to meet you. 
$  
$ ./test3.sh &quot;Rich Blum&quot; 
Hello Rich Blum, glad to meet you. 
$ 
</code></pre>
<p><img src="https://s1.ax2x.com/2018/08/12/55IbFe.png" alt="55IbFe.png"></p>
<pre><code class="language-sh">$ cat test4.sh 
#!/bin/bash 
# handling lots of parameters 
# 
total=$[ ${10} * ${11} ] 
echo The tenth parameter is ${10} 
echo The eleventh parameter is ${11} 
echo The total is $total 
$  
$ ./test4.sh 1 2 3 4 5 6 7 8 9 10 11 12 
The tenth parameter is 10 
The eleventh parameter is 11 
The total is 110 
$
</code></pre>
<p>这项技术允许你根据需要向脚本添加任意多的命令行参数。</p>
<h4 id="12-读取脚本名">1.2 读取脚本名</h4>
<pre><code class="language-sh">$ cat test5.sh 
#!/bin/bash 
# Testing the $0 parameter 
# 
echo The zero parameter is set to: $0 
# 
$ 
$ bash test5.sh 
The zero parameter is set to: test5.sh 
$ 
</code></pre>
<p>但是这里存在一个潜在的问题。如果使用另一个命令来运行shell脚本，命令会和脚本名混在一起，出现在$0参数中。</p>
<pre><code class="language-sh">$ ./test5.sh 
The zero parameter is set to: ./test5.sh 
$
</code></pre>
<p>这还不是唯一的问题。当传给$0变量的实际字符串不仅仅是脚本名，而是完整的脚本路径时，变量$0就会使用整个路径。</p>
<pre><code class="language-sh">$ bash /home/Christine/test5.sh 
The zero parameter is set to: /home/Christine/test5.sh 
$ 
</code></pre>
<p>如果你要编写一个根据脚本名来执行不同功能的脚本，就得做点额外工作。你得把脚本的运行路径给剥离掉。另外，还要删除与脚本名混杂在一起的命令。</p>
<p>幸好有个方便的小命令可以帮到我们。basename命令会返回不包含路径的脚本名。</p>
<pre><code class="language-sh">$ cat test5b.sh 
#!/bin/bash 
# Using basename with the $0 parameter 
# 
name=$(basename $0) 
echo 
echo The script name is: $name 
# 
$ bash /home/Christine/test5b.sh 
 
The script name is: test5b.sh 
$ 
$ ./test5b.sh 
 
The script name is: test5b.sh 
$ 
</code></pre>
<p>现在好多了。可以用这种方法来编写基于脚本名执行不同功能的脚本。这里有个简单的例子。</p>
<pre><code class="language-sh">$ cat test6.sh 
#!/bin/bash 
# Testing a Multi-function script 
# 
name=$(basename $0) 
# 
if [ $name = &quot;addem&quot; ] 
then 
   total=$[ $1 + $2 ] 
# 
elif [ $name = &quot;multem&quot; ] 
then 
   total=$[ $1 * $2 ] 
fi 
# 
echo 
echo The calculated value is $total 
#


$ 

$ chmod u+x addem 
$ 
$ ln -s test6.sh multem 
$ 
$ ls -l *em 
-rwxrw-r--. 1 Christine Christine 224 Jun 30 23:50 addem 
lrwxrwxrwx. 1 Christine Christine   8 Jun 30 23:50 multem -&gt; test6.sh 
$ 
$ ./addem 2 5 
 
The calculated value is 7 
$ 
$ ./multem 2 5 
 
The calculated value is 10 
$ 

</code></pre>
<p>本例从test6.sh脚本中创建了两个不同的文件名：一个通过复制文件创建（addem），另一个通过链接（参见第3章）创建（multem）。在两种情况下都会先获得脚本的基本名称，然后根据该值执行相应的功能。</p>
<h4 id="13-测试参数">1.3 测试参数</h4>
<p>在shell脚本中使用命令行参数时要小心些。如果脚本不加参数运行，可能会出问题。</p>
<pre><code class="language-sh">$ ./addem 2 
./addem: line 8: 2 +  : syntax error: operand expected (error 
 token is &quot; &quot;) 
The calculated value is 
$ 
</code></pre>
<p>当脚本认为参数变量中会有数据而实际上并没有时，脚本很有可能会产生错误消息。这种写脚本的方法并不可取。在使用参数前一定要检查其中是否存在数据。</p>
<pre><code class="language-sh">$ cat test7.sh 
#!/bin/bash 
# testing parameters before use 
# 
if [ -n &quot;$1&quot; ] 
then 
   echo Hello $1, glad to meet you. 
else 
   echo &quot;Sorry, you did not identify yourself. &quot; 
fi 
$  
$ ./test7.sh Rich 
Hello Rich, glad to meet you. 
$  
$ ./test7.sh 
Sorry, you did not identify yourself. 
$ 
</code></pre>
<p>在本例中，使用了-n测试来检查命令行参数$1中是否有数据。在下一节中，你会看到还有另一种检查命令行参数的方法。</p>
<h2 id="2-特殊参数变量">2. 特殊参数变量</h2>
<p>在bash shell中有些特殊变量，它们会记录命令行参数。本节将会介绍这些变量及其用法。</p>
<h4 id="21-参数统计">2.1 参数统计**</h4>
<p>如在上一节中看到的，在脚本中使用命令行参数之前应该检查一下命令行参数。对于使用多个命令行参数的脚本来说，这有点麻烦。</p>
<p>你可以统计一下命令行中输入了多少个参数，无需测试每个参数。bash shell为此提供了一个特殊变量。</p>
<p>特殊变量$#含有脚本运行时携带的命令行参数的个数。可以在脚本中任何地方使用这个特殊变量，就跟普通变量一样。</p>
<pre><code class="language-sh">$ cat test8.sh 
#!/bin/bash 
# getting the number of parameters 
# 
echo There were $# parameters supplied. 
$  
$ ./test8.sh 
There were 0 parameters supplied. 
$  
$ ./test8.sh 1 2 3 4 5 
There were 5 parameters supplied. 
$  
$ ./test8.sh 1 2 3 4 5 6 7 8 9 10 
There were 10 parameters supplied. 
$  
$ ./test8.sh &quot;Rich Blum&quot; 
There were 1 parameters supplied. 
$ 
</code></pre>
<p>现在你就能在使用参数前测试参数的总数了。</p>
<pre><code class="language-sh">$ cat test9.sh 
#!/bin/bash 
# Testing parameters 
# 
if [ $# -ne 2 ] 
then 
   echo 
   echo Usage: test9.sh a b 
   echo 
else 
   total=$[ $1 + $2 ] 
   echo 
   echo The total is $total 
   echo 
fi 
# 
$
$ bash test9.sh 
 
Usage: test9.sh a b 
 
$ bash test9.sh 10 
 
Usage: test9.sh a b 
 
$ bash test9.sh 10 15 
 
The total is 25 
 
$ 
</code></pre>
<p>if-then语句用-ne测试命令行参数数量。如果参数数量不对，会显示一条错误消息告知脚本的正确用法。</p>
<p>这个变量还提供了一个简便方法来获取命令行中最后一个参数，完全不需要知道实际上到底用了多少个参数。不过要实现这一点，得稍微多花点工夫。</p>
<p><img src="https://s1.ax2x.com/2018/08/12/55Ipud.png" alt="55Ipud.png"></p>
<pre><code class="language-sh">$ cat badtest1.sh 
#!/bin/bash 
# testing grabbing last parameter 
# 
echo The last parameter was ${$#} 
$  
$ ./badtest1.sh 10 
The last parameter was 15354 
$
</code></pre>
<p>怎么了？显然，出了点问题。它表明你不能在花括号内使用美元符。必须将美元符换成感叹号。很奇怪，但的确管用。</p>
<pre><code class="language-sh">$ cat test10.sh 
#!/bin/bash 
# Grabbing the last parameter 
# 
params=$# 
echo 
echo The last parameter is $params 
echo The last parameter is ${!#} 
echo 
# 
$ 
$ bash test10.sh 1 2 3 4 5 
The last parameter is 5 
The last parameter is 5 
 
$ 
$ bash test10.sh 
 
The last parameter is 0 
The last parameter is test10.sh 
 
$
</code></pre>
<p><img src="https://s1.ax2x.com/2018/08/12/55IsAR.png" alt="55IsAR.png"></p>
<h4 id="22-抓取所有的数据">2.2 抓取所有的数据</h4>
<p>有时候需要抓取命令行上提供的所有参数。这时候不需要先用$#变量来判断命令行上有多少参数，然后再进行遍历，你可以使用一组其他的特殊变量来解决这个问题。</p>
<p>$*和$@变量可以用来轻松访问所有的参数。这两个变量都能够在单个变量中存储所有的命令行参数。</p>
<p>$*变量会将命令行上提供的所有参数当作一个单词保存。这个单词包含了命令行中出现的每一个参数值。基本上$*变量会将这些参数视为一个整体，而不是多个个体。</p>
<p>另一方面，$@变量会将命令行上提供的所有参数当作同一字符串中的多个独立的单词。这样你就能够遍历所有的参数值，得到每个参数。这通常通过for命令完成。</p>
<p>这两个变量的工作方式不太容易理解。看个例子，你就能理解二者之间的区别了。</p>
<pre><code class="language-sh">$ cat test11.sh 
#!/bin/bash 
# testing $* and $@ 
# 
echo 
echo &quot;Using the \$* method: $*&quot; 
echo 
echo &quot;Using the \$@ method: $@&quot; 
$  
$ ./test11.sh rich barbara katie jessica 
 
Using the $* method: rich barbara katie jessica 
 
Using the $@ method: rich barbara katie jessica 
$ 
</code></pre>
<p>注意，从表面上看，两个变量产生的是同样的输出，都显示出了所有命令行参数。</p>
<p>下面的例子给出了二者的差异。</p>
<pre><code class="language-sh">$ cat test12.sh 
#!/bin/bash 
# testing $* and $@ 
# 
echo 
count=1 
# 
for param in &quot;$*&quot; 
do 
   echo &quot;\$* Parameter #$count = $param&quot; 
   count=$[ $count + 1 ] 
done 
# 
echo 
count=1 
# 
for param in &quot;$@&quot; 
do 
   echo &quot;\$@ Parameter #$count = $param&quot; 
   count=$[ $count + 1 ] 
done 
$  
$ ./test12.sh rich barbara katie jessica 
 
$* Parameter #1 = rich barbara katie jessica 
 
$@ Parameter #1 = rich 
$@ Parameter #2 = barbara 
$@ Parameter #3 = katie 
$@ Parameter #4 = jessica 
$ 
</code></pre>
<p>现在清楚多了。通过使用for命令遍历这两个特殊变量，你能看到它们是如何不同地处理命令行参数的。$*变量会将所有参数当成单个参数，而$@变量会单独处理每个参数。这是遍历命令行参数的一个绝妙方法。</p>
<h2 id="3-移动变量">3. 移动变量</h2>
<p>bash shell工具箱中另一件工具是shift命令。bash shell的shift命令能够用来操作命令行参数。跟字面上的意思一样，shift命令会根据它们的相对位置来移动命令行参数。</p>
<p>在使用shift命令时，默认情况下它会将每个参数变量向左移动一个位置。所以，变量$3的值会移到$2中，变量$2的值会移到$1中，而变量$1的值则会被删除（注意，变量$0的值，也就是程序名，不会改变）。</p>
<p>这是遍历命令行参数的另一个好方法，尤其是在你不知道到底有多少参数时。你可以只操作第一个参数，移动参数，然后继续操作第一个参数。</p>
<p>这里有个例子来解释它是如何工作的。</p>
<pre><code class="language-sh">$ cat test13.sh 
#!/bin/bash 
# demonstrating the shift command 

echo 
count=1 
while [ -n &quot;$1&quot; ] 
do 
   echo &quot;Parameter #$count = $1&quot; 
   count=$[ $count + 1 ] 
   shift 
done 
$  
$ ./test13.sh rich barbara katie jessica 
 
Parameter #1 = rich 
Parameter #2 = barbara 
Parameter #3 = katie 
Parameter #4 = jessica 
$ 
</code></pre>
<p>这个脚本通过测试第一个参数值的长度执行了一个while循环。当第一个参数的长度为零时，循环结束。测试完第一个参数后，shift命令会将所有参数的位置移动一个位置。</p>
<p>另外，你也可以一次性移动多个位置，只需要给shift命令提供一个参数，指明要移动的位置数就行了。</p>
<pre><code class="language-sh">$ cat test14.sh 
#!/bin/bash 
# demonstrating a multi-position shift 
# 
echo 
echo &quot;The original parameters: $*&quot; 
shift 2 
echo &quot;Here's the new first parameter: $1&quot; 
$  
$ ./test14.sh 1 2 3 4 5 
 
The original parameters: 1 2 3 4 5 
Here's the new first parameter: 3 
$ 
</code></pre>
<p>通过使用shift命令的参数，就可以轻松地跳过不需要的参数。</p>
<h2 id="4-处理选项">4. 处理选项</h2>
<p>如果你认真读过本书前面的所有内容，应该就见过了一些同时提供了参数和选项的bash命令。<strong>选项是跟在单破折线后面的单个字母，它能改变命令的行为。本节将会介绍3种在脚本中处理选项的方法。</strong></p>
<h4 id="41-查找选项">4.1 查找选项</h4>
<p>表面上看，命令行选项也没什么特殊的。在命令行上，它们紧跟在脚本名之后，就跟命令行参数一样。实际上，如果愿意，你可以像处理命令行参数一样处理命令行选项。</p>
<ol>
<li>处理简单选项</li>
</ol>
<p>在前面的test13.sh脚本中，你看到了如何使用shift命令来依次处理脚本程序携带的命令行参数。你也可以用同样的方法来处理命令行选项。</p>
<p>在提取每个单独参数时，用case语句（参见第12章）来判断某个参数是否为选项。</p>
<pre><code class="language-sh">$ cat test15.sh 
#!/bin/bash 
# extracting command line options as parameters 
# 
echo 
while [ -n &quot;$1&quot; ] 
do 
   case &quot;$1&quot; in 
     -a) echo &quot;Found the -a option&quot; ;; 
     -b) echo &quot;Found the -b option&quot; ;; 
     -c) echo &quot;Found the -c option&quot; ;; 
      *) echo &quot;$1 is not an option&quot; ;; 
   esac 
   shift 
done 

$  
$ ./test15.sh -a -b -c -d 
 
Found the -a option 
Found the -b option 
Found the -c option 
-d is not an option 
$ 
</code></pre>
<p>case语句会检查每个参数是不是有效选项。如果是的话，就运行对应case语句中的命令。不管选项按什么顺序出现在命令行上，这种方法都适用。</p>
<pre><code class="language-sh">$ ./test15.sh -d -c -a 
 
-d is not an option 
Found the -c option 
Found the -a option 
$ 
</code></pre>
<p>case语句在命令行参数中找到一个选项，就处理一个选项。如果命令行上还提供了其他参数，你可以在case语句的通用情况处理部分中处理。</p>
<p>你会经常遇到想在shell脚本中同时使用选项和参数的情况。Linux中处理这个问题的标准方式是用特殊字符来将二者分开，该字符会告诉脚本何时选项结束以及普通参数何时开始。</p>
<p>对Linux来说，这个特殊字符是双破折线（--）。shell会用双破折线来表明选项列表结束。在双破折线之后，脚本就可以放心地将剩下的命令行参数当作参数，而不是选项来处理了。</p>
<p>要检查双破折线，只要在case语句中加一项就行了。</p>
<pre><code class="language-sh">$ cat test16.sh 
#!/bin/bash 
# extracting options and parameters 
echo 
while [ -n &quot;$1&quot; ] 
do 
   case &quot;$1&quot; in 
      -a) echo &quot;Found the -a option&quot; ;; 
      -b) echo &quot;Found the -b option&quot;;; 
      -c) echo &quot;Found the -c option&quot; ;; 
      --) shift 
          break ;; 
       *) echo &quot;$1 is not an option&quot;;; 
   esac 
   shift 
done 
# 
count=1 
for param in $@ 
do 
   echo &quot;Parameter #$count: $param&quot; 
   count=$[ $count + 1 ] 
done 
$
</code></pre>
<p>在遇到双破折线时，脚本用break命令来跳出while循环。由于过早地跳出了循环，我们需要再加一条shift命令来将双破折线移出参数变量。</p>
<p>对于第一个测试，试试用一组普通的选项和参数来运行这个脚本。</p>
<pre><code class="language-sh">$ ./test16.sh -c -a -b test1 test2 test3 
 
Found the -c option 
Found the -a option 
Found the -b option 
test1 is not an option 
test2 is not an option 
test3 is not an option 
$ 
</code></pre>
<p>结果说明在处理时脚本认为所有的命令行参数都是选项。接下来，进行同样的测试，只是这次会用双破折线来将命令行上的选项和参数划分开来。</p>
<pre><code class="language-sh">$ ./test16.sh -c -a -b -- test1 test2 test3 
 
Found the -c option 
Found the -a option 
Found the -b option 
Parameter #1: test1 
Parameter #2: test2 
Parameter #3: test3 
$ 
</code></pre>
<p>当脚本遇到双破折线时，它会停止处理选项，并将剩下的参数都当作命令行参数。</p>
<ol start="3">
<li>处理带值的选项</li>
</ol>
<p>有些选项会带上一个额外的参数值。在这种情况下，命令行看起来像下面这样。</p>
<pre><code class="language-sh">$ ./testing.sh -a test1 -b -c -d test2
</code></pre>
<p>当命令行选项要求额外的参数时，脚本必须能检测到并正确处理。下面是如何处理的例子。</p>
<pre><code class="language-sh">$ cat test17.sh 
#!/bin/bash 
# extracting command line options and values 
echo 
while [ -n &quot;$1&quot; ] 
do 
   case &quot;$1&quot; in 
      -a) echo &quot;Found the -a option&quot;;; 
      -b) param=&quot;$2&quot; 
          echo &quot;Found the -b option, with parameter value $param&quot; 
          shift ;; 
      -c) echo &quot;Found the -c option&quot;;; 
      --) shift 
          break ;; 
       *) echo &quot;$1 is not an option&quot;;; 
   esac 
   shift 
done 
# 
count=1 
for param in &quot;$@&quot; 
do 
   echo &quot;Parameter #$count: $param&quot; 
   count=$[ $count + 1 ] 
done 
$  
$ ./test17.sh -a -b test1 -d 
 
Found the -a option 
Found the -b option, with parameter value test1 
-d is not an option 
$
</code></pre>
<p>在这个例子中，case语句定义了三个它要处理的选项。-b选项还需要一个额外的参数值。由于要处理的参数是\1，额外的参数值就应该位于$2（因为所有的参数在处理完都会被移出）。只要将参数值从$2变量中提取出来就可以了。当然，因为这个选项占用了两个参数位，所以你还需要使用shift命令多移动一个位置。</p>
<p>只用这些基本的特性，整个过程就能正常工作，不管按什么顺序放置选项（但要记住包含每个选项相应的选项参数）。</p>
<pre><code class="language-sh">$ ./test17.sh -b test1 -a -d 
Found the -b option, with parameter value test1 
Found the -a option 
-d is not an option 
$
</code></pre>
<p>现在shell脚本中已经有了处理命令行选项的基本能力，但还有一些限制。比如，如果你想将多个选项放进一个参数中时，它就不能工作了。</p>
<pre><code class="language-sh">$ ./test17.sh -ac 
-ac is not an option 
$ 
</code></pre>
<p>在Linux中，合并选项是一个很常见的用法，而且如果脚本想要对用户更友好一些，也要给用户提供这种特性。幸好，有另外一种处理选项的方法能够帮忙。</p>
<h4 id="42-使用getopt命令">4.2 使用getopt命令</h4>
<p>getopt命令是一个在处理命令行选项和参数时非常方便的工具。它能够识别命令行参数，从而在脚本中解析它们时更方便。</p>
<ol>
<li>命令的格式</li>
</ol>
<p>getopt命令可以接受一系列任意形式的命令行选项和参数，并自动将它们转换成适当的格式。它的命令格式如下：</p>
<pre><code>getopt optstring parameters 
</code></pre>
<p><strong>optstring</strong>是这个过程的关键所在。它定义了命令行有效的选项字母，还定义了哪些选项字母需要参数值。</p>
<p>首先，在optstring中列出你要在脚本中用到的每个命令行选项字母。然后，在每个需要参数值的选项字母后加一个冒号。getopt命令会基于你定义的optstring解析提供的参数。</p>
<hr>
<p>窍门:</p>
<p>getopt命令有一个更高级的版本叫作getopts（注意这是复数形式）。getopts命令会在本文随后部分讲到。因为这两个命令的拼写几乎一模一样，所以很容易搞混。一定要小心！</p>
<hr>
<p>下面是个getopt如何工作的简单例子。</p>
<pre><code class="language-sh">$ getopt ab:cd -a -b test1 -cd test2 test3 
 -a -b test1 -c -d -- test2 test3 
$
</code></pre>
<p>optstring定义了四个有效选项字母：a、b、c和d。冒号（:）被放在了字母b后面，因为b选项需要一个参数值。当getopt命令运行时，它会检查提供的参数列表（-a -b test1 -cd test2 test3），并基于提供的optstring进行解析。注意，它会自动将-cd选项分成两个单独的选项，并插入双破折线来分隔行中的额外参数。</p>
<p>如果指定了一个不在optstring中的选项，默认情况下，getopt命令会产生一条错误消息。</p>
<pre><code class="language-sh">$ getopt ab:cd -a -b test1 -cde test2 test3 
getopt: invalid option -- e 
 -a -b test1 -c -d -- test2 test3 
$ 
</code></pre>
<p>如果想忽略这条错误消息，可以在命令后加-q选项。</p>
<pre><code class="language-sh">$ getopt -q ab:cd -a -b test1 -cde test2 test3 
 -a -b 'test1' -c -d -- 'test2' 'test3' 
$ 
</code></pre>
<p>注意，getopt命令选项必须出现在optstring之前。现在应该可以在脚本中使用此命令处理命令行选项了。</p>
<ol start="2">
<li>在脚本中使用getopt</li>
</ol>
<p>可以在脚本中使用getopt来格式化脚本所携带的任何命令行选项或参数，但用起来略微复杂。</p>
<p>可以在脚本中使用getopt来格式化脚本所携带的任何命令行选项或参数。</p>
<p>方法是用getopt命令生成的格式化后的版本来替换已有的命令行选项和参数。用set命令能够做到。</p>
<p>set命令能够处理shell中的各种变量。</p>
<p>set命令的选项之一是双破折线（--），它会将命令行参数替换成set命令的命令行值。</p>
<p>然后，该方法会将原始脚本的命令行参数传给getopt命令，之后再将getopt命令的输出传给set命令，用getopt格式化后的命令行参数来替换原始的命令行参数，看起来如下所示。</p>
<pre><code>set -- $(getopt -q ab:cd &quot;$@&quot;) 
</code></pre>
<p>现在原始的命令行参数变量的值会被getopt命令的输出替换，而getopt已经为我们格式化好了命令行参数。</p>
<p>利用该方法，现在就可以写出能帮我们处理命令行参数的脚本。</p>
<pre><code class="language-sh">$ cat test18.sh 
#!/bin/bash 
# Extract command line options &amp; values with getopt 
# 
set -- $(getopt -q ab:cd &quot;$@&quot;) 
# 
echo 
while [ -n &quot;$1&quot; ] 
do 
   case &quot;$1&quot; in 
   -a) echo &quot;Found the -a option&quot; ;; 
   -b) param=&quot;$2&quot; 
       echo &quot;Found the -b option, with parameter value $param&quot; 
       shift ;; 
   -c) echo &quot;Found the -c option&quot; ;; 
   --) shift 
       break ;; 
    *) echo &quot;$1 is not an option&quot;;; 
   esac 
   shift 
done 
# 
count=1 
for param in &quot;$@&quot; 
do 
   echo &quot;Parameter #$count: $param&quot; 
   count=$[ $count + 1 ] 
done 
# 
$
</code></pre>
<p>你会注意到它跟脚本test17.sh一样，唯一不同的是加入了getopt命令来帮助格式化命令行参数。</p>
<p>现在如果运行带有复杂选项的脚本，就可以看出效果更好了。</p>
<pre><code class="language-sh">$ ./test18.sh -ac 
 
Found the -a option 
Found the -c option 
$ 
</code></pre>
<p>当然，之前的功能照样没有问题。</p>
<pre><code class="language-sh">$ ./test18.sh -a -b test1 -cd test2 test3 test4 
 
Found the -a option 
Found the -b option, with parameter value 'test1' 
Found the -c option 
Parameter #1: 'test2' 
Parameter #2: 'test3' 
Parameter #3: 'test4' 
$ 
</code></pre>
<p>现在看起来相当不错了。但是，在getopt命令中仍然隐藏着一个小问题。看看这个例子。</p>
<pre><code class="language-sh">$ ./test18.sh -a -b test1 -cd &quot;test2 test3&quot; test4 
 
Found the -a option 
Found the -b option, with parameter value 'test1' 
Found the -c option 
Parameter #1: 'test2 
Parameter #2: test3' 

</code></pre>
<p>getopt命令并不擅长处理带空格和引号的参数值。它会将空格当作参数分隔符，而不是根据双引号将二者当作一个参数。幸而还有另外一个办法能解决这个问题。</p>
<h4 id="43-使用更高级的-getopts">4.3 使用更高级的 getopts **</h4>
<p>getopts命令（注意是复数）内建于bash shell。它跟近亲getopt看起来很像，但多了一些扩展功能。</p>
<p>与getopt不同，前者将命令行上选项和参数处理后只生成一个输出，而getopts命令能够和已有的shell参数变量配合默契。</p>
<p>每次调用它时，它一次只处理命令行上检测到的一个参数。处理完所有的参数后，它会退出并返回一个大于0的退出状态码。这让它非常适合用解析命令行所有参数的循环中。</p>
<p>getopts命令的格式如下：</p>
<pre><code>getopts optstring variable 
</code></pre>
<p>optstring值类似于getopt命令中的那个。有效的选项字母都会列在optstring中，如果选项字母要求有个参数值，就加一个冒号。<strong>要去掉错误消息的话，可以在optstring之前加一个冒号</strong>。getopts命令将当前参数保存在命令行中定义的variable中。</p>
<p>getopts命令会用到两个环境变量。如果选项需要跟一个参数值，<strong>OPTARG环境变量</strong>就会保存这个值。OPTIND环境变量保存了参数列表中getopts正在处理的参数位置。这样你就能在处理完选项之后继续处理其他命令行参数了。</p>
<p>让我们看个使用getopts命令的简单例子。</p>
<pre><code class="language-sh">$ cat test19.sh 
#!/bin/bash 
# simple demonstration of the getopts command 
# 
echo 
while getopts :ab:c opt 
do 
   case &quot;$opt&quot; in 
      a) echo &quot;Found the -a option&quot; ;; 
      b) echo &quot;Found the -b option, with value $OPTARG&quot;;; 
      c) echo &quot;Found the -c option&quot; ;; 
      *) echo &quot;Unknown option: $opt&quot;;; 
   esac 
done 
$ 


$ ./test19.sh -ab test1 -c 
 
Found the -a option 
Found the -b option, with value test1 
Found the -c option 
$ 
</code></pre>
<p>while语句定义了getopts命令，指明了要查找哪些命令行选项，以及每次迭代中存储它们的变量名（opt）。</p>
<p>你会注意到在本例中case语句的用法有些不同。getopts命令解析命令行选项时会移除开头的单破折线，所以在case定义中不用单破折线。</p>
<p>getopts命令有几个好用的功能。对新手来说，可以在参数值中包含空格。</p>
<pre><code class="language-sh">$ ./test19.sh -b &quot;test1 test2&quot; -a 
 
Found the -b option, with value test1 test2 
Found the -a option 
$ 
</code></pre>
<p>另一个好用的功能是将选项字母和参数值放在一起使用，而不用加空格。</p>
<pre><code class="language-sh">$ ./test19.sh -abtest1 
 
Found the -a option 
Found the -b option, with value test1 
$
</code></pre>
<p>getopts命令能够从-b选项中正确解析出test1值。除此之外，getopts还能够将命令行上找到的所有未定义的选项统一输出成问号。</p>
<pre><code class="language-sh">$ ./test19.sh -d 
 
Unknown option: ? 
$  
$ ./test19.sh -acde 
 
Found the -a option 
Found the -c option 
Unknown option: ? 
Unknown option: ? 
$ 
</code></pre>
<p>optstring中未定义的选项字母会以问号形式发送给代码。</p>
<p>getopts命令知道何时停止处理选项，并将参数留给你处理。在getopts处理每个选项时，它会将OPTIND环境变量值增一。在getopts完成处理时，你可以使用shift命令和OPTIND值来移动参数。</p>
<pre><code class="language-sh">$ cat test20.sh 
#!/bin/bash 
# Processing options &amp; parameters with getopts 
# 
echo 
while getopts :ab:cd opt 
do 
   case &quot;$opt&quot; in 
   a) echo &quot;Found the -a option&quot;  ;; 
   b) echo &quot;Found the -b option, with value $OPTARG&quot; ;; 
   c) echo &quot;Found the -c option&quot;  ;; 
   d) echo &quot;Found the -d option&quot;  ;; 
   *) echo &quot;Unknown option: $opt&quot; ;; 
   esac 
done 
# 
shift $[ $OPTIND - 1 ] 
# 
echo 
count=1 
for param in &quot;$@&quot; 
do 
   echo &quot;Parameter $count: $param&quot; 
   count=$[ $count + 1 ] 
done 
# 
$  
$ ./test20.sh -a -b test1 -d test2 test3 test4 
 
Found the -a option 
Found the -b option, with value test1 
Found the -d option 
 
Parameter 1: test2 
Parameter 2: test3 
Parameter 3: test4 
$
</code></pre>
<p>现在你就拥有了一个能在所有shell脚本中使用的全功能命令行选项和参数处理工具。</p>
<h2 id="5-将选项标准化">5. 将选项标准化</h2>
<p>在创建shell脚本时，显然可以控制具体怎么做。你完全可以决定用哪些字母选项以及它们的用法。</p>
<p>表14-1显示了Linux中用到的一些命令行选项的常用含义。</p>
<p><img src="https://s1.ax2x.com/2018/08/10/55Cxz3.png" alt="55Cxz3.png"></p>
<p>通过学习本书时遇到的各种bash命令，你大概已经知道这些选项中大部分的含义了。如果你的选项也采用同样的含义，这样用户在使用你的脚本时就不用去查手册了。</p>
<h2 id="6-获得用户输入">6. 获得用户输入</h2>
<p>尽管命令行选项和参数是从脚本用户处获得输入的一种重要方式，但有时脚本的交互性还需要更强一些。比如你想要在脚本运行时问个问题，并等待运行脚本的人来回答。bash shell为此提供了read命令。</p>
<h4 id="61-基本的读取">6.1 基本的读取</h4>
<p>read命令从标准输入（键盘）或另一个文件描述符中接受输入。在收到输入后，read命令会将数据放进一个变量。下面是read命令的最简单用法。</p>
<pre><code class="language-sh">$ cat test21.sh 
#!/bin/bash 
# testing the read command 
# 
echo -n &quot;Enter your name: &quot; 
read name 
echo &quot;Hello $name, welcome to my program. &quot; 
# 
$  
$ ./test21.sh 
Enter your name: Rich Blum 
Hello Rich Blum, welcome to my program. 
$ 
</code></pre>
<p>相当简单。注意，<strong>生成提示的echo命令使用了-n选项。该选项不会在字符串末尾输出换行符，允许脚本用户紧跟其后输入数据，而不是下一行</strong>。这让脚本看起来更像表单。</p>
<p>实际上，read命令包含了-p选项，允许你直接在read命令行指定提示符。</p>
<pre><code class="language-sh">$ cat test22.sh 
#!/bin/bash 
# testing the read -p option 
# 
read -p &quot;Please enter your age: &quot; age 
days=$[ $age * 365 ] 
echo &quot;That makes you over $days days old! &quot; 
# 
$  
$ ./test22.sh 
Please enter your age: 10 
That makes you over 3650 days old! 
$ 
</code></pre>
<p>你会注意到，在第一个例子中当有名字输入时，read命令会将姓和名保存在同一个变量中。read命令会将提示符后输入的所有数据分配给单个变量，要么你就指定多个变量。输入的每个数据值都会分配给变量列表中的下一个变量。如果变量数量不够，剩下的数据就全部分配给最后一个变量。</p>
<pre><code class="language-sh">$ cat test23.sh 
#!/bin/bash 

# entering multiple variables 
# 
read -p &quot;Enter your name: &quot; first last 
echo &quot;Checking data for $last, $first…&quot; 
$  
$ ./test23.sh 
Enter your name: Rich Blum 
Checking data for Blum, Rich... 
$ 
</code></pre>
<p>也可以在read命令行中不指定变量。如果是这样，read命令会将它收到的任何数据都放进<strong>特殊环境变量REPLY中</strong>。</p>
<pre><code class="language-sh">$ cat test24.sh 
#!/bin/bash 
# Testing the REPLY Environment variable 
# 
read -p &quot;Enter your name: &quot; 
echo 
echo Hello $REPLY, welcome to my program. 
# 
$  
$ ./test24.sh 
Enter your name: Christine 
 
Hello Christine, welcome to my program. 
$ 
</code></pre>
<p>REPLY环境变量会保存输入的所有数据，可以在shell脚本中像其他变量一样使用。</p>
<h4 id="62-超时">6.2 超时</h4>
<p>使用read命令时要当心。脚本很可能会一直苦等着脚本用户的输入。如果不管是否有数据输入，脚本都必须继续执行，你可以用-t选项来指定一个计时器。-t选项指定了read命令等待输入的秒数。当计时器过期后，read命令会返回一个非零退出状态码。</p>
<pre><code class="language-sh">$ cat test25.sh 
#!/bin/bash 
# timing the data entry 
# 
if read -t 5 -p &quot;Please enter your name: &quot; name 
then 
   echo &quot;Hello $name, welcome to my script&quot; 
else 
   echo 
   echo &quot;Sorry, too slow! &quot; 
fi 
$ 

$ ./test25.sh 
Please enter your name: Rich 
Hello Rich, welcome to my script 
$  

$ ./test25.sh 
Please enter your name: 
Sorry, too slow! 
$ 
</code></pre>
<p>如果计时器过期，read命令会以非零退出状态码退出，可以使用如if-then语句或while循环这种标准的结构化语句来理清所发生的具体情况。在本例中，计时器过期时，if语句不成立，shell会执行else部分的命令。</p>
<p>也可以不对输入过程计时，而是让read命令来统计输入的字符数。当输入的字符达到预设的字符数时，就自动退出，将输入的数据赋给变量。</p>
<pre><code class="language-sh">$ cat test26.sh 
#!/bin/bash 
# getting just one character of input 
# 
read -n1 -p &quot;Do you want to continue [Y/N]? &quot; answer 
case $answer in 
Y | y) echo 
       echo &quot;fine, continue on…&quot;;; 
N | n) echo 
       echo OK, goodbye 
       exit;; 
esac 
echo &quot;This is the end of the script&quot; 
$  
$ ./test26.sh 
Do you want to continue [Y/N]? Y 
fine, continue on… 
This is the end of the script 
$  
$ ./test26.sh 
Do you want to continue [Y/N]? n 
OK, goodbye 
$ 
</code></pre>
<p>本例中将-n选项和值1一起使用，告诉read命令在接受单个字符后退出。只要按下单个字符回答后，read命令就会接受输入并将它传给变量，无需按回车键。</p>
<h4 id="63-隐藏方式读取">6.3 隐藏方式读取</h4>
<p>有时你需要从脚本用户处得到输入，但又在屏幕上显示输入信息。其中典型的例子就是输入的密码，但除此之外还有很多其他需要隐藏的数据类型。</p>
<p>-s选项可以避免在read命令中输入的数据出现在显示器上（实际上，数据会被显示，只是read命令会将文本颜色设成跟背景色一样）。这里有个在脚本中使用-s选项的例子。</p>
<pre><code class="language-sh">$ cat test27.sh 
#!/bin/bash 
# hiding input data from the monitor 
# 
read -s -p &quot;Enter your password: &quot; pass 
echo 
echo &quot;Is your password really $pass? &quot; 
$  
$ ./test27.sh 
Enter your password: 
Is your password really T3st1ng? 
$
</code></pre>
<p>输入提示符输入的数据不会出现在屏幕上，但会赋给变量，以便在脚本中使用。</p>
<h4 id="64-从文件中读取">6.4 从文件中读取</h4>
<p>最后，也可以用read命令来读取Linux系统上文件里保存的数据。每次调用read命令，它都会从文件中读取一行文本。当文件中再没有内容时，read命令会退出并返回非零退出状态码。</p>
<p>其中最难的部分是将文件中的数据传给read命令。最常见的方法是对文件使用cat命令，将结果通过管道直接传给含有read命令的while命令。下面的例子说明怎么处理。</p>
<pre><code class="language-sh">$ cat test28.sh  
#!/bin/bash 
# reading data from a file 
# 
count=1 
cat test | while read line 
do 
   echo &quot;Line $count: $line&quot; 
   count=$[ $count + 1] 
done 
echo &quot;Finished processing the file&quot; 
$  
$ cat test 
The quick brown dog jumps over the lazy fox. 
This is a test, this is only a test. 
O Romeo, Romeo! Wherefore art thou Romeo? 
$  
$ ./test28.sh 
Line 1: The quick brown dog jumps over the lazy fox. 
Line 2: This is a test, this is only a test. 
Line 3: O Romeo, Romeo! Wherefore art thou Romeo? 
Finished processing the file 
$ 
</code></pre>
<p>while循环会持续通过read命令处理文件中的行，直到read命令以非零退出状态码退出。</p>
<h2 id="7-小结">7. 小结</h2>
<p>本章描述了3种不同的方法来从脚本用户处获得数据。命令行参数允许用户运行脚本时直接从命令行输入数据。脚本通过位置参数来取回命令行参数并将它们赋给变量。</p>
<p>shift命令通过对位置参数进行轮转的方式来操作命令行参数。就算不知道有多少个参数，这个命令也可以让你轻松遍历参数。</p>
<p>有三个特殊变量可以用来处理命令行参数。shell会将$#变量设为命令行输入的参数总数。$*变量会将所有参数保存为一个字符串。$@变量将所有变量都保存为单独的词。这些变量在处理长参数列表时非常有用。</p>
<p>除了参数外，脚本用户还可以用命令行选项来给脚本传递信息。命令行选项是前面带有单破折线的单个字母。可以给不同的选项赋值，从而改变脚本的行为。</p>
<p>bash shell提供了三种方式来处理命令行选项。</p>
<p>第一种方式是将它们像命令行参数一样处理。可以利用位置参数变量来遍历选项，在每个选项出现在命令行上时处理它。</p>
<p>另一种处理命令行选项的方式是用getopt命令。该命令会将命令行选项和参数转换成可以在脚本中处理的标准格式。getopt命令允许你指定将哪些字母识别成选项以及哪些选项需要额外的参数值。getopt命令会处理标准的命令行参数并按正确顺序输出选项和参数。</p>
<p>处理命令行选项的最后一种方法是通过getopts命令（注意是复数）。getopts命令提供了处理命令行参数的高级功能。它支持多值的参数，能够识别脚本未定义的选项。</p>
<p>从脚本用户处获得数据的一种交互方法是read命令。read命令支持脚本向用户提问并等待。read命令会将脚本用户输入的数据赋给一个或多个变量，你在脚本中可以使用它们。</p>
<p>read命令有一些选项支持定制脚本的输入数据，比如隐藏输入数据选项、超时选项以及要求输入特定数目字符的选项。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[shell语言脚本构建3-更多的结构化命令]]></title>
        <id>https://wangxf133.github.io/post/shell-yu-yan-jiao-ben-gou-jian-3-geng-duo-de-jie-gou-hua-ming-ling</id>
        <link href="https://wangxf133.github.io/post/shell-yu-yan-jiao-ben-gou-jian-3-geng-duo-de-jie-gou-hua-ming-ling">
        </link>
        <updated>2019-03-27T11:39:27.000Z</updated>
        <content type="html"><![CDATA[<!--More-->
<p>继续学习能够控制shell脚本流程的结构化命令。了解如何重复一些过程和命令，也就是循环执行一组命令直至达到了某个特定条件。本节将会讨论和演示bash shell的循环命令for、while和until。</p>
<h2 id="1for命令">1.for命令</h2>
<p>重复执行一系列命令在编程中很常见。通常你需要重复一组命令直至达到某个特定条件，比如处理某个目录下的所有文件、系统上的所有用户或是某个文本文件中的所有行。</p>
<p>bash shell提供了for命令，允许你创建一个遍历一系列值的循环。每次迭代都使用其中一个值来执行已定义好的一组命令。下面是bash shell中for命令的基本格式。</p>
<pre><code class="language-sh">for var in list 
do 
    commands 
done 
</code></pre>
<p>在list参数中，你需要提供迭代中要用到的一系列值。可以通过几种不同的方法指定列表中的值。</p>
<p>在每次迭代中，变量var会包含列表中的当前值。第一次迭代会使用列表中的第一个值，第二次迭代使用第二个值，以此类推，直到列表中的所有值都过一遍。</p>
<p>在do和done语句之间输入的命令可以是一条或多条标准的bash shell命令。在这些命令中，$var变量包含着这次迭代对应的当前列表项中的值。</p>
<h4 id="11读取列表中的值">1.1读取列表中的值</h4>
<p>for命令最基本的用法就是遍历for命令自身所定义的一系列值。</p>
<pre><code class="language-sh">#!/bin/bash 
# basic for command 
 
for test in Alabama Alaska Arizona Arkansas California Colorado 
do 
    echo The next state is $test 
done 
</code></pre>
<p>和</p>
<pre><code class="language-sh">#!/bin/bash 
# basic for command 
 
for test in Alabama Alaska Arizona Arkansas California Colorado 
do 
    echo &quot;The next state is $test&quot; 
done 
</code></pre>
<p>这两种写法得到的结果是一样的</p>
<p>得到的结果：</p>
<pre><code class="language-sh">$sh test.sh
The next state is Alabama
The next state is Alaska
The next state is Arizona
The next state is Arkansas
The next state is California
The next state is Colorado
</code></pre>
<p>每次for命令遍历值列表，它都会将列表中的下个值赋给<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mi>e</mi><mi>s</mi><mi>t</mi><mi mathvariant="normal">变</mi><mi mathvariant="normal">量</mi><mi mathvariant="normal">。</mi></mrow><annotation encoding="application/x-tex">test变量。</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord cjk_fallback">变</span><span class="mord cjk_fallback">量</span><span class="mord cjk_fallback">。</span></span></span></span>test变量可以像for命令语句中的其他脚本变量一样使用。在最后一次迭代后，$test变量的值会在shell脚本的剩余<br>
部分一直保持有效。它会一直保持最后一次迭代的值（除非你修改了它）。</p>
<pre><code class="language-sh">$ cat test1b 
#!/bin/bash 
# testing the for variable after the looping 
 
for test in Alabama Alaska Arizona Arkansas California Colorado 
do 
   echo &quot;The next state is $test&quot; 
done 
echo &quot;The last state we visited was $test&quot; 
test=Connecticut 
echo &quot;Wait, now we're visiting $test&quot; 
$
$

$sh test1b.sh
The next state is Alabama
The next state is Alaska
The next state is Arizona
The next state is Arkansas
The next state is California
The next state is Colorado
The last state we visited was Colorado
Wait, now we're visiting Connecticut
</code></pre>
<p>$test变量保持了其值，也允许我们修改它的值，并在for命令循环之外跟其他变量一样使用。</p>
<h4 id="12读取列表中的复杂值">1.2读取列表中的复杂值</h4>
<p>事情并不会总像你在for循环中看到的那么简单。有时会遇到难处理的数据。下面是给shell脚本程序员带来麻烦的典型例子。</p>
<pre><code class="language-sh">$ cat badtest1 
#!/bin/bash 
# another example of how not to use the for command 
 
for test in I don't know if this'll work 
do 
    echo &quot;word:$test&quot; 
done 


$ ./badtest1 
word:I 
word:dont know if thisll 
word:work 
$
</code></pre>
<p>真麻烦。shell看到了列表值中的单引号并尝试使用它们来定义一个单独的数据值，这真是把事情搞得一团糟。</p>
<p>有两种办法可解决这个问题：</p>
<blockquote>
<ol>
<li>使用转义字符（反斜线）来将单引号转义；</li>
<li>使用双引号来定义用到单引号的值。</li>
</ol>
</blockquote>
<p>这两种解决方法并没有什么出奇之处，但都能解决这个问题。</p>
<pre><code class="language-sh">$ cat test2 
#!/bin/bash 
# another example of how not to use the for command 
 
for test in I don\'t know if &quot;this'll&quot; work 
do 
    echo &quot;word:$test&quot; 
done 


$ ./test2 
word:I 
word:don't 
word:know 
word:if 
word:this'll 
word:work 
$ 
</code></pre>
<p>在第一个有问题的地方添加了反斜线字符来转义don't中的单引号。在第二个有问题的地方将this'll用双引号圈起来。两种方法都能正常辨别出这个值。</p>
<p>你可能遇到的另一个问题是有多个词的值。<strong>记住，for循环假定每个值都是用空格分割的</strong>。如果有包含空格的数据值，你就陷入麻烦了。</p>
<pre><code class="language-sh">$ cat badtest2 
#!/bin/bash 
# another example of how not to use the for command 
 
for test in Nevada New Hampshire New Mexico New York North Carolina 
do 
    echo &quot;Now going to $test&quot; 
done 
$ ./badtest1 
Now going to Nevada 
Now going to New 
Now going to Hampshire 
Now going to New 
Now going to Mexico 
Now going to New 
Now going to York 
Now going to North 
Now going to Carolina 
$
</code></pre>
<p>这不是我们想要的结果。for命令用空格来划分列表中的每个值。如果在单独的数据值中有空格，就必须用双引号将这些值圈起来。</p>
<pre><code class="language-sh">$ cat test3 
#!/bin/bash 
# an example of how to properly define values 
 
for test in Nevada &quot;New Hampshire&quot; &quot;New Mexico&quot; &quot;New York&quot; 
do 
    echo &quot;Now going to $test&quot; 
done 
$ ./test3 
Now going to Nevada 
Now going to New Hampshire 
Now going to New Mexico 
Now going to New York 
$ 
</code></pre>
<p>现在for命令可以正确区分不同值了。另外要注意的是，在某个值两边使用双引号时，shell并不会将双引号当成值的一部分。</p>
<h4 id="13从变量读取列表">1.3从变量读取列表</h4>
<p>通常shell脚本遇到的情况是，你将一系列值都集中存储在了一个变量中，然后需要遍历变量中的整个列表。也可以通过for命令完成这个任务。</p>
<pre><code class="language-sh">$ cat test4 
#!/bin/bash 
# using a variable to hold the list 
 
list=&quot;Alabama Alaska Arizona Arkansas Colorado&quot; 
list=$list&quot; Connecticut&quot;

for state in $list 
do 
    echo &quot;Have you ever visited $state?&quot; 
done 
$ ./test4 
Have you ever visited Alabama? 
Have you ever visited Alaska? 
Have you ever visited Arizona? 
Have you ever visited Arkansas? 
Have you ever visited Colorado? 
Have you ever visited Connecticut? 
$ 

</code></pre>
<p>这个$list变量包含了用于迭代的标准文本值列表。注意，代码还是用了另一个赋值语句向$list变量包含的已有列表中添加（或者说是拼接）了一个值。这是向变量中存储的已有文本字符串尾部添加文本的一个常用方法。</p>
<h4 id="14从命令读取值">1.4从命令读取值</h4>
<p>生成列表中所需值的另外一个途径就是使用命令的输出。可以用命令替换来执行任何能产生输出的命令，然后在for命令中使用该命令的输出。</p>
<pre><code class="language-sh">$ cat test5 
#!/bin/bash 
# reading values from a file 
 
file=&quot;states&quot; 
 
for state in $(cat $file) 
do 
    echo &quot;Visit beautiful $state&quot; 
done 


$ cat states 
Alabama 
Alaska 
Arizona 
Arkansas 
Colorado 
Connecticut 
Delaware 
Florida 
Georgia 


$ ./test5 
Visit beautiful Alabama 
Visit beautiful Alaska 
Visit beautiful Arizona 
Visit beautiful Arkansas 
Visit beautiful Colorado 
Visit beautiful Connecticut 
Visit beautiful Delaware 
Visit beautiful Florida 
Visit beautiful Georgia 
$ 


如果
$ cat states
Alabama wangxiaofei
Alaska
Arizona
Arkansas
Colorado
Connecticut
Delaware
Florida
Georgia

$sh test5.sh
Visit beautiful Alabama
Visit beautiful wangxiaofei
Visit beautiful Alaska
Visit beautiful Arizona
Visit beautiful Arkansas
Visit beautiful Colorado
Visit beautiful Connecticut
Visit beautiful Delaware
Visit beautiful Florida
Visit beautiful Georgia
</code></pre>
<p>这个例子在命令替换中使用了cat命令来输出文件states的内容。你会注意到states文件中每一行有一个州，而不是通过空格分隔的。for命令仍然以每次一行的方式遍历了cat命令的输出，假定每个州都是在单独的一行上。但这并没有解决数据中有空格的问题。如果你列出了一个名字中有空格的州，for命令仍然会将每个单词当作单独的值。这是有原因的，下一节我们将会了解。</p>
<h4 id="15更改字段分隔符-懂了但是还没运行成功仍需找bug">1.5更改字段分隔符 (懂了，但是还没运行成功，仍需找bug)</h4>
<p>造成这个问题的原因是特殊的环境变量IFS，叫作内部字段分隔符（internal field separator）。IFS环境变量定义了bash shell用作字段分隔符的一系列字符。默认情况下，bash shell会将下列字符当作字段分隔符：</p>
<ul class="contains-task-list">
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-917660"><label class="task-list-item-label" for="task-item-917660"> 空格</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-8441912"><label class="task-list-item-label" for="task-item-8441912"> 制表符</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-274064"><label class="task-list-item-label" for="task-item-274064"> 换行符</label></li>
</ul>
<p>如果bash shell在数据中看到了这些字符中的任意一个，它就会假定这表明了列表中一个新数据字段的开始。在处理可能含有空格的数据（比如文件名）时，这会非常麻烦，就像你在上一个脚本示例中看到的。</p>
<p>要解决这个问题，可以在shell脚本中临时更改IFS环境变量的值来限制被bash shell当作字段分隔符的字符。例如，如果你想修改IFS的值，使其只能识别换行符，那就必须这么做：</p>
<pre><code>IFS=$'\n' 
</code></pre>
<p>将这个语句加入到脚本中，告诉bash shell在数据值中忽略空格和制表符。对前一个脚本使用这种方法，将获得如下输出。</p>
<pre><code class="language-sh">$ cat test5b 
#!/bin/bash 
# reading values from a file 
 
file=&quot;states&quot; 
 
IFS=$'\n' 
for state in $(cat $file) 
do 
    echo &quot;Visit beautiful $state&quot; 
done 

$ ./test5b 
Visit beautiful Alabama 
Visit beautiful Alaska 
Visit beautiful Arizona 
Visit beautiful Arkansas 
Visit beautiful Colorado 
Visit beautiful Connecticut 
Visit beautiful Delaware 
Visit beautiful Florida 
Visit beautiful Georgia 
Visit beautiful New York 
Visit beautiful New Hampshire 
Visit beautiful North Carolina
</code></pre>
<p>现在，shell脚本旧能够使用列表中含有空格的值了。</p>
<hr>
<p><img src="https://s1.ax2x.com/2018/08/08/554BEu.png" alt="554BEu.png"></p>
<hr>
<p>还有其他一些IFS环境变量的绝妙用法。假定你要遍历一个文件中用冒号分隔的值（比如在/etc/passwd文件中）。你要做的就是将IFS的值设为冒号。</p>
<pre><code>IFS=:
</code></pre>
<p>如果要指定多个IFS字符，只要将它们在赋值行串起来就行。</p>
<pre><code>IFS=$'\n':;&quot;
</code></pre>
<p>这个赋值会将换行符、冒号、分号和双引号作为字段分隔符。如何使用IFS字符解析数据没有任何限制。</p>
<h4 id="用通配符读取目录">用通配符读取目录</h4>
<p>最后，可以用for命令来自动遍历目录中的文件。进行此操作时，必须在文件名或路径名中使用通配符。它会强制shell使用文件扩展匹配。文件扩展匹配是生成匹配指定通配符的文件名或路径名的过程。</p>
<p>如果不知道所有的文件名，这个特性在处理目录中的文件时就非常好用。</p>
<pre><code class="language-sh">$ cat test6 
#!/bin/bash 
# iterate through all the files in a directory 
 
for file in /mnt/d/shell/13/* 
do 
 
    if [ -d &quot;$file&quot; ] 
    then 
       echo &quot;$file is a directory&quot; 
    elif [ -f &quot;$file&quot; ] 
    then 
       echo &quot;$file is a file&quot; 
    fi 
done 


[xiaofei@DESKTOP-U55QOF8 13]$sh test6.sh
/mnt/d/shell/13/states is a file
/mnt/d/shell/13/test is a directory
/mnt/d/shell/13/test.sh is a file
/mnt/d/shell/13/test1b.sh is a file
/mnt/d/shell/13/test4.sh is a file
/mnt/d/shell/13/test5.sh is a file
/mnt/d/shell/13/test5b.sh is a file
/mnt/d/shell/13/test6.sh is a file

</code></pre>
<p>for命令会遍历/home/rich/test/*输出的结果。该代码用test命令测试了每个条目（使用方括号方法），以查看它是目录（通过-d参数）还是文件（通过-f参数）</p>
<p>注意，我们在这个例子的if语句中做了一些不同的处理：</p>
<pre><code>if [ -d &quot;$file&quot; ] 
</code></pre>
<p>在Linux中，目录名和文件名中包含空格当然是合法的。要适应这种情况，应该将$file变量用双引号圈起来。如果不这么做，遇到含有空格的目录名或文件名时就会有错误产生。</p>
<pre><code>./test6: line 6: [: too many arguments 
./test6: line 9: [: too many arguments
</code></pre>
<p>在test命令中，bash shell会将额外的单词当作参数，进而造成错误。</p>
<p>也可以在for命令中列出多个目录通配符，将目录查找和列表合并进同一个for语句。</p>
<pre><code class="language-sh">$ cat test7 
#!/bin/bash 
# iterating through multiple directories 
 
for file in /home/rich/.b* /home/rich/badtest 
do 
    if [ -d &quot;$file&quot; ] 
    then 
       echo &quot;$file is a directory&quot; 
    elif [ -f &quot;$file&quot; ] 
    then 
       echo &quot;$file is a file&quot; 
    else 
       echo &quot;$file doesn't exist&quot; 
    fi 
done

$ sh test7 
/home/rich/.backup.timestamp is a file 
/home/rich/.bash_history is a file 
/home/rich/.bash_logout is a file 
/home/rich/.bash_profile is a file 
/home/rich/.bashrc is a file 
/home/rich/badtest doesn't exist 
$ 
</code></pre>
<p>for语句首先使用了文件扩展匹配来遍历通配符生成的文件列表，然后它会遍历列表中的下一个文件。可以将任意多的通配符放进列表中。</p>
<p><img src="https://s1.ax2x.com/2018/08/08/554mlq.png" alt="554mlq.png"></p>
<h2 id="2c-语言风格的-for命令">2.C 语言风格的 for命令</h2>
<p>如果你从事过C语言编程，可能会对bash shell中for命令的工作方式有点惊奇。在C语言中，for循环通常定义一个变量，然后这个变量会在每次迭代时自动改变。通常程序员会将这个变量用作计数器，并在每次迭代中让计数器增一或减一。bash的for命令也提供了这个功能。本节将会告诉你如何在bash shell脚本中使用C语言风格的for命令。</p>
<h4 id="21-c语言的-for命令">2.1 C语言的 for命令</h4>
<p>C语言的for命令有一个用来指明变量的特定方法，一个必须保持成立才能继续迭代的条件，以及另一个在每个迭代中改变变量的方法。当指定的条件不成立时，for循环就会停止。条件等式通过标准的数学符号定义。比如，考虑下面的C语言代码:</p>
<pre><code class="language-sh">for (i = 0; i &lt; 10; i++) 
{ 
    printf(&quot;The next number is %d\n&quot;, i); 
} 
</code></pre>
<p>这段代码产生了一个简单的迭代循环，其中变量i作为计数器。第一部分将一个默认值赋给该变量。中间的部分定义了循环重复的条件。当定义的条件不成立时，for循环就停止迭代。最后一部分定义了迭代的过程。在每次迭代之后，最后一部分中定义的表达式会被执行。在本例中，i变量会在每次迭代后增一。</p>
<p>bash shell也支持一种for循环，它看起来跟C语言风格的for循环类似，但有一些细微的不同，其中包括一些让shell脚本程序员困惑的东西。以下是bash中C语言风格的for循环的基本格式。</p>
<pre><code>for (( variable assignment ; condition ; iteration process )) 
</code></pre>
<p>C语言风格的for循环的格式会让bash shell脚本程序员摸不着头脑，因为它使用了C语言风格的变量引用方式而不是shell风格的变量引用方式。C语言风格的for命令看起来如下。</p>
<pre><code>for (( a = 1; a &lt; 10; a++ )) 
</code></pre>
<p>注意，有些部分并没有遵循bash shell标准的for命令：</p>
<ul class="contains-task-list">
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-7411100"><label class="task-list-item-label" for="task-item-7411100"> 变量赋值可以有空格；</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-2162392"><label class="task-list-item-label" for="task-item-2162392"> 条件中的变量不以美元符开头；</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-2115662"><label class="task-list-item-label" for="task-item-2115662"> 迭代过程的算式未用expr命令格式。</label></li>
</ul>
<p>shell开发人员创建了这种格式以更贴切地模仿C语言风格的for命令。这虽然对C语言程序员来说很好，但也会把专家级的shell程序员弄得一头雾水。在脚本中使用C语言风格的for循环时要小心。</p>
<p>以下例子是在bash shell程序中使用C语言风格的for命令。</p>
<pre><code class="language-sh">$ cat test8 
#!/bin/bash 
# testing the C-style for loop 
 
for (( i=1; i &lt;= 10; i++ )) 
do 
    echo &quot;The next number is $i&quot; 
done 
$ ./test8 
The next number is 1 
The next number is 2 
The next number is 3 
The next number is 4 
The next number is 5 
The next number is 6 
The next number is 7 
The next number is 8 
The next number is 9 
The next number is 10 
$
</code></pre>
<p>for循环通过定义好的变量（本例中是变量i）来迭代执行这些命令。在每次迭代中，$i变量包含了for循环中赋予的值。在每次迭代后，循环的迭代过程会作用在变量上，在本例中，变量增一。</p>
<h4 id="22-使用多个变量">2.2 使用多个变量</h4>
<p>C语言风格的for命令也允许为迭代使用多个变量。循环会单独处理每个变量，你可以为每个变量定义不同的迭代过程。尽管可以使用多个变量，但你只能在for循环中定义一种条件。</p>
<pre><code>$ cat test9
#!/bin/bash 
# multiple variables 
 
for (( a=1, b=10; a &lt;= 10; a++, b-- )) 
do 
    echo &quot;$a - $b&quot; 
done 
$ ./test9 
1 - 10 
2 - 9 
3 - 8 
4 - 7 
5 - 6 
6 - 5 
7 - 4 
8 - 3 
9 - 2 
10 - 1 
$ 
</code></pre>
<p>变量a和b分别用不同的值来初始化并且定义了不同的迭代过程。循环的每次迭代在增加变量a的同时减小了变量b。</p>
<h2 id="3while命令">3.while命令</h2>
<p>while命令某种意义上是if-then语句和for循环的混杂体。while命令允许定义一个要测试的命令，然后循环执行一组命令，只要定义的测试命令返回的是退出状态码0。它会在每次迭代的一开始测试test命令。在test命令返回非零退出状态码时，while命令会停止执行那组命令。</p>
<h4 id="31-while的基本格式">3.1 while的基本格式</h4>
<p>while命令的格式是：</p>
<pre><code class="language-sh">while test command 
do 
  other commands 
done
</code></pre>
<p>while命令中定义的test command和if-then语句中的格式一模一样。可以使用任何普通的bash shell命令，或者用test命令进行条件测试，比如测试变量值。</p>
<p>while命令的关键在于所指定的test command的退出状态码必须随着循环中运行的命令而改变。如果退出状态码不发生变化， while循环就将一直不停地进行下去。</p>
<p><strong>最常见的test command的用法是用方括号来检查循环命令中用到的shell变量的值。</strong></p>
<pre><code class="language-sh">$ cat test10 
#!/bin/bash 
# while command test 
 
var1=10 
while [ $var1 -gt 0 ] 
do 
    echo $var1 
    var1=$[ $var1 - 1 ] 
done 
$ ./test10 
10 
9 
8 
7 
6 
5 
4 
3 
2 
1 
$
</code></pre>
<p>while命令定义了每次迭代时检查的测试条件：</p>
<pre><code class="language-sh">while [ $var1 -gt 0 ] 
</code></pre>
<p>只要测试条件成立，while命令就会不停地循环执行定义好的命令。在这些命令中，测试条件中用到的变量必须修改，否则就会陷入无限循环。在本例中，我们用shell算术来将变量值减一：</p>
<pre><code class="language-sh">var1=$[ $var1 - 1 ] 
</code></pre>
<p>while循环会在测试条件不再成立时停止。</p>
<h4 id="32-使用多个测试命令">3.2 使用多个测试命令</h4>
<p>while命令允许你在while语句行定义多个测试命令。只有最后一个测试命令的退出状态码会被用来决定什么时候结束循环。如果你不够小心，可能会导致一些有意思的结果。下面的例子将说明这一点。</p>
<pre><code class="language-sh">$ cat test11 
#!/bin/bash 
# testing a multicommand while loop 
 
var1=10 
 
while echo $var1 
       [ $var1 -ge 0 ] 
do 
    echo &quot;This is inside the loop&quot; 
    var1=$[ $var1 - 1 ] 
done 

$ ./test11 
10 
This is inside the loop 
9 
This is inside the loop 
8 
This is inside the loop 
7 
This is inside the loop 
6 
This is inside the loop 
5 
This is inside the loop 
4 
This is inside the loop 
3 
This is inside the loop 
2 
This is inside the loop 
1 
This is inside the loop 
0 
This is inside the loop 
-1 
$ 
</code></pre>
<p>请仔细观察本例中做了什么。while语句中定义了两个测试命令。</p>
<pre><code>while echo $var1 
      [ $var1 -ge 0 ] 
</code></pre>
<p>第一个测试简单地显示了var1变量的当前值。第二个测试用方括号来判断var1变量的值。在循环内部，echo语句会显示一条简单的消息，说明循环被执行了。注意当你运行本例时输出是如何结束的。</p>
<pre><code>This is inside the loop 
-1 
$ 
</code></pre>
<p>while循环会在var1变量等于0时执行echo语句，然后将var1变量的值减一。接下来再次执行测试命令，用于下一次迭代。echo测试命令被执行并显示了var变量的值（现在小于0了）。直到shell执行test测试命令，whle循环才会停止。</p>
<p>这说明在含有多个命令的while语句中，在每次迭代中所有的测试命令都会被执行，包括测试命令失败的最后一次迭代。要留心这种用法。另一处要留意的是该如何指定多个测试命令。注意，每个测试命令都出现在单独的一行上。</p>
<h2 id="4until命令">4.until命令</h2>
<p>until命令和while命令工作的方式完全相反。until命令要求你指定一个通常返回非零退出状态码的测试命令。只有测试命令的退出状态码不为0，bash shell才会执行循环中列出的命令。一旦测试命令返回了退出状态码0，循环就结束了。</p>
<pre><code>until test commands 
do 
    other commands 
done
</code></pre>
<p>和while命令类似，你可以在until命令语句中放入多个测试命令。只有最后一个命令的退出状态码决定了bash shell是否执行已定义的other commands。</p>
<p>下面是使用until命令的一个例子。</p>
<pre><code class="language-sh">$ cat test12 
#!/bin/bash 
# using the until command 
 
var1=100 
 
until [ $var1 -eq 0 ] 
do 
    echo $var1 
    var1=$[ $var1 - 25 ] 
done 
$ ./test12 
100 
75 
50 
25 
$
</code></pre>
<p>本例中会测试var1变量来决定until循环何时停止。只要该变量的值等于0，until命令就会停止循环。同while命令一样，在until命令中使用多个测试命令时要注意。</p>
<pre><code class="language-sh">$ cat test13 
#!/bin/bash 
# using the until command 
 
var1=100 
 
until echo $var1 
       [ $var1 -eq 0 ] 
do 
    echo Inside the loop: $var1 
    var1=$[ $var1 - 25 ] 
done 
$ ./test13 
100 
Inside the loop: 100 
75 
Inside the loop: 75 
50 
Inside the loop: 50 
25 
Inside the loop: 25 
0 
$ 
</code></pre>
<p>shell会执行指定的多个测试命令，只有在最后一个命令成立时停止。</p>
<h2 id="5嵌套循环">5.嵌套循环</h2>
<p>循环语句可以在循环内使用任意类型的命令，包括其他循环命令。这种循环叫作嵌套循环（nested loop）。注意，在使用嵌套循环时，你是在迭代中使用迭代，与命令运行的次数是乘积关系。不注意这点的话，有可能会在脚本中造成问题。</p>
<p>这里有个在for循环中嵌套for循环的简单例子。</p>
<pre><code class="language-sh">$ cat test14 
#!/bin/bash 
# nesting for loops 
 
for (( a = 1; a &lt;= 3; a++ )) 
do 
    echo &quot;Starting loop $a:&quot; 
    for (( b = 1; b &lt;= 3; b++ )) 
    do 
       echo &quot;   Inside loop: $b&quot; 
    done 
done 


$ ./test14 
Starting loop 1: 
    Inside loop: 1 
    Inside loop: 2 
    Inside loop: 3 
Starting loop 2: 
    Inside loop: 1 
    Inside loop: 2 
    Inside loop: 3 
Starting loop 3: 
    Inside loop: 1 
    Inside loop: 2 
    Inside loop: 3 
$ 
</code></pre>
<p>这个被嵌套的循环（也称为内部循环，inner loop）会在外部循环的每次迭代中遍历一次它所有的值。注意，两个循环的do和done命令没有任何差别。bash shell知道当第一个done命令执行时是指内部循环而非外部循环。</p>
<p>在混用循环命令时也一样，比如在while循环内部放置一个for循环。</p>
<pre><code class="language-sh">$ cat test15 
#!/bin/bash 
# placing a for loop inside a while loop 

var1=5 

while [ $var1 -ge 0 ] 
do 
    echo &quot;Outer loop: $var1&quot; 
    for (( var2 = 1; $var2 &lt; 3; var2++ )) 
    do 
       var3=$[ $var1 * $var2 ] 
       echo &quot;  Inner loop: $var1 * $var2 = $var3&quot; 
    done 
    var1=$[ $var1 - 1 ] 
done 


$ ./test15 
Outer loop: 5 
   Inner loop: 5 * 1 = 5 
   Inner loop: 5 * 2 = 10 
Outer loop: 4 
   Inner loop: 4 * 1 = 4 
   Inner loop: 4 * 2 = 8 
Outer loop: 3 
   Inner loop: 3 * 1 = 3 
   Inner loop: 3 * 2 = 6 
Outer loop: 2 
   Inner loop: 2 * 1 = 2 
   Inner loop: 2 * 2 = 4 
Outer loop: 1 
   Inner loop: 1 * 1 = 1 
   Inner loop: 1 * 2 = 2 
Outer loop: 0 
   Inner loop: 0 * 1 = 0 
   Inner loop: 0 * 2 = 0 
$ 
</code></pre>
<p>同样，shell能够区分开内部for循环和外部while循环各自的do和done命令。</p>
<p>如果真的想挑战脑力，可以混用until和while循环。</p>
<pre><code class="language-sh">$ cat test16 
#!/bin/bash 
# using until and while loops 
 
var1=3 
 
until [ $var1 -eq 0 ] 
do 
    echo &quot;Outer loop: $var1&quot; 
    var2=1 
    while [ $var2 -lt 5 ] 
    do 
       var3=$(echo &quot;scale=4; $var1 / $var2&quot; | bc) 
       echo &quot;   Inner loop: $var1 / $var2 = $var3&quot; 
       var2=$[ $var2 + 1 ] 
    done 
    var1=$[ $var1 - 1 ] 
done 

$ ./test16 
Outer loop: 3 
    Inner loop: 3 / 1 = 3.0000 
    Inner loop: 3 / 2 = 1.5000 
    Inner loop: 3 / 3 = 1.0000 
    Inner loop: 3 / 4 = .7500 
Outer loop: 2 
    Inner loop: 2 / 1 = 2.0000 
    Inner loop: 2 / 2 = 1.0000 
    Inner loop: 2 / 3 = .6666 
    Inner loop: 2 / 4 = .5000 
Outer loop: 1 
    Inner loop: 1 / 1 = 1.0000 
    Inner loop: 1 / 2 = .5000 
    Inner loop: 1 / 3 = .3333 
    Inner loop: 1 / 4 = .2500 
$
</code></pre>
<p>外部的until循环以值3开始，并继续执行到值等于0。内部while循环以值1开始并一直执行，只要值小于5。每个循环都必须改变在测试条件中用到的值，否则循环就会无止尽进行下去。</p>
<h2 id="6循环处理文件数据">6.循环处理文件数据</h2>
<p>通常必须遍历存储在文件中的数据。这要求结合已经讲过的两种技术：</p>
<ul>
<li>使用嵌套循环</li>
<li>修改IFS环境变量</li>
</ul>
<p>通过修改IFS环境变量，就能强制for命令将文件中的每行都当成单独的一个条目来处理，即便数据中有空格也是如此。一旦从文件中提取出了单独的行，可能需要再次利用循环来提取行中的数据。<br>
典型的例子是处理/etc/passwd文件中的数据。这要求你逐行遍历/etc/passwd文件，并将IFS变量的值改成冒号，这样就能分隔开每行中的各个数据段了。</p>
<pre><code class="language-sh">#!/bin/bash
# changing the IFS value

IFS.OLD=$IFS
IFS=$'\n'
for entry in $(cat /etc/passwd)
do
    echo &quot;Values in $entry –&quot;
    IFS=:
    for value in $entry
    do
       echo &quot;   $value&quot;
    done
done
</code></pre>
<p>内部循环会解析出/etc/passwd每行中的各个值。这种方法在处理外部导入电子表格所采用的逗号分隔的数据时也很方便.</p>
<h2 id="7控制循环">7.控制循环</h2>
<p>你可能会想，一旦启动了循环，就必须苦等到循环完成所有的迭代。并不是这样的。有两个命令能帮我们控制循环内部的情况：</p>
<ul>
<li>break命令</li>
<li>continue命令</li>
</ul>
<p>每个命令在如何控制循环的执行方面有不同的用法。下面几节将介绍如何使用这些命令来控制循环。</p>
<h4 id="71-break命令">7.1 break命令</h4>
<p>break命令是退出循环的一个简单方法。可以用break命令来退出任意类型的循环，包括while和until循环。</p>
<p>有几种情况可以使用break命令，本节将介绍这些方法。</p>
<ol>
<li>跳出单个循环</li>
</ol>
<p>在shell执行break命令时，它会尝试跳出当前正在执行的循环。</p>
<pre><code class="language-sh">$ cat test17 
#!/bin/bash 
# breaking out of a for loop 
 
for var1 in 1 2 3 4 5 6 7 8 9 10 
do 
   if [ $var1 -eq 5 ] 
   then 
      break 
   fi 
   echo &quot;Iteration number: $var1&quot; 
done 
echo &quot;The for loop is completed&quot; 


$ ./test17 
Iteration number: 1 
Iteration number: 2 
Iteration number: 3 
Iteration number: 4 
The for loop is completed 
$ 
</code></pre>
<p>for循环通常都会遍历列表中指定的所有值。但当满足if-then的条件时，shell会执行break命令，停止for循环。</p>
<p>这种方法同样适用于while和until循环。</p>
<pre><code class="language-sh">$ cat test18 
#!/bin/bash 
# breaking out of a while loop 
 
var1=1 
 
while [ $var1 -lt 10 ] 
do 
   if [ $var1 -eq 5 ] 
   then 
      break 
   fi 
   echo &quot;Iteration: $var1&quot; 
   var1=$[ $var1 + 1 ] 
done 
echo &quot;The while loop is completed&quot; 


$ ./test18 
Iteration: 1 
Iteration: 2 
Iteration: 3 
Iteration: 4 
The while loop is completed 
$ 
</code></pre>
<p>while循环会在if-then的条件满足时执行break命令，终止。</p>
<ol start="2">
<li>跳出内部循环</li>
</ol>
<p>在处理多个循环时，break命令会自动终止你所在的最内层的循环。</p>
<pre><code class="language-sh">$ cat test19 
#!/bin/bash 
# breaking out of an inner loop 
 
for (( a = 1; a &lt; 4; a++ )) 
do 
   echo &quot;Outer loop: $a&quot; 
   for (( b = 1; b &lt; 100; b++ )) 
   do 
      if [ $b -eq 5 ] 
      then 
         break 
      fi 
      echo &quot;   Inner loop: $b&quot; 
   done 
done 



$ ./test19 
Outer loop: 1 
   Inner loop: 1 
   Inner loop: 2 
   Inner loop: 3 
   Inner loop: 4 
Outer loop: 2 
   Inner loop: 1 
   Inner loop: 2 
   Inner loop: 3 
   Inner loop: 4 
Outer loop: 3 
   Inner loop: 1 
   Inner loop: 2 
   Inner loop: 3 
   Inner loop: 4 
$ 

</code></pre>
<p>内部循环里的for语句指明当变量b等于100时停止迭代。但内部循环的if-then语句指明当变量b的值等于5时执行break命令。注意，即使内部循环通过break命令终止了，外部循环依然继续执行。</p>
<ol start="3">
<li>跳出外部循环</li>
</ol>
<p>有时你在内部循环，但需要停止外部循环。break命令接受单个命令行参数值：</p>
<pre><code>break n 
</code></pre>
<p>其中n指定了要跳出的循环层级。默认情况下，n为1，表明跳出的是当前的循环。如果你将n设为2，break命令就会停止下一级的外部循环。</p>
<pre><code class="language-sh">$ cat test20 
#!/bin/bash 
# breaking out of an outer loop 

for (( a = 1; a &lt; 4; a++ )) 
do 
  echo &quot;Outer loop: $a&quot; 
  for (( b = 1; b &lt; 100; b++ )) 
  do 
     if [ $b -gt 4 ] 
     then 
        break 2 
     fi 
     echo &quot;   Inner loop: $b&quot; 
  done 
done


$ ./test20 
Outer loop: 1 
  Inner loop: 1 
  Inner loop: 2 
  Inner loop: 3 
  Inner loop: 4 
</code></pre>
<p>注意，当shell执行了break命令后，外部循环就停止了。</p>
<h4 id="72-continue命令">7.2 continue命令</h4>
<p>continue命令可以提前中止某次循环中的命令，但并不会完全终止整个循环。可以在循环内部设置shell不执行命令的条件。这里有个在for循环中使用continue命令的简单例子。</p>
<pre><code class="language-sh">
$ cat test21 
#!/bin/bash 
# using the continue command 

for (( var1 = 1; var1 &lt; 15; var1++ )) 
do 
   if [ $var1 -gt 5 ] &amp;&amp; [ $var1 -lt 10 ] 
   then 
      continue 
   fi 
   echo &quot;Iteration number: $var1&quot; 
done 

$ ./test21 
Iteration number: 1 
Iteration number: 2 
Iteration number: 3 
Iteration number: 4 
Iteration number: 5 
Iteration number: 10 
Iteration number: 11 
Iteration number: 12 
Iteration number: 13 
Iteration number: 14 
$ 
</code></pre>
<p>当if-then语句的条件被满足时（值大于5且小于10），shell会执行continue命令，跳过此次循环中剩余的命令，但整个循环还会继续。当if-then的条件不再被满足时，一切又回到正轨。</p>
<p>也可以在while和until循环中使用continue命令，但要特别小心。记住，当shell执行continue命令时，它会跳过剩余的命令。如果你在其中某个条件里对测试条件变量进行增值，问题就会出现。</p>
<pre><code class="language-sh">$ cat badtest3 
#!/bin/bash 
# improperly using the continue command in a while loop 
 
var1=0 
 
while echo &quot;while iteration: $var1&quot; 
      [ $var1 -lt 15 ] 
do 
   if [ $var1 -gt 5 ] &amp;&amp; [ $var1 -lt 10 ] 
   then 
      continue 
   fi 
   echo &quot;   Inside iteration number: $var1&quot; 
   var1=$[ $var1 + 1 ] 
done 


$ ./badtest3 | more 
while iteration: 0 
   Inside iteration number: 0 
while iteration: 1 
   Inside iteration number: 1 
while iteration: 2 
   Inside iteration number: 2 
while iteration: 3 
   Inside iteration number: 3 
while iteration: 4 
   Inside iteration number: 4 
while iteration: 5 
   Inside iteration number: 5 
while iteration: 6 
while iteration: 6 
while iteration: 6 
while iteration: 6 
while iteration: 6 
while iteration: 6 
while iteration: 6 
while iteration: 6 
while iteration: 6 
while iteration: 6 
while iteration: 6 
$ 

</code></pre>
<p>你得确保将脚本的输出重定向到了more命令，这样才能停止输出。在if-then的条件成立之前，所有一切看起来都很正常，然后shell执行了continue命令。当shell执行continue命令时，它跳过了while循环中余下的命令。不幸的是，被跳过的部分正是$var1计数变量增值的地方，而这个变量又被用于while测试命令中。这意味着这个变量的值不会再变化了，从前面连续的输出显示中你也可以看出来。</p>
<p>和break命令一样，continue命令也允许通过命令行参数指定要继续执行哪一级循环：</p>
<pre><code>continue n 
</code></pre>
<p>其中n定义了要继续的循环层级。下面是继续外部for循环的一个例子。</p>
<pre><code class="language-sh">$ cat test22 
#!/bin/bash 
# continuing an outer loop 
 
for (( a = 1; a &lt;= 5; a++ )) 
do 
   echo &quot;Iteration $a:&quot; 
   for (( b = 1; b &lt; 3; b++ )) 
   do 
      if [ $a -gt 2 ] &amp;&amp; [ $a -lt 4 ] 
      then 
         continue 2 
      fi 
      var3=$[ $a * $b ] 
      echo &quot;   The result of $a * $b is $var3&quot; 
   done 
done 

$ ./test22 
Iteration 1: 
   The result of 1 * 1 is 1 
   The result of 1 * 2 is 2 
Iteration 2: 
   The result of 2 * 1 is 2 
   The result of 2 * 2 is 4 
Iteration 3: 
Iteration 4: 
   The result of 4 * 1 is 4 
   The result of 4 * 2 is 8 
Iteration 5: 
   The result of 5 * 1 is 5 
   The result of 5 * 2 is 10 
$ 
</code></pre>
<p>其中的if-then语句：</p>
<pre><code class="language-sh">if [ $a -gt 2 ] &amp;&amp; [ $a -lt 4 ] 
      then 
         continue 2 
      fi 
</code></pre>
<p>此处用continue命令来停止处理循环内的命令，但会继续处理外部循环。注意，值为3的那次迭代并没有处理任何内部循环语句，因为尽管continue命令停止了处理过程，但外部循环依然会继续。</p>
<h2 id="8-处理循环的输出">8. 处理循环的输出</h2>
<p>最后，在shell脚本中，你可以对循环的输出使用管道或进行重定向。这可以通过在done命令之后添加一个处理命令来实现。</p>
<pre><code class="language-sh">for file in /home/rich/* 
 do 
   if [ -d &quot;$file&quot; ] 
   then 
      echo &quot;$file is a directory&quot; 
   elif 
      echo &quot;$file is a file&quot; 
   fi 
done &gt; output.txt 
</code></pre>
<p>shell会将for命令的结果重定向到文件output.txt中，而不是显示在屏幕上。</p>
<p>考虑下面将for命令的输出重定向到文件的例子。</p>
<pre><code class="language-sh">$ cat test23 
#!/bin/bash 
# redirecting the for output to a file 

for (( a = 1; a &lt; 10; a++ )) 
do 
   echo &quot;The number is $a&quot; 
done &gt; test23.txt 
echo &quot;The command is finished.&quot;

$ ./test23 
The command is finished. 
$ cat test23.txt 
The number is 1 
The number is 2 
The number is 3 
The number is 4 
The number is 5 
The number is 6 
The number is 7 
The number is 8 
The number is 9 
$ 
</code></pre>
<p>shell创建了文件test23.txt并将for命令的输出重定向到这个文件。shell在for命令之后正常显示了echo语句。</p>
<p>这种方法同样适用于将循环的结果管接给另一个命令。</p>
<pre><code class="language-h">$ cat test24 
#!/bin/bash 
# piping a loop to another command 
 
for state in &quot;North Dakota&quot; Connecticut Illinois Alabama Tennessee 
do 
   echo &quot;$state is the next place to go&quot; 
done | sort 
echo &quot;This completes our travels&quot; 
$ ./test24 
Alabama is the next place to go 
Connecticut is the next place to go 
Illinois is the next place to go 
North Dakota is the next place to go 
Tennessee is the next place to go 
This completes our travels 
$
</code></pre>
<p>state值并没有在for命令列表中以特定次序列出。for命令的输出传给了sort命令，该命令会改变for命令输出结果的顺序。运行这个脚本实际上说明了结果已经在脚本内部排好序了。</p>
<h2 id="9-实例">9. 实例</h2>
<p>现在你已经看到了shell脚本中各种循环的使用方法，来看一些实际应用的例子吧。循环是对系统数据进行迭代的常用方法，无论是目录中的文件还是文件中的数据。下面的一些例子演示了如何使用简单的循环来处理数据。</p>
<h4 id="91-查找可执行文件">9.1 查找可执行文件</h4>
<p>当你从命令行中运行一个程序的时候，Linux系统会搜索一系列目录来查找对应的文件。这些目录被定义在环境变量PATH中。如果你想找出系统中有哪些可执行文件可供使用，只需要扫描PATH环境变量中所有的目录就行了。如果要徒手查找的话，就得花点时间了。不过我们可以编写一个小小的脚本，轻而易举地搞定这件事。</p>
<p>首先是创建一个for循环，对环境变量PATH中的目录进行迭代。处理的时候别忘了设置IFS分隔符。</p>
<pre><code>IFS=: 
for folder in $PATH 
do 
</code></pre>
<p>现在你已经将各个目录存放在了变量$folder中，可以使用另一个for循环来迭代特定目录中的所有文件。</p>
<pre><code>for file in $folder/* 
do 
</code></pre>
<p>最后一步是检查各个文件是否具有可执行权限，你可以使用if-then测试功能来实现。</p>
<pre><code>if [ -x $file ] 
then 
   echo &quot;   $file&quot; 
fi 
</code></pre>
<p>好了，搞定了！将这些代码片段组合成脚本就行了。</p>
<pre><code class="language-sh">$ cat test25 
#!/bin/bash 
# finding files in the PATH 
 
IFS=: 
for folder in $PATH 
do 
   echo &quot;$folder:&quot; 
   for file in $folder/* 
   do 
      if [ -x $file ] 
      then 
         echo &quot;   $file&quot; 
      fi 
   done 
done 
$ 
</code></pre>
<p>运行这段代码时，你会得到一个可以在命令行中使用的可执行文件的列表。</p>
<pre><code class="language-sh">$ ./test25 | more 
/usr/local/bin: 
/usr/bin: 
   /usr/bin/Mail 
   /usr/bin/Thunar 
   /usr/bin/X 
   /usr/bin/Xorg 
   /usr/bin/[ 
   /usr/bin/a2p 
   /usr/bin/abiword 
   /usr/bin/ac 
   /usr/bin/activation-client 
   /usr/bin/addr2line 
...
</code></pre>
<p>输出显示了在环境变量PATH所包含的所有目录中找到的全部可执行文件，数量真是不少！</p>
<h4 id="92-创建多个用户账户">9.2 创建多个用户账户</h4>
<p>shell脚本的目标是让系统管理员过得更轻松。如果你碰巧工作在一个拥有大量用户的环境最烦人的工作之一就是创建新用户账户。好在可以使用while循环来降低工作的难度。</p>
<p>你不用为每个需要创建的新用户账户手动输入useradd命令，而是可以将需要添加的新用户账户放在一个文本文件中，然后创建一个简单的脚本进行处理。这个文本文件的格式如下：</p>
<pre><code>userid,user name
</code></pre>
<p>第一个条目是你为新用户账户所选用的用户ID。第二个条目是用户的全名。两个值之间使用逗号分隔，这样就形成了一种名为逗号分隔值的文件格式（或者是.csv）。这种文件格式在电子表格中极其常见，所以你可以轻松地在电子表格程序中创建用户账户列表，然后将其保存成.csv格式，以备shell脚本读取及处理。</p>
<p>要读取文件中的数据，得用上一点shell脚本编程技巧。我们将IFS分隔符设置成逗号，并将其放入while语句的条件测试部分。然后使用read命令读取文件中的各行。实现代码如下：</p>
<pre><code>hile IFS=’,’ read –r userid name  
</code></pre>
<p>read命令会自动读取.csv文本文件的下一行内容，所以不需要专门再写一个循环来处理。当read命令返回FALSE时（也就是读取完整个文件时），while命令就会退出。</p>
<p>要想把数据从文件中送入while命令，只需在while命令尾部使用一个重定向符就可以了。</p>
<p>将各部分处理过程写成脚本如下。</p>
<pre><code class="language-sh">$ cat test26 
#!/bin/bash 
# process new user accounts 
 
input=&quot;users.csv&quot; 
while IFS=',' read -r userid name 
do 
  echo &quot;adding $userid&quot; 
  useradd -c &quot;$name&quot; -m $userid 
done &lt; &quot;$input&quot; 
$ 
</code></pre>
<p>$input变量指向数据文件，并且该变量被作为while命令的重定向数据。users.csv文件内容如下。</p>
<pre><code class="language-sh">$ cat users.csv 
rich,Richard Blum 
christine,Christine Bresnahan 
barbara,Barbara Blum 
tim,Timothy Bresnahan 
$
</code></pre>
<p>必须作为root用户才能运行这个脚本，因为useradd命令需要root权限。</p>
<pre><code class="language-sh"># ./test26 
adding rich 
adding christine 
adding barbara 
adding tim 
#
</code></pre>
<p>来看一眼/etc/passwd文件，你会发现账户已经创建好了。</p>
<pre><code class="language-sh"># tail /etc/passwd 
rich:x:1001:1001:Richard Blum:/home/rich:/bin/bash 
christine:x:1002:1002:Christine Bresnahan:/home/christine:/bin/bash 
barbara:x:1003:1003:Barbara Blum:/home/barbara:/bin/bash 
tim:x:1004:1004:Timothy Bresnahan:/home/tim:/bin/bash 
# 
</code></pre>
<p>恭喜，你已经在添加用户账户这项任务上给自己省出了大量时间！</p>
<h2 id="10-小结">10. 小结</h2>
<p>循环是编程的一部分。bash shell提供了三种可用于脚本中的循环命令。</p>
<p>for命令允许你遍历一系列的值，不管是在命令行里提供好的、包含在变量中的还是通过文件扩展匹配获得的文件名和目录名。</p>
<p>while命令使用普通命令或测试命令提供了基于命令条件的循环。只有在命令（或条件）产生退出状态码0时，while循环才会继续迭代指定的一组命令。</p>
<p>until命令也提供了迭代命令的一种方法，但它的迭代是建立在命令（或条件）产生非零退出状态码的基础上。这个特性允许你设置一个迭代结束前都必须满足的条件。</p>
<p>可以在shell脚本中对循环进行组合，生成多层循环。bash shell提供了continue和break命令，允许你根据循环内的不同值改变循环的正常流程。</p>
<p>bash shell还允许使用标准的命令重定向和管道来改变循环的输出。你可以使用重定向来将循环的输出重定向到一个文件或是另一个命令。这就为控制shell脚本执行提供了丰富的功能。</p>
<p>下一节将会讨论如何和shell脚本用户交互。shell脚本通常并不完全是自成一体的。它们需要在运行时被提供某些外部数据。下一章将讨论各种可用来向shell脚本提供实时数据的方法。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[shell语言脚本构建2-使用结构化命令]]></title>
        <id>https://wangxf133.github.io/post/shell-yu-yan-jiao-ben-gou-jian-2-shi-yong-jie-gou-hua-ming-ling</id>
        <link href="https://wangxf133.github.io/post/shell-yu-yan-jiao-ben-gou-jian-2-shi-yong-jie-gou-hua-ming-ling">
        </link>
        <updated>2019-03-27T11:37:51.000Z</updated>
        <content type="html"><![CDATA[<!--more-->
<p>许多程序要求对shell脚本中的命令施加一些逻辑流程控制。有一类命令会根据条件使脚本跳过某些命令。这样的命令通常称为结构化命令（structured command）。</p>
<p>结构化命令允许你改变程序执行的顺序。在bash shell中有不少结构化命令，我们会逐个研究。</p>
<p>本章来看一下if-then和case语句。</p>
<h2 id="使用-if-then语句">使用 if-then语句</h2>
<p>最基本的结构化命令就是if-then语句。if-then语句有如下格式。</p>
<pre><code class="language-sh">if command 
then 
    commands 
fi 
</code></pre>
<p>如果你在用其他编程语言的if-then语句，这种形式可能会让你有点困惑。在其他编程语言中，if语句之后的对象是一个等式，这个等式的求值结果为TRUE或FALSE。但bash shell的if语句并不是这么做的。<br>
bash shell的if语句会运行if后面的那个命令。如果该命令的退出状态码（参见上篇文章）是0（该命令成功运行），位于then部分的命令就会被执行。如果该命令的退出状态码是其他值，then部分的命令就不会被执行，bash shell会继续执行脚本中的下一个命令。<strong>fi语句用来表示if-then语句到此结束</strong>。</p>
<p>这里有个简单的例子可解释这个概念。</p>
<pre><code class="language-sh">$ cat test1.sh 
#!/bin/bash 
# testing the if statement 
if pwd 
then 
    echo &quot;It worked&quot; 
fi 
</code></pre>
<p>这个脚本在if行采用了pwd命令。如果命令成功结束，echo语句就会显示该文本字符串。在命令行运行该脚本时，会得到如下结果。</p>
<pre><code class="language-sh">$ sh test1.sh 
/home/Christine 
It worked

</code></pre>
<p><strong>shell执行了if行中的pwd命令。由于退出状态码是0，它就又执行了then部分的echo语句。</strong></p>
<p>另外一个例子:</p>
<pre><code class="language-sh">$ cat test2.sh 
#!/bin/bash 
# testing a bad command 
if IamNotaCommand 
then 
   echo &quot;It worked&quot; 
fi 
echo &quot;We are outside the if statement&quot; 
</code></pre>
<pre><code class="language-sh">$ sh test2.sh 
test2.sh: line 3: IamNotaCommand: command not found 
We are outside the if statement 
</code></pre>
<p>在这个例子中，我们在if语句行故意放了一个不能工作的命令。由于这是个错误的命令，所以它会产生一个非零的退出状态码，且bash shell会跳过then部分的echo语句。还要注意，运行if语句中的那个错误命令所生成的错误消息依然会显示在脚本的输出中。</p>
<blockquote>
<p>有时你可能不想看到错误信息，等以后有机会了在学习。（先挖个坑）</p>
</blockquote>
<hr>
<p>说明<br>
你可能在有些脚本中看到过if-then语句的另一种形式：</p>
<pre><code>if command; then 
 commands 
fi 
</code></pre>
<p>通过把分号放在待求值的命令尾部，就可以将then语句放在同一行上了，这样看起来更像其他编程语言中的if-then语句。</p>
<hr>
<p>在then部分，你可以使用不止一条命令。可以像在脚本中的其他地方一样在这里列出多条命令。bash shell会将这些命令当成一个块，如果if语句行的命令的退出状态值为0，所有的命令都会被执行；如果if语句行的命令的退出状态不为0，所有的命令都会被跳过。</p>
<pre><code class="language-sh">$ cat test3.sh 
#!/bin/bash 
# testing multiple commands in the then section 
# 
testuser=Christine 
# 
if grep $testuser /etc/passwd 
then 
   echo &quot;This is my first command&quot; 
   echo &quot;This is my second command&quot; 
   echo &quot;I can even put in other commands besides&quot;
   ls -a /home/$testuser/.b* 
fi 
</code></pre>
<p>if语句行使用grep命令在/etc/passwd文件中查找某个用户名当前是否在系统上使用。如果有用户使用了那个登录名，脚本会显示一些文本信息并列出该用户HOME目录的bash文件。</p>
<pre><code class="language-sh">[xiaofei@DESKTOP-U55QOF8 12]$sh test3.sh
xiaofei:x:1000:1000:,,,:/home/xiaofei:/bin/bash
This is my first command
This is my second command
I can even put in other commands besides echo:
/home/xiaofei/.bash_history  /home/xiaofei/.bashrc
/home/xiaofei/.bash_logout   /home/xiaofei/.bashrc-miniconda3.bak
</code></pre>
<p>但是，如果将testuser变量设置成一个系统上不存在的用户，则什么都不会显示。<br>
如果在这里显示的一些消息可说明这个用户名在系统中未找到，这样可能就会显得更友好。是的，可以用if-then语句的另外一个特性来做到这一点。</p>
<h2 id="if-then-else语句">if-then-else语句</h2>
<p>在if-then语句中，不管命令是否成功执行，你都只有一种选择。如果命令返回一个非零退出状态码(不正常运行)，bash shell会继续执行脚本中的下一条命令。在这种情况下，如果能够执行另一组命令就好了。这正是if-then-else语句的作用。<br>
if-then-else语句在语句中提供了另外一组命令。</p>
<pre><code>if command 
then 
   commands 
else 
   commands 
fi 
</code></pre>
<p>当if语句中的命令返回退出状态码0时，then部分中的命令会被执行，这跟普通的if-then语句一样。当if语句中的命令返回非零退出状态码时，bash shell会执行else部分中的命令。<br>
现在可以复制并修改测试脚本来加入else部分。</p>
<pre><code class="language-sh">#!/bin/bash
# testing multiple commands in the then section
#
testuser=xiaofei  
#testuser=Christine
#
if grep $testuser /etc/passwd
then
   echo &quot;The bash files for user $testuser are:&quot;
   ls -a /home/$testuser/.b*
   echo
else
   echo &quot;The user $testuser does not exist on this system.&quot;
   echo
fi
</code></pre>
<p>这样就更友好了。跟then部分一样，else部分可以包含多条命令。fi语句说明else部分结束了。</p>
<h2 id="嵌套-if">嵌套 if</h2>
<p>有时你需要检查脚本代码中的多种条件。对此，可以使用嵌套的if-then语句。<br>
要检查/etc/passwd文件中是否存在某个用户名以及该用户的目录是否尚在，可以使用嵌套的if-then语句。嵌套的if-then语句位于主if-then-else语句的else代码块中。</p>
<pre><code class="language-sh">$ ls -d /home/NoSuchUser/ 
/home/NoSuchUser/ 
$ 
$ cat test5.sh 
#!/bin/bash 
# Testing nested ifs 
# 
testuser=NoSuchUser 
# 
if grep $testuser /etc/passwd 
then 
   echo &quot;The user $testuser exists on this system.&quot; 
else 
   echo &quot;The user $testuser does not exist on this system.&quot; 
   if ls -d /home/$testuser/ 
   then 
      echo &quot;However, $testuser has a directory.&quot; 
   fi 
fi 

</code></pre>
<p>运行结果</p>
<pre><code class="language-sh">$ sh test5.sh 
The user NoSuchUser does not exist on this system. 
/home/NoSuchUser/ 
However, NoSuchUser has a directory. 
$ 
</code></pre>
<p>这个脚本准确无误地发现，尽管登录名已经从/etc/passwd中删除了，但是该用户的目录仍然存在。在脚本中使用这种嵌套if-then语句的问题在于代码不易阅读，很难理清逻辑流程。</p>
<p>可以使用else部分的另一种形式：elif。这样就不用再书写多个if-then语句了。<strong>elif使用另一个if-then语句延续else部分。</strong></p>
<pre><code class="language-sh">if command1 
then 
   commands 
elif command2 
then 
    more commands 
fi
</code></pre>
<p>elif语句行提供了另一个要测试的命令，这类似于原始的if语句行。如果elif后命令的退出状态码是0，则bash会执行第二个then语句部分的命令。使用这种嵌套方法，代码更清晰，逻辑更易懂。</p>
<pre><code class="language-sh">$ cat test5.sh 
#!/bin/bash 
# Testing nested ifs - use elif 
# 
testuser=NoSuchUser 
# 
if grep $testuser /etc/passwd 
then 
   echo &quot;The user $testuser exists on this system.&quot; 
# 
elif ls -d /home/$testuser 
then 
   echo &quot;The user $testuser does not exist on this system.&quot; 
   echo &quot;However, $testuser has a directory.&quot; 
# 
fi 
</code></pre>
<p>运行结果：</p>
<pre><code class="language-sh">$ sh test5.sh 
/home/NoSuchUser 
The user NoSuchUser does not exist on this system. 
However, NoSuchUser has a directory. 
</code></pre>
<p>甚至可以更进一步，让脚本检查拥有目录的不存在用户以及没有拥有目录的不存在用户。这可以通过在嵌套elif中加入一个else语句来实现。</p>
<pre><code class="language-sh">#!/bin/bash
# Testing nested ifs - use elif &amp; else

testuser=NoSuchUser
#testuser=xiaofei


if grep $testuser /etc/passwd
then
    echo &quot;The user $testuser exists on this system.&quot;
elif ls -d /home/$testuser
then
    echo &quot;The user $testuser does not exist on this system.&quot;
    echo &quot;However, $testuser has a directory.&quot;
else
    echo &quot;The user $testuser does not exist on this system.&quot;
    echo &quot;And, $testuser does not have a directory.&quot;
fi
</code></pre>
<p>在/home/NoSuchUser目录被删除之前，这个测试脚本执行的是elif语句，返回零值的退出状态。因此elif的then代码块中的语句得以执行。删除了/home/NoSuchUser目录之后，elif语句返回的是非零值的退出状态。这使得elif块中的else代码块得以执行。</p>
<hr>
<p>窍门:<br>
记住，在elif语句中，紧跟其后的else语句属于elif代码块。它们并不属于之前的if-then代码块。</p>
<hr>
<p>可以继续将多个elif语句串起来，形成一个大的if-then-elif嵌套组合。</p>
<pre><code class="language-sh">if command1 
then 
    command set 1 
elif command2 
then 
   command set 2 
elif command3 
then 
   command set 3 
elif command4 
then 
   command set 4 
fi 
</code></pre>
<p>每块命令都会根据命令是否会返回退出状态码0来执行。记住，bash shell会依次执行if语句，只有第一个返回退出状态码0的语句中的then部分会被执行。</p>
<p>尽管使用了elif语句的代码看起来更清晰，但是脚本的逻辑仍然会让人犯晕。在后面中你会看到如何使用case命令代替if-then语句的大量嵌套。</p>
<h2 id="test命令">test命令</h2>
<p>到目前为止，在if语句中看到的都是普通shell命令。你可能想问，if-then语句是否能测试命令退出状态码之外的条件</p>
<p>答案是不能。但在bash shell中有个好用的工具可以帮你通过if-then语句测试其他条件。</p>
<p>test命令提供了在if-then语句中测试不同条件的途径。如果test命令中列出的条件成立，test命令就会退出并返回退出状态码0。这样if-then语句就与其他编程语言中的if-then语句以类似的方式工作了。如果条件不成立，test命令就会退出并返回非零的退出状态码，这使得if-then语句不会再被执行。</p>
<p>test命令的格式非常简单。</p>
<pre><code class="language-sh">test condition 
</code></pre>
<p>condition是test命令要测试的一系列参数和值。当用在if-then语句中时，test命令看起来是这样的。</p>
<pre><code class="language-sh">if test condition 
then 
   commands 
fi 
</code></pre>
<p>如果不写test命令的condition部分，它会以非零的退出状态码退出，并执行else语句块。</p>
<pre><code class="language-sh">$ cat test6.sh 
#!/bin/bash 
# Testing the test command 
# 
if test 
then 
   echo &quot;No expression returns a True&quot; 
else 
   echo &quot;No expression returns a False&quot; 
fi 
</code></pre>
<pre><code class="language-sh">$ sh test6.sh 
No expression returns a False 
</code></pre>
<p>当你加入一个条件时，test命令会测试该条件。例如，可以使用test命令确定变量中是否有内容。这只需要一个简单的条件表达式。</p>
<pre><code class="language-sh">$ cat test6.sh 
#!/bin/bash 
# Testing the test command 
# 
my_variable=&quot;Full&quot; 
# 
if test $my_variable 
then 
   echo &quot;The $my_variable expression returns a True&quot; 
# 
else 
   echo &quot;The $my_variable expression returns a False&quot; 
fi 

$ sh test6.sh 
The Full expression returns a True 
</code></pre>
<p>变量my_variable中包含有内容（Full），因此当test命令测试条件时，返回的退出状态为0。这使得then语句块中的语句得以执行。<br>
如你所料，如果该变量中没有包含内容，就会出现相反的情况。</p>
<pre><code class="language-sh">$ cat test6.sh 
#!/bin/bash 
# Testing the test command 
# 
my_variable=&quot;&quot; 
# 
if test $my_variable 
then 
   echo &quot;The $my_variable expression returns a True&quot; 
# 
else 
   echo &quot;The $my_variable expression returns a False&quot; 
fi 

$ sh test6.sh 
The  expression returns a False 
</code></pre>
<p>bash shell提供了另一种条件测试方法，无需在if-then语句中声明test命令。</p>
<pre><code>if [ condition ] 
then 
   commands 
fi 
</code></pre>
<p>方括号定义了测试条件。<strong>注意，第一个方括号之后和第二个方括号之前必须加上一个空格，否则就会报错。</strong><br>
test命令可以判断三类条件：</p>
<ul>
<li>数值比较</li>
<li>字符串比较</li>
<li>文件比较</li>
</ul>
<h4 id="数值比较">数值比较</h4>
<p>使用test命令最常见的情形是对两个数值进行比较。下表列出了测试两个值时可用的条件参数。<br>
<img src="https://s1.ax2x.com/2018/08/07/55MplR.png" alt="55MplR.png"></p>
<p>数值条件测试可以用在数字和变量上。</p>
<pre><code class="language-sh">$ cat numeric_test.sh 
#!/bin/bash 
# Using numeric test evaluations 

value1=10 
value2=11 

if [ $value1 -gt 5 ] 
then 
    echo &quot;The test value $value1 is greater than 5&quot; 
fi 
# 
if [ $value1 -eq $value2 ] 
then 
    echo &quot;The values are equal&quot; 
else 
    echo &quot;The values are different&quot; 
fi 
</code></pre>
<p>第一个条件测试：</p>
<pre><code>if [ $value1 -gt 5 ] 
</code></pre>
<p>测试变量value1的值是否大于5。第二个条件测试：</p>
<pre><code>if [ $value1 -eq $value2 ] 
</code></pre>
<p>测试变量value1的值是否和变量value2的值相等。两个数值条件测试的结果和预想一致。</p>
<pre><code class="language-sh">$ sh numeric_test.sh 
The test value 10 is greater than 5 
The values are different 
$ 
</code></pre>
<p>但是涉及浮点值时，数值条件测试会有一个限制。</p>
<pre><code class="language-sh">$ cat floating_point_test.sh 
#!/bin/bash 
# Using floating point numbers in test evaluations 
# 
value1=5.555 
# 
echo &quot;The test value is $value1&quot; 
# 
if [ $value1 -gt 5 ] 
then 
    echo &quot;The test value $value1 is greater than 5&quot; 
fi 
# 
$ sh floating_point_test.sh 
The test value is 5.555 
./floating_point_test.sh: line 8:  
[: 5.555: integer expression expected 
</code></pre>
<p>此例，变量value1中存储的是浮点值。接着，脚本对这个值进行了测试。显然这里出错了。记住，bash shell只能处理整数。如果你只是要通过echo语句来显示这个结果，那没问题。但是，在基于数字的函数中就不行了，例如我们的数值测试条件。最后一行就说明我们不能在test命令中使用浮点值。</p>
<h4 id="字符串比较">字符串比较</h4>
<p>条件测试还允许比较字符串值。比较字符串比较烦琐，你马上就会看到。下表列出了可用的字符串比较功能。</p>
<p><img src="https://s1.ax2x.com/2018/08/07/55MuFr.png" alt="55MuFr.png"></p>
<h5 id="字符串相等性">字符串相等性</h5>
<p>字符串的相等和不等条件不言自明，很容易看出两个字符串值是否相同。</p>
<pre><code class="language-sh">$ cat test7.sh 
#!/bin/bash
# testing string equality
testuser=xiaofei
#
if [ $USER = $testuser ]
then
   echo &quot;Welcome $testuser&quot;
fi


$ sh test7.sh 
Welcome xiaofei 
</code></pre>
<p>字符串不等条件也可以判断两个字符串是否有相同的值。</p>
<pre><code class="language-sh">$ cat test8.sh 
#!/bin/bash 
# testing string equality 
testuser=baduser 
# 
if [ $USER != $testuser ] 
then 
   echo &quot;This is not $testuser&quot; 
else 
   echo &quot;Welcome $testuser&quot; 
fi


$ sh test8.sh 
This is not baduser 
</code></pre>
<p>记住，在比较字符串的相等性时，比较测试会将所有的标点和大小写情况都考虑在内。</p>
<h5 id="字符串顺序">字符串顺序</h5>
<p>要测试一个字符串是否比另一个字符串大就是麻烦的开始。当要开始使用测试条件的大于或小于功能时，就会出现两个经常困扰shell程序员的问题：</p>
<ul>
<li>大于号和小于号必须转义，否则shell会把它们当作重定向符号，把字符串值当作文件名；</li>
<li>大于和小于顺序和sort命令所采用的不同。</li>
</ul>
<p>在编写脚本时，第一条可能会导致一个不易察觉的严重问题。下面的例子展示了shell脚本编程初学者时常碰到的问题。</p>
<pre><code class="language-sh">$ cat badtest.sh 
#!/bin/bash 
# mis-using string comparisons 
# 
val1=baseball 
val2=hockey 
# 
if [ $val1 &gt; $val2 ] 
then 
   echo &quot;$val1 is greater than $val2&quot; 
else 
   echo &quot;$val1 is less than $val2&quot; 
fi 


$ ./badtest.sh 
baseball is greater than hockey 
$ ls -l hockey 
-rw-r--r--    1 rich     rich            0 Sep 30 19:08 hockey 

</code></pre>
<p>这个脚本中只用了大于号，没有出现错误，但结果是错的。脚本把大于号解释成了输出重定向。因此，它创建了一个名为hockey的文件。由于重定向的顺利完成，test命令返回了退出状态码0，if语句便以为所有命令都成功结束了。<br>
要解决这个问题，就需要正确转义大于号。</p>
<pre><code class="language-sh">$ cat test9.sh 
#!/bin/bash 
# mis-using string comparisons 
# 
val1=baseball 
val2=hockey 
# 
if [ $val1 \&gt; $val2 ] 
then 
  echo &quot;$val1 is greater than $val2&quot; 
else 
   echo &quot;$val1 is less than $val2&quot; 
fi 
  
$ sh test9.sh 
baseball is less than hockey 
</code></pre>
<p>这个答案就对了</p>
<p>第二个问题更细微，除非你经常处理大小写字母，否则几乎遇不到。sort命令处理大写字母的方法刚好跟test命令相反。让我们在脚本中测试一下这个特性。</p>
<pre><code class="language-sh">$ cat test9b.sh 
#!/bin/bash 
# testing string sort order 
val1=Testing 
val2=testing 
# 
if [ $val1 \&gt; $val2 ] 
then 
   echo &quot;$val1 is greater than $val2&quot; 
else 
   echo &quot;$val1 is less than $val2&quot; 
fi 
$  
$ ./test9b.sh 
Testing is less than testing 
$  
$ sort testfile 
testing 
Testing
</code></pre>
<p>在比较测试中，大写字母被认为是小于小写字母的。但sort命令恰好相反。当你将同样的字符串放进文件中并用sort命令排序时，小写字母会先出现。这是由各个命令使用的排序技术不同造成的。</p>
<p>比较测试中使用的是标准的ASCII顺序，根据每个字符的ASCII数值来决定排序结果。sort命令使用的是系统的本地化语言设置中定义的排序顺序。对于英语，本地化设置指定了在排序顺序中小写字母出现在大写字母前。</p>
<h5 id="字符串大小">字符串大小</h5>
<p>-n和-z可以检查一个变量是否含有数据。</p>
<pre><code class="language-sh">$ cat test10.sh 
#!/bin/bash 
# testing string length 
val1=testing 
val2='' 
# 
if [ -n $val1 ] 
then 
   echo &quot;The string '$val1' is not empty&quot; 
else 
   echo &quot;The string '$val1' is empty&quot; 
fi 
# 
if [ -z $val2 ] 
then 
   echo &quot;The string '$val2' is empty&quot; 
else 
   echo &quot;The string '$val2' is not empty&quot; 
fi 
# 
if [ -z $val3 ] 
then 
   echo &quot;The string '$val3' is empty&quot; 
else 
   echo &quot;The string '$val3' is not empty&quot; 
fi 
$  
$ ./test10.sh 
The string 'testing' is not empty 
The string '' is empty 
The string '' is empty 
</code></pre>
<p>这个例子创建了两个字符串变量。val1变量包含了一个字符串，val2变量包含的是一个空字符串。后续的比较如下：</p>
<pre><code>if [ -n $val1 ] 
</code></pre>
<p>判断val1变量是否长度非0，而它的长度正好非0，所以then部分被执行了。</p>
<pre><code>if [ -z $var2 ]  
</code></pre>
<p>判断val2变量是否长度为0，而它正好长度为0，所以then部分被执行了。</p>
<pre><code>if [ -z $val3 ]  
</code></pre>
<p>判断val3变量是否长度为0。这个变量并未在shell脚本中定义过，所以它的字符串长度仍然为0，尽管它未被定义过。</p>
<h4 id="文件比较">文件比较</h4>
<p>最后一类比较测试很有可能是shell编程中最为强大、也是用得最多的比较形式。它允许你测试Linux文件系统上文件和目录的状态。下表列出了这些比较。<br>
<img src="https://s1.ax2x.com/2018/08/07/55MyEl.png" alt="55MyEl.png"><br>
这些测试条件使你能够在shell脚本中检查文件系统中的文件。它们经常出现在需要进行文件访问的脚本中。鉴于其使用广泛，我们来逐个看看。</p>
<h5 id="检查目录">检查目录</h5>
<p>-d测试会检查指定的目录是否存在于系统中。如果你打算将文件写入目录或是准备切换到某个目录中，先进行测试总是件好事情。</p>
<pre><code class="language-sh">$ cat test11.sh 
#!/bin/bash 
# Look before you leap 
# 
jump_directory=/home/arthur 
# 
if [ -d $jump_directory ] 
then 
   echo &quot;The $jump_directory directory exists&quot; 
   cd $jump_directory 
   ls 
else 
   echo &quot;The $jump_directory directory does not exist&quot; 
fi 
#

$ sh test11.sh 
The /home/arthur directory does not exist 

</code></pre>
<p>示例代码中使用了-d测试条件来检查jump_directory变量中的目录是否存在：若存在，就使用cd命令切换到该目录并列出目录中的内容；若不存在，脚本就输出一条警告信息，然后退出。</p>
<h5 id="检查对象是否存在">检查对象是否存在</h5>
<p>-e比较允许你的脚本代码在使用文件或目录前先检查它们是否存在。</p>
<pre><code class="language-sh">$ cat test12.sh 
#!/bin/bash 
# Check if either a directory or file exists 
# 
location=$HOME 
file_name=&quot;sentinel&quot; 
# 
if [ -e $location ] 
then  #Directory does exist 
   echo &quot;OK on the $location directory.&quot; 
   echo &quot;Now checking on the file, $file_name.&quot; 
   # 
   if [ -e $location/$file_name ] 
   then #File does exist 
       echo &quot;OK on the filename&quot; 
       echo &quot;Updating Current Date...&quot; 
       date &gt;&gt; $location/$file_name 
   # 
   else #File does not exist 
       echo &quot;File does not exist&quot; 
       echo &quot;Nothing to update&quot; 
   fi 
# 
else   #Directory does not exist 
   echo &quot;The $location directory does not exist.&quot; 
   echo &quot;Nothing to update&quot; 
fi 
# 
$ 
$ sh test12.sh 
OK on the /home/Christine directory. 
Now checking on the file, sentinel. 
File does not exist 
Nothing to update 

$ 
$ touch sentinel 
$
$ sh test12.sh 
OK on the /home/Christine directory. 
Now checking on the file, sentinel. 
OK on the filename 
Updating Current Date... 
$ 
</code></pre>
<p>第一次检查用-e比较来判断用户是否有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>H</mi><mi>O</mi><mi>M</mi><mi>E</mi><mi mathvariant="normal">目</mi><mi mathvariant="normal">录</mi><mi mathvariant="normal">。</mi><mi mathvariant="normal">如</mi><mi mathvariant="normal">果</mi><mi mathvariant="normal">有</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">接</mi><mi mathvariant="normal">下</mi><mi mathvariant="normal">来</mi><mi mathvariant="normal">的</mi><mo>−</mo><mi>e</mi><mi mathvariant="normal">比</mi><mi mathvariant="normal">较</mi><mi mathvariant="normal">会</mi><mi mathvariant="normal">检</mi><mi mathvariant="normal">查</mi><mi>s</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>i</mi><mi>n</mi><mi>e</mi><mi>l</mi><mi mathvariant="normal">文</mi><mi mathvariant="normal">件</mi><mi mathvariant="normal">是</mi><mi mathvariant="normal">否</mi><mi mathvariant="normal">存</mi><mi mathvariant="normal">在</mi><mi mathvariant="normal">于</mi></mrow><annotation encoding="application/x-tex">HOME目录。如果有，接下来的-e比较会检查sentinel文件是否存在于</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord cjk_fallback">目</span><span class="mord cjk_fallback">录</span><span class="mord cjk_fallback">。</span><span class="mord cjk_fallback">如</span><span class="mord cjk_fallback">果</span><span class="mord cjk_fallback">有</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">接</span><span class="mord cjk_fallback">下</span><span class="mord cjk_fallback">来</span><span class="mord cjk_fallback">的</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">e</span><span class="mord cjk_fallback">比</span><span class="mord cjk_fallback">较</span><span class="mord cjk_fallback">会</span><span class="mord cjk_fallback">检</span><span class="mord cjk_fallback">查</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord cjk_fallback">文</span><span class="mord cjk_fallback">件</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">否</span><span class="mord cjk_fallback">存</span><span class="mord cjk_fallback">在</span><span class="mord cjk_fallback">于</span></span></span></span>HOME目录中。如果不存在，shell脚本就会提示该文件不存在，不需要进行更新。</p>
<p>为确保更新操作能够正常进行，我们创建了sentinel文件，然后重新运行这个shell脚本。这一次在进行条件测试时，$HOME和sentinel文件都存在，因此当前日期和时间就被追加到了文件中。</p>
<h5 id="检查文件">检查文件</h5>
<p>-e比较可用于文件和目录。要确定指定对象为文件，必须用-f比较。</p>
<pre><code class="language-sh">$ cat test13.sh 
#!/bin/bash 
# Check if either a directory or file exists 
# 
item_name=$HOME 
echo 
echo &quot;The item being checked: $item_name&quot; 
echo 
# 
if [ -e $item_name ] 
then  #Item does exist 
   echo &quot;The item, $item_name, does exist.&quot; 
   echo &quot;But is it a file?&quot; 
   echo 
   # 
   if [ -f $item_name ] 
   then #Item is a file 
       echo &quot;Yes, $item_name is a file.&quot; 
   # 
   else #Item is not a file 
       echo &quot;No, $item_name is not a file.&quot; 
   fi 
# 
else   #Item does not exist 
   echo &quot;The item, $item_name, does not exist.&quot; 
   echo &quot;Nothing to update&quot; 
fi 
# 
$ sh test13.sh 
 
The item being checked: /home/Christine 
 
The item, /home/Christine, does exist. 
But is it a file? 
 
No, /home/Christine is not a file. 
$ 
</code></pre>
<p>这一小段脚本进行了大量的检查！它首先使用-e比较测试<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>H</mi><mi>O</mi><mi>M</mi><mi>E</mi><mi mathvariant="normal">是</mi><mi mathvariant="normal">否</mi><mi mathvariant="normal">存</mi><mi mathvariant="normal">在</mi><mi mathvariant="normal">。</mi><mi mathvariant="normal">如</mi><mi mathvariant="normal">果</mi><mi mathvariant="normal">存</mi><mi mathvariant="normal">在</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">继</mi><mi mathvariant="normal">续</mi><mi mathvariant="normal">用</mi><mo>−</mo><mi>f</mi><mi mathvariant="normal">来</mi><mi mathvariant="normal">测</mi><mi mathvariant="normal">试</mi><mi mathvariant="normal">它</mi><mi mathvariant="normal">是</mi><mi mathvariant="normal">不</mi><mi mathvariant="normal">是</mi><mi mathvariant="normal">一</mi><mi mathvariant="normal">个</mi><mi mathvariant="normal">文</mi><mi mathvariant="normal">件</mi><mi mathvariant="normal">。</mi><mi mathvariant="normal">如</mi><mi mathvariant="normal">果</mi><mi mathvariant="normal">它</mi><mi mathvariant="normal">不</mi><mi mathvariant="normal">是</mi><mi mathvariant="normal">文</mi><mi mathvariant="normal">件</mi><mi mathvariant="normal">（</mi><mi mathvariant="normal">当</mi><mi mathvariant="normal">然</mi><mi mathvariant="normal">不</mi><mi mathvariant="normal">会</mi><mi mathvariant="normal">是</mi><mi mathvariant="normal">了</mi><mi mathvariant="normal">）</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">就</mi><mi mathvariant="normal">会</mi><mi mathvariant="normal">显</mi><mi mathvariant="normal">示</mi><mi mathvariant="normal">一</mi><mi mathvariant="normal">条</mi><mi mathvariant="normal">消</mi><mi mathvariant="normal">息</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">表</mi><mi mathvariant="normal">明</mi><mi mathvariant="normal">这</mi><mi mathvariant="normal">不</mi><mi mathvariant="normal">是</mi><mi mathvariant="normal">一</mi><mi mathvariant="normal">个</mi><mi mathvariant="normal">文</mi><mi mathvariant="normal">件</mi><mi mathvariant="normal">。</mi><mi mathvariant="normal">我</mi><mi mathvariant="normal">们</mi><mi mathvariant="normal">对</mi><mi mathvariant="normal">变</mi><mi mathvariant="normal">量</mi><mi>i</mi><mi>t</mi><mi>e</mi><msub><mi>m</mi><mi>n</mi></msub><mi>a</mi><mi>m</mi><mi>e</mi><mi mathvariant="normal">作</mi><mi mathvariant="normal">了</mi><mi mathvariant="normal">一</mi><mi mathvariant="normal">个</mi><mi mathvariant="normal">小</mi><mi mathvariant="normal">小</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">修</mi><mi mathvariant="normal">改</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">将</mi><mi mathvariant="normal">目</mi><mi mathvariant="normal">录</mi></mrow><annotation encoding="application/x-tex">HOME是否存在。如果存在，继续用-f来测试它是不是一个文件。如果它不是文件（当然不会是了），就会显示一条消息，表明这不是一个文件。
我们对变量item_name作了一个小小的修改，将目录</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">否</span><span class="mord cjk_fallback">存</span><span class="mord cjk_fallback">在</span><span class="mord cjk_fallback">。</span><span class="mord cjk_fallback">如</span><span class="mord cjk_fallback">果</span><span class="mord cjk_fallback">存</span><span class="mord cjk_fallback">在</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">继</span><span class="mord cjk_fallback">续</span><span class="mord cjk_fallback">用</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord cjk_fallback">来</span><span class="mord cjk_fallback">测</span><span class="mord cjk_fallback">试</span><span class="mord cjk_fallback">它</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">不</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">一</span><span class="mord cjk_fallback">个</span><span class="mord cjk_fallback">文</span><span class="mord cjk_fallback">件</span><span class="mord cjk_fallback">。</span><span class="mord cjk_fallback">如</span><span class="mord cjk_fallback">果</span><span class="mord cjk_fallback">它</span><span class="mord cjk_fallback">不</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">文</span><span class="mord cjk_fallback">件</span><span class="mord cjk_fallback">（</span><span class="mord cjk_fallback">当</span><span class="mord cjk_fallback">然</span><span class="mord cjk_fallback">不</span><span class="mord cjk_fallback">会</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">了</span><span class="mord cjk_fallback">）</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">就</span><span class="mord cjk_fallback">会</span><span class="mord cjk_fallback">显</span><span class="mord cjk_fallback">示</span><span class="mord cjk_fallback">一</span><span class="mord cjk_fallback">条</span><span class="mord cjk_fallback">消</span><span class="mord cjk_fallback">息</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">表</span><span class="mord cjk_fallback">明</span><span class="mord cjk_fallback">这</span><span class="mord cjk_fallback">不</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">一</span><span class="mord cjk_fallback">个</span><span class="mord cjk_fallback">文</span><span class="mord cjk_fallback">件</span><span class="mord cjk_fallback">。</span><span class="mord cjk_fallback">我</span><span class="mord cjk_fallback">们</span><span class="mord cjk_fallback">对</span><span class="mord cjk_fallback">变</span><span class="mord cjk_fallback">量</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">a</span><span class="mord mathdefault">m</span><span class="mord mathdefault">e</span><span class="mord cjk_fallback">作</span><span class="mord cjk_fallback">了</span><span class="mord cjk_fallback">一</span><span class="mord cjk_fallback">个</span><span class="mord cjk_fallback">小</span><span class="mord cjk_fallback">小</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">修</span><span class="mord cjk_fallback">改</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">将</span><span class="mord cjk_fallback">目</span><span class="mord cjk_fallback">录</span></span></span></span>HOME替换成文件$HOME/sentinel，结果就不一样了。</p>
<pre><code class="language-sh">$ nano test13.sh 
$ 
$ cat test13.sh 
#!/bin/bash 
# Check if either a directory or file exists 
# 
item_name=$HOME/sentinel 

[...] 

$ 
$ ./test13.sh 
 
The item being checked: /home/Christine/sentinel 
 
The item, /home/Christine/sentinel, does exist. 
But is it a file? 
 
Yes, /home/Christine/sentinel is a file. 
$ 
</code></pre>
<p>这里只列出了脚本test13.sh的部分代码，因为只改变了脚本变量item_name的值。当运行这个脚本时，对$HOME/sentinel进行的-f测试所返回的退出状态码为0，then语句得以执行，然后输出消息：Yes, /home/Christine/sentinel is a file。</p>
<h5 id="检查是否可读">检查是否可读</h5>
<p>在尝试从文件中读取数据之前，最好先测试一下文件是否可读。可以使用-r比较测试。</p>
<pre><code class="language-sh">$ cat test14.sh 
#!/bin/bash 
# testing if you can read a file 
pwfile=/etc/shadow 
# 
# first, test if the file exists, and is a file 
if [ -f $pwfile ] 
then 
   # now test if you can read it 
   if [ -r $pwfile ] 
   then 
      tail $pwfile 
   else 
      echo &quot;Sorry, I am unable to read the $pwfile file&quot; 
   fi 
else 
   echo &quot;Sorry, the file $file does not exist&quot; 
fi 
$  
$ ./test14.sh 
Sorry, I am unable to read the /etc/shadow file 
$ 

</code></pre>
<p>/etc/shadow文件含有系统用户加密后的密码，所以它对系统上的普通用户来说是不可读的。-r比较确定该文件不允许进行读取，因此测试失败，bash shell执行了if-then语句的else部分。</p>
<h5 id="检查空文件">检查空文件</h5>
<p>应该用-s比较来检查文件是否为空，尤其是在不想删除非空文件的时候。<strong>要留心的是，当-s比较成功时，说明文件中有数据。</strong></p>
<pre><code class="language-sh">$ cat test15.sh 
#!/bin/bash 
# Testing if a file is empty 
# 
file_name=$HOME/sentinel 
# 
if [ -f $file_name ] 
then 
   if [ -s $file_name ] 
   then 
      echo &quot;The $file_name file exists and has data in it.&quot; 
      echo &quot;Will not remove this file.&quot; 
# 
   else 
      echo &quot;The $file_name file exists, but is empty.&quot; 
      echo &quot;Deleting empty file...&quot; 
      rm $file_name 
   fi 
else 
   echo &quot;File, $file_name, does not exist.&quot; 
fi 
# 
$ ls -l $HOME/sentinel 
-rw-rw-r--. 1 Christine Christine 29 Jun 25 05:32 /home/Christine/sentinel 
$ 
$ ./test15.sh 
The /home/Christine/sentinel file exists and has data in it. 
Will not remove this file. 
$
</code></pre>
<p>-f比较测试首先测试文件是否存在。如果存在，由-s比较来判断该文件是否为空。空文件会被删除。可以从ls –l的输出中看出sentinel并不是空文件，因此脚本并不会删除它。</p>
<h5 id="检查是否可写">检查是否可写</h5>
<p>-w比较会判断你对文件是否有可写权限。脚本test16.sh只是脚本test13.sh的修改版。现在不单检查item_name是否存在、是否为文件，还会检查该文件是否有写入权限。</p>
<pre><code class="language-sh">$ cat test16.sh 
#!/bin/bash 
# Check if a file is writable. 
# 
item_name=$HOME/sentinel 
echo 
echo &quot;The item being checked: $item_name&quot; 
echo 
[...] 
       echo &quot;Yes, $item_name is a file.&quot; 
       echo &quot;But is it writable?&quot; 
       echo 
       # 
       if [ -w $item_name ] 
       then #Item is writable 
            echo &quot;Writing current time to $item_name&quot; 
            date +%H%M &gt;&gt; $item_name 
       # 
       else #Item is not writable 
            echo &quot;Unable to write to $item_name&quot; 
       fi 
   # 
   else #Item is not a file 
       echo &quot;No, $item_name is not a file.&quot; 
   fi 

[...]


$ 
$ ls -l sentinel 
-rw-rw-r--. 1 Christine Christine 0 Jun 27 05:38 sentinel 
$ 
$ sh test16.sh 
 
The item being checked: /home/Christine/sentinel 
 
The item, /home/Christine/sentinel, does exist. 
But is it a file? 
 
Yes, /home/Christine/sentinel is a file. 
But is it writable? 
 
Writing current time to /home/Christine/sentinel 
$ 
$ cat sentinel 
0543 
$ 

</code></pre>
<p>变量item_name被设置成$HOME/sentinel，该文件允许用户进行写入。因此当脚本运行时，-w测试表达式会返回非零退出状态，然后执行then代码块，将时间戳写入文件sentinel中.<br>
如果使用chmod关闭文件sentinel的用户 写入权限，-w测试表达式会返回非零的退出状态码，时间戳不会被写入文件。</p>
<pre><code class="language-sh">$ chmod u-w sentinel 
$ 
$ ls -l sentinel 
-r--rw-r--. 1 Christine Christine 5 Jun 27 05:43 sentinel 
$ 
$ ./test16.sh 
 
The item being checked: /home/Christine/sentinel 
The item, /home/Christine/sentinel, does exist. 
But is it a file? 
 
Yes, /home/Christine/sentinel is a file. 
But is it writable? 
 
Unable to write to /home/Christine/sentinel 
$ 
</code></pre>
<p>chmod命令可用来为读者再次回授写入权限。这会使得写入测试表达式返回退出状态码0，并允许一次针对文件的写入尝试。</p>
<h5 id="检查文件是否可以执行">检查文件是否可以执行</h5>
<p>-x比较是判断特定文件是否有执行权限的一个简单方法。虽然可能大多数命令用不到它，但如果你要在shell脚本中运行大量脚本，它就能发挥作用。</p>
<pre><code class="language-sh">$ cat test17.sh 
#!/bin/bash 
# testing file execution 
# 
if [ -x test16.sh ] 
then 
   echo &quot;You can run the script: &quot; 
   ./test16.sh 
else 
   echo &quot;Sorry, you are unable to execute the script&quot; 
fi 
$  
$ ./test17.sh 
You can run the script: 

[...] 

$  
$ chmod u-x test16.sh 
$  
$ ./test17.sh 
Sorry, you are unable to execute the script 
$ 
</code></pre>
<p>这段示例shell脚本用-x比较来测试是否有权限执行test16.sh脚本。如果有权限，它会运行这个脚本。在首次成功运行test16.sh脚本后，更改文件的权限。这次，-x比较失败了，因为你已经没有test16.sh脚本的执行权限了。</p>
<h5 id="检查所属关系">检查所属关系</h5>
<p>-O比较可以测试出你是否是文件的属主。</p>
<pre><code class="language-sh">$ cat test18.sh 
#!/bin/bash 
# check file ownership 
# 
if [ -O /etc/passwd ] 
then 
   echo &quot;You are the owner of the /etc/passwd file&quot; 
else 
   echo &quot;Sorry, you are not the owner of the /etc/passwd file&quot; 
fi 
$  
$ ./test18.sh 
Sorry, you are not the owner of the /etc/passwd file 
$  
</code></pre>
<p>这段脚本用-O比较来测试运行该脚本的用户是否是/etc/passwd文件的属主。这个脚本是运行在普通用户账户下的，所以测试失败了。(就是看这个文件什么的是属于哪个账户的)))</p>
<h5 id="检查默认属组关系">检查默认属组关系</h5>
<p>-G比较会检查文件的默认组，如果它匹配了用户的默认组，则测试成功。由于-G比较只会检查默认组而非用户所属的所有组，这会叫人有点困惑。这里有个例子。</p>
<pre><code class="language-sh">$ cat test19.sh 
#!/bin/bash 
# check file group test 
# 
if [ -G $HOME/testing ] 
then 
   echo &quot;You are in the same group as the file&quot; 
else 
   echo &quot;The file is not owned by your group&quot; 
fi 
$  
$ ls -l $HOME/testing 
-rw-rw-r-- 1 rich rich 58 2014-07-30 15:51 /home/rich/testing 
$  
$ ./test19.sh 
You are in the same group as the file 
$  
$ chgrp sharing $HOME/testing 
$  
$ ./test19 
The file is not owned by your group 
$ 
</code></pre>
<p>第一次运行脚本时，$HOME/testing文件属于rich组，所以通过了-G比较。接下来，组被改成了sharing组，用户也是其中的一员。但是，-G比较失败了，因为它只比较默认组，不会去比较其他的组。</p>
<h5 id="检查文件日期">检查文件日期</h5>
<p>最后一组方法用来对两个文件的创建日期进行比较。这在编写软件安装脚本时非常有用。有时候，你不会愿意安装一个比系统上已有文件还要旧的文件。</p>
<p>-nt比较会判定一个文件是否比另一个文件新。如果文件较新，那意味着它的文件创建日期更近。-ot比较会判定一个文件是否比另一个文件旧。如果文件较旧，意味着它的创建日期更早。</p>
<pre><code class="language-sh">$ cat test20.sh 
#!/bin/bash 
# testing file dates 
# 
if [ test19.sh -nt test18.sh ] 
then 
   echo &quot;The test19 file is newer than test18&quot; 
else 
   echo &quot;The test18 file is newer than test19&quot; 
fi 
if [ test17.sh -ot test19.sh ] 
then 
  echo &quot;The test17 file is older than the test19 file&quot; 
fi 
$  
$ ./test20.sh 
The test19 file is newer than test18 
The test17 file is older than the test19 file 
$  
$ ls -l test17.sh test18.sh test19.sh 
-rwxrw-r-- 1 rich rich 167 2014-07-30 16:31 test17.sh 
-rwxrw-r-- 1 rich rich 185 2014-07-30 17:46 test18.sh 
-rwxrw-r-- 1 rich rich 167 2014-07-30 17:50 test19.sh 
$ 
</code></pre>
<p>用于比较文件路径是相对你运行该脚本的目录而言的。如果你要检查的文件已经移走，就会出现问题。另一个问题是，这些比较都不会先检查文件是否存在。试试这个测试。</p>
<pre><code class="language-sh">$ cat test21.sh 
#!/bin/bash 
# testing file dates 
# 
if [ badfile1 -nt badfile2 ] 
then 
   echo &quot;The badfile1 file is newer than badfile2&quot; 
else 
   echo &quot;The badfile2 file is newer than badfile1&quot; 
fi 
$  
$ ./test21.sh 
The badfile2 file is newer than badfile1 
$ 
</code></pre>
<blockquote>
<p>这个小例子演示了如果文件不存在，-nt比较会返回一个错误的结果。在你尝试使用-nt或-ot比较文件之前，必须先确认文件是存在的。</p>
</blockquote>
<h2 id="复合条件测试">复合条件测试</h2>
<p>if-then语句允许你使用布尔逻辑来组合测试。有两种布尔运算符可用：</p>
<pre><code>[ condition1 ] &amp;&amp; [ condition2 ] 
[ condition1 ] || [ condition2 ] 
</code></pre>
<p>第一种布尔运算使用AND布尔运算符来组合两个条件。要让then部分的命令执行，两个条件都必须满足。</p>
<p>第二种布尔运算使用OR布尔运算符来组合两个条件。如果任意条件为TRUE，then部分的命令就会执行。</p>
<p>下例展示了AND布尔运算符的使用。</p>
<pre><code class="language-sh">$ cat test22.sh 
#!/bin/bash 
# testing compound comparisons 
# 
if [ -d $HOME ] &amp;&amp; [ -w $HOME/testing ] 
then 
   echo &quot;The file exists and you can write to it&quot; 
else 
   echo &quot;I cannot write to the file&quot; 
fi 
$  
$ ./test22.sh 
I cannot write to the file 
$ 
$ touch $HOME/testing 
$  
$ ./test22.sh 
The file exists and you can write to it 
$ 
</code></pre>
<p>使用AND布尔运算符时，两个比较都必须满足。第一个比较会检查用户的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>H</mi><mi>O</mi><mi>M</mi><mi>E</mi><mi mathvariant="normal">目</mi><mi mathvariant="normal">录</mi><mi mathvariant="normal">是</mi><mi mathvariant="normal">否</mi><mi mathvariant="normal">存</mi><mi mathvariant="normal">在</mi><mi mathvariant="normal">。</mi><mi mathvariant="normal">第</mi><mi mathvariant="normal">二</mi><mi mathvariant="normal">个</mi><mi mathvariant="normal">比</mi><mi mathvariant="normal">较</mi><mi mathvariant="normal">会</mi><mi mathvariant="normal">检</mi><mi mathvariant="normal">查</mi><mi mathvariant="normal">在</mi><mi mathvariant="normal">用</mi><mi mathvariant="normal">户</mi><mi mathvariant="normal">的</mi></mrow><annotation encoding="application/x-tex">HOME目录是否存在。第二个比较会检查在用户的</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord cjk_fallback">目</span><span class="mord cjk_fallback">录</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">否</span><span class="mord cjk_fallback">存</span><span class="mord cjk_fallback">在</span><span class="mord cjk_fallback">。</span><span class="mord cjk_fallback">第</span><span class="mord cjk_fallback">二</span><span class="mord cjk_fallback">个</span><span class="mord cjk_fallback">比</span><span class="mord cjk_fallback">较</span><span class="mord cjk_fallback">会</span><span class="mord cjk_fallback">检</span><span class="mord cjk_fallback">查</span><span class="mord cjk_fallback">在</span><span class="mord cjk_fallback">用</span><span class="mord cjk_fallback">户</span><span class="mord cjk_fallback">的</span></span></span></span>HOME目录是否有个叫testing的文件，以及用户是否有该文件的写入权限。如果两个比较中的一个失败了，if语句就会失败，shell就会执行else部分的命令。如果两个比较都通过了，则if语句通过，shell会执行then部分的命令。</p>
<h2 id="if-then的高级特性">if-then的高级特性</h2>
<p>bash shell提供了两项可在if-then语句中使用的高级特性：</p>
<ul>
<li>用于数学表达式的双括号</li>
<li>用于高级字符串处理功能的双方括号</li>
</ul>
<h4 id="使用双括号">使用双括号</h4>
<p>双括号命令允许你在比较过程中使用高级数学表达式。test命令只能在比较中使用简单的算术操作。双括号命令提供了更多的数学符号，这些符号对于用过其他编程语言的程序员而言并不陌生。双括号命令的格式如下：</p>
<pre><code>(( expression )) 
</code></pre>
<p>expression可以是任意的数学赋值或比较表达式。除了test命令使用的标准数学运算符，下表列出了双括号命令中会用到的其他运算符。<br>
<img src="https://s1.ax2x.com/2018/08/07/55MNYa.png" alt="55MNYa.png"><br>
可以在if语句中用双括号命令，也可以在脚本中的普通命令里使用来赋值。</p>
<pre><code class="language-sh">$ cat test23.sh 
#!/bin/bash 
# using double parenthesis 
# 
val1=10 
# 
if (( $val1 ** 2 &gt; 90 )) 
then 
   (( val2 = $val1 ** 2 )) 
   echo &quot;The square of $val1 is $val2&quot; 
fi 
$  
$ ./test23.sh 
The square of 10 is 100 
$
</code></pre>
<p>注意，不需要将双括号中表达式里的大于号转义。这是双括号命令提供的另一个高级特性。</p>
<h4 id="使用双方括号">使用双方括号</h4>
<p>双方括号命令提供了针对字符串比较的高级特性。双方括号命令的格式如下：</p>
<pre><code>[[ expression ]] 
</code></pre>
<p>双方括号里的expression使用了test命令中采用的标准字符串比较。但它提供了test命令未提供的另一个特性——模式匹配（pattern matching）。</p>
<p>在模式匹配中，可以定义一个正则表达式来匹配字符串值。</p>
<pre><code class="language-sh">$ cat test24.sh 
#!/bin/bash 
# using pattern matching 
# 
if [[ $USER == r* ]] 
then 
   echo &quot;Hello $USER&quot; 
else 
   echo &quot;Sorry, I do not know you&quot; 
fi 
$  
$ ./test24.sh 
Hello rich
</code></pre>
<p>在上面的脚本中，我们使用了双等号（==）。双等号将右边的字符串（r*）视为一个模式，并应用模式匹配规则。双方括号命令$USER环境变量进行匹配，看它是否以字母r开头。如果是的话，比较通过，shell会执行then部分的命令。</p>
<h2 id="case命令">case命令</h2>
<p>你会经常发现自己在尝试计算一个变量的值，在一组可能的值中寻找特定值。在这种情形下，你不得不写出很长的if-then-else语句，就像下面这样。</p>
<pre><code class="language-sh">$ cat test25.sh 
#!/bin/bash 
# looking for a possible value 
# 
if [ $USER = &quot;rich&quot; ] 
then 
   echo &quot;Welcome $USER&quot; 
   echo &quot;Please enjoy your visit&quot; 
elif [ $USER = &quot;barbara&quot; ] 
then 
   echo &quot;Welcome $USER&quot; 
   echo &quot;Please enjoy your visit&quot; 
elif [ $USER = &quot;testing&quot; ] 
then 
   echo &quot;Special testing account&quot; 
elif [ $USER = &quot;jessica&quot; ] 
then 
   echo &quot;Do not forget to logout when you're done&quot; 
else 
   echo &quot;Sorry, you are not allowed here&quot; 
fi 
$  
$ ./test25.sh 
Welcome rich 
Please enjoy your visit 
$ 
</code></pre>
<p>elif语句继续if-then检查，为比较变量寻找特定的值。</p>
<p>有了case命令，就不需要再写出所有的elif语句来不停地检查同一个变量的值了。case命令会采用列表格式来检查单个变量的多个值。</p>
<pre><code class="language-sh">case variable in 
pattern1 | pattern2) commands1;; 
pattern3) commands2;; 
*) default commands;; 
esac
</code></pre>
<p>case命令会将指定的变量与不同模式进行比较。如果变量和模式是匹配的，那么shell会执行为该模式指定的命令。可以通过竖线操作符在一行中分隔出多个模式模式。星号会捕获所有与已知模式不匹配的值。这里有个将if-then-else程序转换成用case命令的例子。</p>
<pre><code class="language-sh">$ cat test26.sh 
#!/bin/bash 
# using the case command 
# 
case $USER in 
rich | barbara) 
   echo &quot;Welcome, $USER&quot; 
   echo &quot;Please enjoy your visit&quot;;; 
testing) 
  echo &quot;Special testing account&quot;;; 
jessica) 
   echo &quot;Do not forget to log off when you're done&quot;;; 
*) 
   echo &quot;Sorry, you are not allowed here&quot;;; 
esac 
$  
$ ./test26.sh 
Welcome, rich 
Please enjoy your visit 
$ 
</code></pre>
<p>case命令提供了一个更清晰的方法来为变量每个可能的值指定不同的选项。</p>
<h2 id="小结">小结</h2>
<ul>
<li>结构化命令允许你改变shell脚本的正常执行流。最基本的结构化命令是if-then语句。该语句允许你执行一个命令并根据该命令的输出来执行其他命令。</li>
<li>也可以扩展if-then语句，加入一组当指定命令失败后由bash shell执行的命令。仅在测试命令返回非零退出状态码时，if-then-else语句才允许执行命令。</li>
<li>也可以将if-then-else语句通过elif语句连接起来。elif等同于使用else if语句，会在测试命令失败时提供额外的检查。</li>
<li>在很多脚本中，你可能希望测试一种条件而不是一个命令，比如数值、字符串内容、文件或目录的状态。test命令为你提供了测试这些条件的简单方法。如果条件为TRUE，test命令会为if-then语句产生退出状态码0。如果条件为FALSE，test命令会为if-then语句产生一个非零的退出状态码。</li>
<li>方括号是与test命令同义的特殊bash命令。可以在if-then语句中将测试条件放在方括号中来测试数值、字符串和文件条件。</li>
<li>双括号使用另一种操作符进行高级数学运算。双方括号命令允许高级字符串模式匹配运算。</li>
<li>最后，本章讨论了case命令。该命令是执行多个if-then-else命令的简便方式，它会参照一个值列表来检查单个变量的值。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[shell语言脚本构建1-shell构建基本脚本]]></title>
        <id>https://wangxf133.github.io/post/shell-yu-yan-jiao-ben-gou-jian-1-shell-gou-jian-ji-ben-jiao-ben</id>
        <link href="https://wangxf133.github.io/post/shell-yu-yan-jiao-ben-gou-jian-1-shell-gou-jian-ji-ben-jiao-ben">
        </link>
        <updated>2019-03-27T11:36:10.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h2 id="1使用多个命令">1.使用多个命令</h2>
<p>shell允许只使用一步就将多个命令串联起来使用。如果要两个命令一起运行，可在同一提示行输入他们，<strong>用分号分隔开 ；</strong></p>
<pre><code>[xiaofei@DESKTOP-U55QOF8 ~]$date ; pwd
Sat Aug  4 15:51:12 DST 2018
/home/xiaofei
</code></pre>
<p>但是每次运行的时候都必须在命令提示符下输入整个命令。这样比较麻烦，所以我们可以将命令合并成一个简单的文本文件。要使用这些命令的时候，我只需要简单的运行这个文本文件。</p>
<h2 id="2创建shell脚本文件">2.创建shell脚本文件</h2>
<p>在创建shell脚本文件时，必须在文件的第一行指定要使用的shell。其格式为：</p>
<pre><code class="language-shell">#!/bin/bash
</code></pre>
<p>在通常的shell脚本中，井号（#）用作注释行。shell并不会处理shell脚本中的注释行。然而，shell脚本文件的第一行是个例外，#后面的惊叹号会告诉shell用哪个shell来运行脚本（是的，你可以使用bash shell，同时还可以使用另一个shell来运行你的脚本）。</p>
<p>在指定了shell之后，就可以在文件的每一行中输入命令，然后加一个回车符。</p>
<pre><code class="language-shell">#!/bin/bash
# 注释信息
date
pwd
</code></pre>
<p>得到结果(有些时候可能会报错，可能是sh文件没有权限，需要用chmof 修改权限)</p>
<pre><code class="language-shell">[xiaofei@DESKTOP-U55QOF8 shell]$sh 1.sh
Sun Aug  5 12:43:56 DST 2018
/mnt/d/shell
[xiaofei@DESKTOP-U55QOF8 shell]$./1.sh
Sun Aug  5 12:44:25 DST 2018
/mnt/d/shell
</code></pre>
<h2 id="3显示消息">3.显示消息</h2>
<p>大多数shell命令都会产生自己的输出，这些输出会显示在脚本所运行的控制台显示器上。很多时候，你可能想要添加自己的文本消息来告诉脚本用户脚本正在做什么。可以通过echo命令来实现这一点。如果在echo命令后面加上了一个字符串，该命令就能显示出这个文本字符串。</p>
<pre><code class="language-shell">$ echo This is a test 
This is a test 
</code></pre>
<p>注意，默认情况下，不需要使用引号将要显示的文本字符串划定出来。但有时在字符串中出现引号的话就比较麻烦了。</p>
<pre><code class="language-shell">$ echo Let's see if this'll work 
Lets see if thisll work
</code></pre>
<p>echo命令可用单引号或双引号来划定文本字符串。如果在字符串中用到了它们，你需要在文本中使用其中一种引号，而用另外一种来将字符串划定起来。</p>
<pre><code class="language-sh">$ echo &quot;This is a test to see if you're paying attention&quot; 
This is a test to see if you're paying attention 
$ echo 'Rich says &quot;scripting is easy&quot;.' 
Rich says &quot;scripting is easy&quot;. 
</code></pre>
<p>所有的引号都可以正常输出了。<br>
可以将echo语句添加到shell脚本中任何需要显示额外信息的地方。</p>
<pre><code class="language-sh">#!/bin/bash
# 注释信息

echo The time and pwd are:
date
echo &quot;where's file location:&quot;
pwd
</code></pre>
<p>当运行这个脚本时，它会产生如下输出。</p>
<pre><code class="language-sh">[xiaofei@DESKTOP-U55QOF8 shell]$sh 1.sh

The time and pwd are:
Sun Aug  5 12:55:22 DST 2018
where's file location:
/mnt/d/shell
</code></pre>
<p>但如果想把文本字符串和命令输出显示在同一行中，该怎么办呢？可以用echo语句的-n参数。只要将第一个echo语句改成这样就行(用处暂不太大)：</p>
<pre><code class="language-sh">echo -n &quot;The time and date are: &quot; 
</code></pre>
<p>需要在字符串的两侧使用引号，<strong>保证要显示的字符串尾部有一个空格</strong>。命令输出将会在紧接着字符串结束的地方出现。现在的输出会是这样：</p>
<pre><code class="language-sh">$ ./test1 
The time and date are: Mon Feb 21 15:42:23 EST 2014 
Let's see who's logged into the system: 
Christine tty2         2014-02-21 15:26 
Samantha tty3         2014-02-21 15:26 
Timothy  tty1         2014-02-21 15:26 
user     tty7         2014-02-19 14:03 (:0) 
user     pts/0        2014-02-21 15:21 (:0.0) 
</code></pre>
<h2 id="4使用变量">4.使用变量</h2>
<p>运行shell脚本中的单个命令自然有用，但这有其自身的限制。通常你会需要在shell命令使用其他数据来处理信息。这可以通过变量来实现。变量允许你临时性地将信息存储在shell脚本中，以便和脚本中的其他命令一起使用。本节将介绍如何在shell脚本中使用变量。</p>
<h4 id="41-环境变量">4.1 环境变量</h4>
<p>在脚本中，你可以在环境变量名称之前加上美元符（$）来使用这些环境变量。下面的脚本演示了这种用法。</p>
<pre><code class="language-sh">#!/bin/bash
# 注释信息

echo &quot;User info for userid: $USER&quot;
echo UID: $UID
echo HOME: $HOME
</code></pre>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>U</mi><mi>S</mi><mi>E</mi><mi>R</mi><mi mathvariant="normal">、</mi></mrow><annotation encoding="application/x-tex">USER、</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord cjk_fallback">、</span></span></span></span>UID和$HOME环境变量用来显示已登录用户的有关信息。脚本输出如下：</p>
<pre><code class="language-sh">[xiaofei@DESKTOP-U55QOF8 shell]$sh 2.sh
User info for userid: xiaofei
UID:
HOME: /home/xiaofei
</code></pre>
<p>注意，echo命令中的环境变量会在脚本运行时替换成当前值。另外，在第一个字符串中可以将$USER系统变量放置到双引号中，而shell依然能够知道我们的意图。但采用这种方法也有一个问题。看看下面这个例子会怎么样。</p>
<pre><code class="language-sh">$ echo &quot;The cost of the item is $15&quot; 
The cost of the item is 5 
</code></pre>
<p>显然这不是我们想要的。只要脚本在引号中出现美元符，它就会以为你在引用一个变量。在这个例子中，脚本会尝试显示变量$1（但并未定义），再显示数字5。要显示美元符，你必须在它前面放置一个反斜线。</p>
<pre><code class="language-sh">$ echo &quot;The cost of the item is \$15&quot; 
The cost of the item is $15 
</code></pre>
<p>看起来好多了。反斜线允许shell脚本将美元符解读为实际的美元符，而不是变量。</p>
<h4 id="42-用户变量">4.2 用户变量</h4>
<p>除了环境变量，shell脚本还允许在脚本中定义和使用自己的变量。定义变量允许临时存储数据并在整个脚本中使用，从而使shell脚本看起来更像一个真正的计算机程序。</p>
<p>用户变量可以是任何由字母、数字或下划线组成的文本字符串，长度不超过20个。用户变量区分大小写，所以变量Var1和变量var1是不同的。<br>
使用等号将值赋给用户变量。在变量、等号和值之间不能出现空格。<br>
赋值例子：</p>
<pre><code>var1=10 
var2=-57 
var3=testing 
var4=&quot;still more testing&quot; 
</code></pre>
<p>shell脚本会自动决定变量值的数据类型。在脚本的整个生命周期里，shell脚本中定义的变量会一直保持着它们的值，但在shell脚本结束时会被删除掉。<br>
与系统变量类似，用户变量可通过美元符引用。</p>
<pre><code class="language-sh">$ cat test3.sh
#!/bin/bash 
# testing variables 
days=10 
guest=&quot;Katie&quot; 
echo &quot;$guest checked in $days days ago&quot; 
days=5 
guest=&quot;Jessica&quot; 
echo &quot;$guest checked in $days days ago&quot;
</code></pre>
<p>运行脚本会有如下输出。</p>
<pre><code class="language-sh">[xiaofei@DESKTOP-U55QOF8 shell]$sh test3.sh
Katie checked in 10 days ago
Jessica checked in 5 days ago
</code></pre>
<p>变量每次被引用时，都会输出当前赋给它的值。重要的是要记住，引用一个变量值时需要使用美元符，而引用变量来对其进行赋值时则不要使用美元符。通过一个例子你就能明白意思。</p>
<pre><code class="language-sh">$ cat test4.sh
#!/bin/bash 
# assigning a variable value to another variable 
 
value1=10 
value2=$value1 
echo The resulting value is $value2
</code></pre>
<p>在赋值语句中使用value1变量的值时，仍然必须用美元符。这段代码产生如下输出。</p>
<pre><code>$sh test4.sh 
The resulting value is 10 
</code></pre>
<p>要是忘了用美元符，使得value2的赋值行变成了这样：</p>
<pre><code>value2=value1 
</code></pre>
<p>那你会得到如下输出：</p>
<pre><code>$sh test4.sh 
The resulting value is value1 
</code></pre>
<p>没有美元符，shell会将变量名解释成普通的文本字符串，通常这并不是你想要的结果。</p>
<h4 id="43-命令替换">4.3 命令替换</h4>
<p>shell脚本中最有用的特性之一就是可以从命令输出中提取信息，并将其赋给变量。把输出赋给变量之后，就可以随意在脚本中使用了。这个特性在处理脚本数据时尤为方便。</p>
<p>有两种方法可以将命令输出赋给变量：</p>
<ul>
<li>反引号字符 (`)</li>
<li>$() 格式</li>
</ul>
<p>要注意反引号字符，这可不是用于字符串的那个普通的单引号字符。由于在shell脚本之外很少用到，你可能甚至都不知道在键盘什么地方能找到这个字符。但你必须慢慢熟悉它，因为这是许多shell脚本中的重要组件。提示：在美式键盘上，它通常和波浪线（~）位于同一键位。</p>
<p>命令替换允许你将shell命令的输出赋给变量。尽管这看起来并不那么重要，但它却是脚本编程中的一个主要组成部分。</p>
<p>要么用一对反引号把整个命令行命令围起来：</p>
<pre><code class="language-sh">testing='date' 
</code></pre>
<p>要么使用$()格式：</p>
<pre><code class="language-sh">testing=$(date)
</code></pre>
<p>shell会运行命令替换符号中的命令，并将其输出赋给变量testing。注意，赋值等号和命令替换字符之间没有空格。这里有个使用普通的shell命令输出创建变量的例子。</p>
<pre><code class="language-sh">$ cat test5.sh 
#!/bin/bash 
testing=$(date) 
echo &quot;The date and time are: &quot; $testing
</code></pre>
<p>变量testing获得了date命令的输出，然后使用echo语句显示出它的值。运行这个shell脚本生成如下输出。</p>
<pre><code class="language-sh">$sh test5.sh
The date and time are:  Mon Aug 6 15:05:40 DST 2018
</code></pre>
<p>下面这个例子很常见，它在脚本中通过命令替换获得当前日期并用它来生成唯一文件名。</p>
<pre><code class="language-sh">#!/bin/bash 
# copy the /usr/bin directory listing to a log file 
today=$(date +%y%m%d) 
ls /usr/bin -al &gt; log.$today 
</code></pre>
<p>today变量是被赋予格式化后的date命令的输出。这是提取日期信息来生成日志文件名常用的一种技术。+%y%m%d格式告诉date命令将日期显示为两位数的年月日的组合。</p>
<pre><code class="language-sh">$date +%y%m%d
180806
</code></pre>
<p>这个脚本将日期值赋给一个变量，之后再将其作为文件名的一部分。文件自身含有目录列表的重定向输出。运行该脚本之后，应该能在目录中看到一个新文件。</p>
<p>目录中出现的日志文件采用$today变量的值作为文件名的一部分。日志文件的内容是/usr/bin目录内容的列表输出。如果脚本在明天运行，日志文件名会是log.140201，就这样为新的一天创建一个新文件。</p>
<h2 id="5重定向输入和输出">5.重定向输入和输出</h2>
<p>有些时候你想要保存某个命令的输出而不仅仅只是让它显示在显示器上。bash shell提供了几个操作符，可以将命令的输出重定向到另一个位置（比如文件）。重定向可以用于输入，也可以用于输出，可以将文件重定向到命令输入。本节介绍了如何在shell脚本中使用重定向。</p>
<h4 id="51输出重定向">5.1输出重定向</h4>
<p>最基本的重定向将命令的输出发送到一个文件中。bash shell用大于号（&gt;）来完成这项功能：</p>
<pre><code>command &gt; outputfile
</code></pre>
<p>如果输出文件已经存在了，重定向操作符会用新的文件数据覆盖已有文件。<br>
有时，你可能并不想覆盖文件原有内容，而是想要将命令的输出追加到已有文件中，比如你正在创建一个记录系统上某个操作的日志文件。在这种情况下，可以用双大于号（&gt;&gt;）来追加数据。</p>
<h4 id="52输入重定向">5.2输入重定向</h4>
<p>输入重定向和输出重定向正好相反。输入重定向将文件的内容重定向到命令，而非将命令的输出重定向到文件。</p>
<p>输入重定向符号是小于号（&lt;）：</p>
<pre><code>command &lt; outputfile
</code></pre>
<p>一个简单的记忆方法就是：在命令行上，命令总是在左侧，而重定向符号“指向”数据流动的方向。小于号说明数据正在从输入文件流向命令。<br>
这里有个和wc命令一起使用输入重定向的例子。</p>
<pre><code>$ wc &lt; test6 
      2      11      60
</code></pre>
<p>wc命令可以对对数据中的文本进行计数。默认情况下，它会输出3个值：<br>
 文本的行数<br>
 文本的词数<br>
 文本的字节数</p>
<p>通过将文本文件重定向到wc命令，你立刻就可以得到文件中的行、词和字节的计数。这个例子说明test6文件有2行、11个单词以及60字节。</p>
<hr>
<p><strong>这个暂时不知道怎么用，先放着</strong></p>
<p>还有另外一种输入重定向的方法，称为内联输入重定向（inline input redirection）。这种方法无需使用文件进行重定向，只需要在命令行中指定用于输入重定向的数据就可以了。乍看一眼，这可能有点奇怪，但有些应用会用到这种方式</p>
<hr>
<h2 id="6管道">6.管道</h2>
<p>有时需要将一个命令的输出作为另一个命令的输入。</p>
<p>在美式键盘上，它通常和反斜线（\）位于同一个键。管道被放在命令之间，将一个命令的输出重定向到另一个命令中：</p>
<pre><code>command1 | command2 
</code></pre>
<p>不要以为由管道串起的两个命令会依次执行。Linux系统实际上会同时运行这两个命令，在系统内部将它们连接起来。在第一个命令产生输出的同时，输出会被立即送给第二个命令。数据传输不会用到任何中间文件或缓冲区。</p>
<h2 id="7执行数学运算">7.执行数学运算</h2>
<p>另一个对任何编程语言都很重要的特性是操作数字的能力。遗憾的是，对shell脚本来说，这个处理过程会比较麻烦。在shell脚本中有两种途径来进行数学运算。</p>
<h4 id="71-expr命令">7.1 expr命令</h4>
<p>最开始，Bourne shell提供了一个特别的命令用来处理数学表达式。expr命令允许在命令行上处理数学表达式，但是特别笨拙。</p>
<pre><code>$ expr 1 + 5 
6 
</code></pre>
<p>不常见。不详述！</p>
<h4 id="72-使用方括号">7.2 使用方括号</h4>
<p>bash shell为了保持跟Bourne shell的兼容而包含了expr命令，但它同样也提供了一种更简单的方法来执行数学表达式。在bash中，在将一个数学运算结果赋给某个变量时，可以用美元符和方括号（$[ operation ]）将数学表达式围起来。</p>
<pre><code>$ var1=$[1 + 5] 
$ echo $var1 
6 
$ var2=$[$var1 * 2] 
$ echo $var2 
12 
</code></pre>
<p>用方括号执行shell数学运算比用expr命令方便很多。这种技术也适用于shell脚本。</p>
<pre><code>$ cat test7 
#!/bin/bash 
var1=100 
var2=50 
var3=45 
var4=$[$var1 * ($var2 - $var3)] 
echo The final result is $var4
</code></pre>
<p>同样，注意在使用方括号来计算公式时，不用担心shell会误解乘号或其他符号。shell知道它不是通配符，因为它在方括号内.</p>
<p>在bash shell脚本中进行算术运算会有一个主要的限制,bash shell数学运算符只支持整数运算。若要进行任何实际的数学计算，这是一个巨大的限制。</p>
<h4 id="73-浮点解决方案">7.3 浮点解决方案</h4>
<p>有几种解决方案能够克服bash中数学运算的整数限制。最常见的方案是用内建的bash计算器，叫作bc。<br>
暂不详解！！</p>
<h2 id="8退出脚本">8.退出脚本</h2>
<p>暂不详解！！</p>
<h2 id="9小结">9.小结</h2>
<p>bash shell脚本允许你将多个命令串起来放进脚本中。创建脚本的最基本的方式是将命令行中的多个命令通过分号分开来。shell会按顺序逐个执行命令，在显示器上显示每个命令的输出。</p>
<p>你也可以创建一个shell脚本文件，将多个命令放进同一个文件，让shell依次执行。shell脚本文件必须定义用于运行脚本的shell。这个可以通过#!符号在脚本文件的第一行指定，后面跟上shell的完整路径。</p>
<p>在shell脚本内，你可以通过在变量前使用美元符来引用环境变量。也可以定义自己的变量以便在脚本内使用，并对其赋值，甚至还可以通过反引号或$()捕获的某个命令的输出。在脚本中可以通过在变量名前放置一个美元符来使用变量的值。</p>
<p>bash shell允许你更改命令的标准输入和输出，将其重定向到其他地方。你可以通过大于号将命令输出从显示器屏幕重定向到一个文件中。也可以通过双大于号将输出数据追加到已有文件。小于号用来将输入重定向到命令。你可以将文件内容重定向到某个命令。<br>
Linux管道命令（断条符号）允许你将命令的输出直接重定向到另一个命令的输入。Linux系统能够同时运行这两条命令，将第一个命令的输出发送给第二个命令的输入，不需要借助任何重定向文件。<br>
bash shell提供了多种方式在shell脚本中执行数学操作。expr命令是一种进行整数运算的简便方法。在bash shell中，你也可以通过将美元符号放在由方括号包围的表达式之前来执行基本的数学运算。为了执行浮点运算，你需要利用bc计算器命令，将内联数据重定向到输入，然后将输出存储到用户变量中。</p>
<p>最后，本章讨论了如何在shell脚本中使用退出状态码。shell中运行的每个命令都会产生一个退出状态码。退出状态码是一个0～255的整数值，表明命令是否成功执行；如果没有成功，可能的原因是什么。退出状态码0表明命令成功执行了。你可以在shell脚本中用exit命令来声明一个脚本完成时的退出状态码。</p>
<p>到目前为止，脚本中的命令都是按照有序的方式一个接着一个处理的。在下章中，你将学习如何用一些逻辑流程控制来更改命令的执行次序。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[StatQuest学习笔记04——拟合]]></title>
        <id>https://wangxf133.github.io/post/statquest-xue-xi-bi-ji-04-ni-he</id>
        <link href="https://wangxf133.github.io/post/statquest-xue-xi-bi-ji-04-ni-he">
        </link>
        <updated>2019-03-27T11:35:13.000Z</updated>
        <content type="html"><![CDATA[<!--More-->
<h2 id="前言">前言</h2>
<p>这篇笔记是StatQuest视频的第13到第15，文件13内容是拟合度；文件14是内容是线性回归；文件15是局部加权最小二乘法。</p>
<hr>
<p>在这篇笔记中，我们需要弄清楚几个问题：</p>
<ul>
<li>什么是相关系数（correlation，简称为R），相关系数的值有什么意义？</li>
<li>我们为什么关注R的平方？</li>
<li>最小二乘法的原理．</li>
</ul>
<h2 id="第1个案例r的平方">第1个案例：R的平方</h2>
<p>先看一个案例，下图是小鼠的体重与小鼠编号的散点图，如下所示：<br>
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180606/I88BACB2C7.png?imageslim" alt=""></p>
<p>红色的是点是小鼠的体重，黑色的横线是平均值。x轴上是小鼠的编号，如果我们要查看这组数据的变异（variation），我们就把每只小鼠的体重减去平均值，然后再平方，再加起来（这个在统计学上叫离均差平方和，英文是sum of squares of deviations from mean），用数学公式就是下面的这个样子：</p>
<blockquote>
<p>离均差平方和(SS - sum of squares of deviation from mean)是统计学中度量离散趋势的重要指标之一，SS越大说明总体的变异程度越大，说明数据离散程度越大。<br>
它的计算方式是计算每个观测值与均值的差，将其平方后相加。可以看出，离均差平方和与方差之间的关系，只要对离均差平方和再除以向本的数量，就会得到方差。</p>
</blockquote>
<p><img src="http://ortxpw68f.bkt.clouddn.com/professional/180606/Hj239BG5DE.png?imageslim" alt=""></p>
<p>此时我们再找一种方法绘制这个散点图，此时将x轴坐标改为小鼠的大小，y轴还是小鼠的体重，此时散点图就是下图这个样子：<br>
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180606/D9bfjL9i7g.png?imageslim" alt=""></p>
<p>此时，它的平均值还是不变的，还是如下图的样子：<br>
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180606/7bmGhLBi4J.png?imageslim" alt=""></p>
<p>从这个图上，我们直观上可以看出，小鼠的体重貌似是随着小鼠的大小而增加的（这个很好理解，不解释）。此时，我们可以再想一下，我们是否能够通过小鼠的大小来预测它的体重？我们画一条线，大致符合这些数据点的分布，如下所示：<br>
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180606/Hd2jFhEd2l.png?imageslim" alt=""></p>
<p>此时，如果我们已知一个小鼠的大小（size），我们就能够根据这条直线大致知道这个小鼠的体重。但是此时有个问题，这条直接是否能够比平均值代表这批小鼠的大小与体重的关系？其实是可以的，我们有个指标，就是R的平方，它能判断某条直线是否代表了小鼠的大小和体重的关系，如下所示：<br>
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180606/F4aD1GFGBE.png?imageslim" alt=""></p>
<p>此时我们可以计算这个直线与均值的差异，其实就是计算R2<br>
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180606/AKlI1J7Jke.png?imageslim" alt=""></p>
<p>通过计算，var(mean)=32,Var(line)=6，根据公式，R2R2如下所示：<br>
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180606/GFLkH7010k.png?imageslim" alt=""></p>
<p>注：R2在统计学上叫决定系数（determination coefficient），它反映了因变量的变异能够被模型（纳入的自变量）所解释的比例，也就是模型解释的变异占总变异的比例，此案例中，这条直线能够解释81%的体重与大小的关系。</p>
<p>这个案例中讲的情况我们在用BCA测蛋白浓度法时经常使用，x轴是吸光度，y轴是蛋白含量，通过做曲线，找出吸光度与蛋白浓度的关系，曲线做得好，R的平方能达到0.99，如下所示：</p>
<p><img src="http://ortxpw68f.bkt.clouddn.com/professional/180606/E05A82dC09.png?imageslim" alt=""></p>
<h2 id="第2个案例">第2个案例</h2>
<p>再看一个案例，在这个案例中，x轴是小鼠嗅岩石所花的时间（我不太清楚这是什么实验，照字面翻译了），y轴是小鼠的体重，它的散点图以及计算的R平方如下所示：<br>
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180606/AD9j5DJ4c5.png?imageslim" alt=""></p>
<p>结果显示，R的平方是6%，它也就是说小鼠嗅岩石所花的时间与小鼠的体重关系不大，这条蓝色只能解释6%的变异。</p>
<h2 id="r平方的意义">R平方的意义</h2>
<p>因此，我们在做某条直线来表示两个变量之间的关系时，如果R的平方是0.9，那么我们可以说，<strong>这条直接可以解释这两个变量90%的变异</strong>。如果是0.01，那么我们可以说，这条直接只能解释这两个变量1%的变异，也就是说这两个变量没什么关系。<br>
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180606/910Bd7Cgak.png?imageslim" alt=""></p>
<p>R与R的平方</p>
<p>那么什么是R，什么是R的平方呢？什么时候使用这两个参数？看下图的解释：</p>
<p><img src="http://ortxpw68f.bkt.clouddn.com/professional/180606/78KEgaKB9J.png?imageslim" alt=""></p>
<p>通过情况，评估一个直线的好坏，都是看R平方的，它直接代表了变异，更好解释直线的拟合好坏，而不是看R（很多统计软件中也都是这样）。例如一个直线的R是0.7，另外一个是0.5，那么转换为R的平方，肯定是前者比后者要好，如下所示：</p>
<p><img src="http://ortxpw68f.bkt.clouddn.com/professional/180606/4B22cJ13Fh.png?imageslim" alt=""></p>
<p>但R的平方也有局限，就是R的平方都是正值，没有负值，它不代表两个变量的具体关系，也就是说，这两个变量是正相关（一个增加，另外一个也增加），还是负相关（一个增加，另外一个减少），此时就要看R了，R是正值，表示正相关，R是负值，表示负相关。</p>
<p>结论就是，R的平方表示直线的拟合程度，R表示了两个变量变化的关系。</p>
<h2 id="线性回归">线性回归</h2>
<p>先看一个场景，下图是某个散点图：<br>
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180606/2a53hIiL2J.png?imageslim" alt=""></p>
<p>此时我们要绘制一条直线来代表这些点，这些直线可以有多条，就像下面的这些直线一样：<br>
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180606/DJIKHe7aLC.png?imageslim" alt=""></p>
<p>但此时有个问题：哪一条直线最合适？<br>
问题解决思路如下：<br>
第一，假如我们先随便找条直接，例如y=3.5这条直线，如下所示：<br>
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180606/0JE9m2bal5.png?imageslim" alt=""></p>
<p>我们可以计算这些点与这条直线的接近程序，例如第一个点（x1,y1），如下所示：<br>
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180606/gI7lG006j2.png?imageslim" alt=""></p>
<p>那么第2个点的距离就是这个样子：<br>
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180606/f1F3dF4ijH.png?imageslim" alt=""><br>
再接着，计算第3个，如下所示：<br>
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180606/3C19h8gAAH.png?imageslim" alt=""></p>
<p>还有第4个点：<br>
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180606/9c527i8590.png?imageslim" alt=""></p>
<p>这第4个点与前面3个点不太一样，因为，b-y4是一个负值，第5个点也是如下：<br>
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180606/C23lIeDkG8.png?imageslim" alt=""></p>
<p>第4个点与第5个点和前面的点不太一样，因为前面的b-y1，b-y2，b-y3都是正值，那么最终计算这些点与这个条直接的距离总和时，会相互抵消，为了避免这个问题，可以将所有的数值平方，如下所示：<br>
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180606/cfkahca5D4.png?imageslim" alt=""></p>
<p>此时，计算一下这些值的平方，数值为24.62，这个数值在统计学上叫残差平方和（sum of squared residuals，简称SSE)，残差（residual）指的是实际数据与拟合曲线的差值平方的和，这个值越小，表示实际的数值离拟合曲线的距离越小，也就是越能代表这些真实的数据，求出的这条曲线的方程的过程叫线性回归（Linear regression）<br>
此时，我们再换条曲线试试，就是把上面的这条曲线旋转一下，再计算一下SSE，如下所示：</p>
<p><img src="http://ortxpw68f.bkt.clouddn.com/professional/180606/fcglJic4Bd.png?imageslim" alt=""></p>
<p>它的SSE是18.72，貌似比第一曲线更好，再旋转一下看看：</p>
<p><img src="http://ortxpw68f.bkt.clouddn.com/professional/180606/7A5CI3h038.png?imageslim" alt=""></p>
<p>它的SSE是14.05，貌似更好，再旋转一下试试：<br>
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180606/2h8fH1gh8j.png?imageslim" alt=""></p>
<p>这个SSE是31.71，貌似就比较差了。此时我们再看一下常规的曲线方程，如下所示：</p>
<p><img src="http://ortxpw68f.bkt.clouddn.com/professional/180606/m2kEF7kaem.png?imageslim" alt=""></p>
<p>其中，a代表这条曲线的斜率，b代表截矩。我们要寻找最佳的拟合曲线必然是SSE最小的那条。而在统计学中，我们经常把下面的公式叫做残差平方和，如下所示：<br>
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180606/B5IBG15h4l.png?imageslim" alt=""></p>
<p>由于我们寻找这条曲线（寻找这条曲线，其实就是寻找这条曲线的斜率与截矩）的方法是通过寻找最小的SSE这个原理实现的，因此，这种求直线的方法就叫做最小二乘法（Least squares）（为什么这种方法的中文译名与英语差异这么大？因为平方在中国古代的数学中就叫二乘，因此这种方法就翻译成了最小二乘法），如下所示：</p>
<p><img src="http://ortxpw68f.bkt.clouddn.com/professional/180606/JDmgEJ3HBl.png?imageslim" alt=""></p>
<p>如果我们将上面的这些曲线以及旋转后的曲线的SSE绘制出来，我们就会得到下面的这个图形：<br>
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180606/HBiI9JEALI.png?imageslim" alt=""></p>
<p>x轴上是各种曲线的形状（它们拥有不同的斜率与截矩），y轴是SSE。上面的散点图的本质其实也是一条曲线（数学上的曲线包括弯曲的线与直线，它是点运动的集合），如何找到最佳拟合的曲线（这条曲线指提原始数据的拟合曲线）呢，就是对曲线（这里的曲线指的上图的这条曲线，也就是不同斜率和截矩下的各种曲线的SSE的集合）求导（derivative），那么导数为0时，也就是SSE最小（导数的推导与意义可以参见高中数学），如下所示：<br>
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180606/IlaCmBLlL0.png?imageslim" alt=""></p>
<p>过程如下：<br>
先看第一个点：<br>
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180606/60f84gccKJ.png?imageslim" alt=""></p>
<p>再看第二个点：<br>
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180606/8IaamD6I56.png?imageslim" alt=""></p>
<p>第三个点：<br>
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180606/1bHhicc2Da.png?imageslim" alt=""></p>
<p>在第三个点处的导数斜率为0（这点很重要），还有这些点：<br>
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180606/dgi53mCaee.png?imageslim" alt=""></p>
<p>再回头看第3个点：<br>
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180606/iaa56BhjLi.png?imageslim" alt=""></p>
<p>我们只需要记住，在对原始数据进行拟合时，曲线的旋转代表了不同的斜率a和截矩b。</p>
<p>在计算最佳的拟合曲线时，我们还使用一种三维坐标系（x轴是斜率，y辆是截矩，z值是SSE），如下所示：<br>
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180606/h661AB8AB2.png?imageslim" alt=""></p>
<p>那么如果我们选定一个截矩，然后绘制不同斜率对应的SSE，如下所示：<br>
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180606/388D924jFa.png?imageslim" alt=""></p>
<p>接着，我们按照同样的方法绘制大量不同截矩与斜率的曲线对应的SSE，如下所示：</p>
<p><img src="http://ortxpw68f.bkt.clouddn.com/professional/180606/k9f3kclAIG.png?imageslim" alt=""></p>
<p>然后计算这些曲线的斜率与截矩的导数，然后找出导数为0时的斜率与截矩。这种方法的计算过程通常是由计算机完成的。最终求出的线性回归方程如下所示：<br>
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180606/68cK9g8L4G.png?imageslim" alt=""></p>
<h2 id="局部线性回归">局部线性回归</h2>
<p>现在我看一个散点图，如下所示：</p>
<p><img src="http://ortxpw68f.bkt.clouddn.com/professional/180606/L0iI9gf5kk.png?imageslim" alt=""></p>
<p>我们如果对这散点进行拟合，困难貌似比较大，因为这些散点图不可能用一个方程表示的直线进行拟合。因此，我们为了拟合这种散点图，就要换一种方法，这种方法的核心思想是：</p>
<p>第一，将这些散点通过一个滑动的窗口将它们分成更小的部分，如下所示：</p>
<p><img src="http://ortxpw68f.bkt.clouddn.com/professional/180607/2754EGKj3D.png?imageslim" alt=""></p>
<p>第二，在每个滑动窗口中，对这一小部分数据进行拟合，求出它的线性回归方向，此时，就跟线性回归一样了，最终再把这些线性回归方程汇总起来，其本质我觉得就是微积分的思想，如下所示：<br>
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180607/2im7m9Il3g.png?imageslim" alt=""></p>
<p>下面是具体的思维过程，上面的散点图有点复杂，我们先看一个比较简单的散点图，我们把下面的散点图以x轴的5个单位为基本单位进行窗口的划分，那么第一个滑动窗口中含有5个数据点，就是图中绿色方框圈起来的部分，如下所示：<br>
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180607/Hi5di4l7Aa.png?imageslim" alt=""></p>
<p>此时，我们把这个方框中的第一个点称为这个窗口的焦点（focal point），如下所示：<br>
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180607/D4HI84ab12.png?imageslim" alt=""><br>
在第一个滑动窗口的这5个点中，第2个点就是最接近焦点的点，它距离焦点是1个单位，如下所示：<br>
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180607/8hDacHf4Hk.png?imageslim" alt=""></p>
<p>第3个点就是第2个最接近焦点的点，如下所示：</p>
<p><img src="http://ortxpw68f.bkt.clouddn.com/professional/180607/iEBja97flL.png?imageslim" alt=""></p>
<p>同理，还有第3个，第4个最接近焦点的点，如下所示：<br>
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180607/IB930je8bl.png?imageslim" alt=""></p>
<p>此时，我们对这5个点做一个“加权最小二乘”（weighted least squares），离焦点最近的点它的权重（weight）就大（权重可以理解为影响拟合曲线的影响力），如下所示：</p>
<p><img src="http://ortxpw68f.bkt.clouddn.com/professional/180607/f8mB03iJ4f.png?imageslim" alt=""></p>
<p>由上述描述可知，焦点的权重最大，而其余点的权重与其跟焦点的距离成反比，最远的点（也就是上图中4号点）权重最小，此时，我们先做一个普通的最小二乘法线性回归，此时的回归并不考虑各个点的权重，它的曲线如下所示：</p>
<p><img src="http://ortxpw68f.bkt.clouddn.com/professional/180607/7K4mKbHBJa.png?imageslim" alt=""></p>
<p>我们再做一个加权后的线性回归，如下所示：<br>
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180607/6Lkc9Je5g7.png?imageslim" alt=""></p>
<p>从图中可以知，最后一个点的权重小，它对于这线曲线的斜率影响不大，并不会把斜率拉高，此时我就对这5个数据点有了一条拟合曲线，此时，我们把第1个点（也就是上图黑色的点）的x轴坐标代入这个拟合的曲线方程，求出一个新的点的坐标，这个新的点的坐标就是我们最终要拟合的曲线上的点，就是下图的红叉所在位置（虽然这个红叉在图片上与第1个点重合，但它们不是一个点），如下所示：<br>
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180607/ckL3L8f6HJ.png?imageslim" alt=""></p>
<p>我们再继续。此时我们把第2个点当作是焦点，如下所示：<br>
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180607/lDfA33l186.png?imageslim" alt=""></p>
<p>这个滑动窗口中还是含有原来的4个点，但是离焦点最近的点的已经变成了2个，它们离焦点是1个单位，如下所示：</p>
<p><img src="http://ortxpw68f.bkt.clouddn.com/professional/180607/BgKfBdCHiH.png?imageslim" alt=""></p>
<p>接着，离焦点次近一点的是离焦点有2个单位的点，如下所示：<br>
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180607/KGaial5089.png?imageslim" alt=""></p>
<p>最远的点，是距离焦点有3个单位的点，如下所示：<br>
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180607/iBJj3FEl1m.png?imageslim" alt=""></p>
<p>此时，我们使用加权最小二乘法时，焦点权重最大，如下所示：<br>
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180607/faL4m0i9L7.png?imageslim" alt=""></p>
<p>两边的两个点权重次之，如下所示：<br>
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180607/f5Dc4il0m7.png?imageslim" alt=""></p>
<p>最远的点，权重最小，此时我们画出拟合曲线，如下所示：<br>
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180607/B6f5D80Kjm.png?imageslim" alt=""></p>
<p>此时，我们利用这个方程求出最终要拟合曲线上的点（这个点的x轴坐标与上面第2个点的x轴坐标一样，但y轴坐标不一样），因此，这个红叉所在点（虽然图片上看上去这个红叉是与第2个点重合，其实是不是重合的）是我们最终要拟合的曲线上的第2个点，如下所示：<br>
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180607/9ieKF2IlFb.png?imageslim" alt=""></p>
<p>此时，我们再研究第3个点，将它当成焦点，如下所示：<br>
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180607/G31G6e8hii.png?imageslim" alt=""></p>
<p>方法如同第1个点和第2个点一样，以第3个点为焦点拟合的曲线如下所示：<br>
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180607/DaGKkifCj7.png?imageslim" alt=""></p>
<p>其中，红叉的地方，就是我们最终要拟合的曲线上的点，接着，我们看第4个点，如果第4个点是焦点的话，此时有点不太一样，这个滑动窗口与前面第1，2，3个点的窗口都有所不同（1，2，3个点的窗口其实是一样的，因为距离它们最近的5个点都相同），而第4个点的话，离它最近的4个点（一个窗口一共是5个点），并不包括第1个点，如下所示：</p>
<p><img src="http://ortxpw68f.bkt.clouddn.com/professional/180607/I2K851gC1H.png?imageslim" alt=""></p>
<p>离第4个点最近的两个点在它的两边，如下所示：<br>
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180607/Fd52hD8FhJ.png?imageslim" alt=""></p>
<p>其次，离它次近的两个点是稍远一点的，如下所示：<br>
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180607/0EHHhC7h7L.png?imageslim" alt=""><br>
从图上可知，我们划分窗口宽度的时候，只考虑x轴，并不考虑y轴。此时，我们采用加权最小二乘法进行拟合，如下所示：</p>
<p><img src="http://ortxpw68f.bkt.clouddn.com/professional/180607/3jfdDA4b2C.png?imageslim" alt=""></p>
<p>然后，根据这条曲线，计算我们最终要拟合曲线上的点，它的求法是将第4个点的x轴坐标代入上面的曲线方程，求出这个拟合曲线上的点，如下所示（此时的这个点与第4个点并不重合，只是x轴坐标一样）：</p>
<p><img src="http://ortxpw68f.bkt.clouddn.com/professional/180607/25GhCh0dfF.png?imageslim" alt=""></p>
<p>此时，我们再看一下我们前面求出的新的点，如下所示：</p>
<p><img src="http://ortxpw68f.bkt.clouddn.com/professional/180607/kEL3LDjl2m.png?imageslim" alt=""></p>
<p>按照这个方法，我们划出一个窗口，然后求出这个窗口中的拟合曲线，然后计算这个窗口中焦点对应的最终拟合曲线上的新的点，最终，求出的所有新的点如下图中的红叉所示：<br>
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180607/L9ddJi9mf5.png?imageslim" alt=""></p>
<p>从下面的图我们可知，黑色椭圆中的这些点是被最上面的点拉上去了，如下所示：</p>
<p><img src="http://ortxpw68f.bkt.clouddn.com/professional/180607/e3IL99dLg9.png?imageslim" alt=""></p>
<p>而最上面的这个点就是个离群点（outliner），为了避免这个点对整体拟合效果的影响，我们需要根据这个点距离原始点和新生成点的距离，对这个点额外添加一个权重，如下所示：</p>
<p><img src="http://ortxpw68f.bkt.clouddn.com/professional/180607/e102G9aG6J.png?imageslim" alt=""></p>
<p>从上面的图还可以知道，大括号标中的点的权重比较低，因为原始点与新生成的点距离比较远。而下面的这个点权重更低，因为它离得更远，如下所示：</p>
<p><img src="http://ortxpw68f.bkt.clouddn.com/professional/180607/8LiGDcHKHB.png?imageslim" alt=""></p>
<p>根据新生成的点与原始点之间的距离，我们可以计算出新的权重，这样我们此时就有了两组权重，<br>
第一组就是基于每个窗口中，每个点距离焦点距离的原始权重，如下所示：<br>
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180607/KgAkeA274i.png?imageslim" alt=""></p>
<p>第二组就是基于原始点与新生成点的距离的权重，如下所示：<br>
根据这些权重调整了原始点与新生成点的位置后，我们就可以看到“新-新”的点（new-new point），从下图中的第4个点和第5个点就能明显看出来，它们之间的距离缩短了，如下所示，利用这些调整后的点绘制曲线，就会显得更加光滑。</p>
<p><img src="http://ortxpw68f.bkt.clouddn.com/professional/180607/Bh0A3adHCH.png?imageslim" alt=""></p>
<p>我们把所有的点都进行调整，我们就会得到一个完美，平滑的回归曲线，如下所示：<br>
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180607/10HH8A1kEL.png?imageslim" alt=""></p>
<p>不过，这个调整过程要不断地进行几次才能得到理想的平滑曲线，以下就是最终得到的曲线：</p>
<p><img src="http://ortxpw68f.bkt.clouddn.com/professional/180607/1cAB3l9K6d.png?imageslim" alt=""></p>
<p>另外的思考</p>
<p>我们试想一下，在第1个窗口中，我们采用回归曲线是直线，其实它也可以做成抛物线，如下所示：</p>
<p><img src="http://ortxpw68f.bkt.clouddn.com/professional/180607/m01AKA5Bbi.png?imageslim" alt=""></p>
<p>我们先看一个案例，还是最初的散点图：<br>
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180607/A6AllAK8FG.png?imageslim" alt=""></p>
<p>下图的黑色曲线是在每一步都采用了加权最小二乘法得到的曲线，蓝色曲线是在每一步都采用了抛物线进行拟合的曲线：</p>
<p><img src="http://ortxpw68f.bkt.clouddn.com/professional/180607/J7lbh4a9l2.png?imageslim" alt=""></p>
<p>从图中我们可以看到，貌似划线的拟合效果更好。在而R语言中，如果只想拟合为常规的这种直线，可以采用<strong>lowess()函数</strong>，如果想要拟合为抛物线(或直线??)，可以采用<strong>loess()函数</strong>，如下所示：<br>
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180607/a9elCdCeI9.png?imageslim" alt=""></p>
<p>在Ｒ中，使用loess()函数还能绘制出曲线的置信区间，如下所示：</p>
<p><img src="http://ortxpw68f.bkt.clouddn.com/professional/180607/aDH2Lb7cem.png?imageslim" alt=""></p>
<p>关于滑动窗口的设置取决于用户自身，滑动窗口的划分可以按照精确的单位进行划分，也可以按照百分比来进行划分，下图我认为是使用了5%这个比例来进行划分的（从图上大概可以看出来，5%的比例范围内，这个曲线是直线）：</p>
<p><img src="http://ortxpw68f.bkt.clouddn.com/professional/180607/FAbeGjJ88h.png?imageslim" alt=""></p>
<p>下图的蓝色拟合曲线是使用了总数据点的三分之一进行窗口划分的：<br>
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180607/d72h86EFj5.png?imageslim" alt=""></p>
<p>下图的红色曲线是使用了R语言中loess()这个函数的默认值进行拟合的，而它的默认值是75%的数据点，如下所示：</p>
<p><img src="http://ortxpw68f.bkt.clouddn.com/professional/180607/E16gaHkf5D.png?imageslim" alt=""></p>
<p>关于权重<br>
计算权重的公式仅仅是出于数学上的考虑，并没有考虑它们的生物学或物理学上的意义。</p>
<p><img src="http://ortxpw68f.bkt.clouddn.com/professional/180607/Hb8GjCGj0g.png?imageslim" alt=""></p>
<p>下图的左图是考虑了每个数据点距离x轴的距离后计算的权重，下图的右图是考虑了原始数据点与新生成数据点的距离后计算的权重：</p>
<p><img src="http://ortxpw68f.bkt.clouddn.com/professional/180607/Cg0b0h8I0h.png?imageslim" alt=""></p>
<p>下图左图是对这两种权重进行比较，我们可以发现，这两种权重有一些微妙的差别，而右图表示的是另外的一种权重函数（右图没听清楚原视频中说的是什么意思，有空翻一下书再来补充）：<br>
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180607/LaIeacaadC.png?imageslim" alt=""></p>
<p>参考：http://rvdsd.top/2018/06/04/BioStatistics/%E7%94%9F%E7%89%A9%E7%BB%9F%E8%AE%A1-StatQuest%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B004-%E6%8B%9F%E5%90%88/</p>
]]></content>
    </entry>
</feed>